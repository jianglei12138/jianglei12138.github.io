<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  从Java对象创建说起 |   Lemon </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header-wrapper">

  <nav class="inner">
    <div class="title">
    </div>

    <ul class="menu">
      
      
      <li class="item">
        <a class="link" id="menu-home" href="/">
          <i class="iconfont icon-home">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-archives" href="/archives">
          <i class="iconfont icon-archives">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-tags" href="/tags">
          <i class="iconfont icon-tags">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-about" href="/about">
          <i class="iconfont icon-about">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-search">
          <i class="iconfont icon-search">
        </i></a>
        

        
      
    </li></ul>
  </nav>
</header>

<header class="mobile-header-wrapper">
  <i id="mobile-toggle" class="iconfont icon-menu mobile-toggle"></i>
</header>   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          <article class="post slideDownMin">
  
	
<div class="header">
		<p class="title">	
			从java对象创建说起
		</p>
		<div class="info">	
			<time>
				Oct 25, 2019
			</time>

			
			
				<i class="iconfont icon-words"></i>
				<span class="words">15909
				</span>
			
		</div>
</div> 
	

    <script type="text/x-mathjax-config">
        var post = document.getElementsByClassName("post")[0];  
        MathJax.Hub.Config({
            showProcessingMessages: false,
            messageStyle: "none",    
            tex2jax: {
                inlineMath:  [ ["$", "$"] , ["\\(","\\)"]],
                displayMath: [ ["$$","$$"] , ["\\[","\\]"]],
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],
            },
            "HTML-CSS": {            
                showMathMenu: false
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub,post]);
    </script>
    <style>.MathJax{outline:0;}</style>

    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.2/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
 

	  <div class="typo post-content ">

		

			
					<p>试想一下，如果我们在代码中直接通过关键字new创建了一个对象，JVM会做那些工作从而保证我们后续的使用不出问题呢？java中内存究竟是怎么分配的呢？为什么java new的对象不需要手动释放？带着这些疑问我们一起来研究一下java中对象创建的相关知识。</p>
 <a id="more"></a>



<h2 id="Java运行时内存区域划分"><a href="#Java运行时内存区域划分" class="headerlink" title="Java运行时内存区域划分"></a>Java运行时内存区域划分</h2><p>如果经常看一些博客或者有过一些面试的经验，可能经常会看到或者听到这样的结论：”Java中通过new关键字创建对象后，对象是放在内存的堆区，对象的引用是放到栈区“。 那么什么是堆？什么是栈呢？</p>
<p>按照字面意思上来说，栈是常见的数据结构，遵循先进后出的规则，堆则相反。但是java中是怎么堆与栈区的到底分别是指哪一块区域，到底存放的是什么呢？通过阅读《深入理解Java虚拟机》与《Java虚拟机规范(Java SE 8版)》相关书籍，可以得到如下java运行时内存区域分配图</p>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/memory.png" alt="memory" style="zoom:50%;align:right"></div>

<p>最明显的内存分为线程共享与线程私有区域，所谓线程共享，是指所有线程都能访问到对应内存区域内容，线程私有则相反，内存只能被当前线程拥有者使用。我们一个个来详细说说这些区域。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器，用来指示当前线程运所执行的字节码指令的地址，不难猜到，此块区域并不需要特别大就已经能够满足需求。由于多线程的<strong>隔离</strong>，必须为每一条线程设置一块程序计数器标示线程运行的位置，等待CPU线程切换继续执行。</p>
<p>此处可能我们就会想到一个问题，如果当前线程执行的java方法，它应该存放下一次要执行字节码指令的地址，如果当前线程正在通过Jni执行native方法，那么，程序计数器存放的内容是什么呢？Java虚拟机规范规定，此时此内存的内容是undefined。正是因为这些特殊的性质，<strong>此区域JVM没有规定会出现任何形式的OOM</strong></p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>在线程创建的时候，Java虚拟机会为其创建一个单独的栈空间，规范中规定此区域不需要是连续的，栈常用的两个操作，压栈与弹栈，当线程执行到某个方法调用的时候，会把此方法相关内容，或者叫栈条目，如参数，局部变量，以及异常等入栈，栈条目通过被称为<strong>栈帧</strong>，方法执行结束，把对应栈条目弹出栈。在一个线程中的所有方法调用结束的时候，JVM会清空相应的栈内存，并在终止线程之前回收栈空间。</p>
<div align="center">
<img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/JVM.jpg" alt="JVM" style="zoom: 67%;">
</div>

<p>栈帧结构</p>
<ul>
<li>LVA，local variable array 本地变量表，变量表的大小由编译期决定，编译期间我们其实已经知道了变量的个数（参数和局部变量），局部变量的类型等，所以此区域不受运行时的修改，一旦编译完成不会再改变，是写在class文件中的。LVA的最小单位叫做变量槽Slot，一般一个Slot至少能存下一个boolean，byte，char，int，short，float，reference或者returnAddress（用来实现异常的处理，目前基本被异常表替代）的数据，对于long与double，JVM规定使用两个Slot存放。一般来说针对非static函数，一般第一个Slot存放的是此对象的引用，剩下的按照参数列表进行排序，参数存放完毕后，在根本方法体内部的变量循序和作用于分配其他Slot</li>
<li>OS，operand stack，操作栈，一种LIFO的数据结构，编译期间已经确定最大深度，用来记录运行过程中的内容或者存储计算结果。默认方法刚开始执行时，此空间为空，方法执行过程中会有各种字节码向操作栈中读写内容。</li>
<li>FD，frame data，包括比如方法返回地址，调试信息等。值得注意的是，其中包括一个叫做动态链接的数据，即一个引用指向运行时常量池中的该栈帧所在的方法。</li>
</ul>
<p><strong>JVM虚拟机规范中制定，此区域如果请求栈深度超出虚拟机最大允许的深度，则抛出StackOverflow异常，当然因为需要存储数据，如果申请不到内存，也是会发生OOM</strong></p>
<p>这个虚拟机栈是指上文存放对象引用的栈区么？从上面分析可知，粗略上来说，是的，因为栈帧中LVA存放的就是reference等数据。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>如虚拟机栈相同，虚拟机栈记录的是java的栈帧，本地方法则是对应的native方法的调用，当然JVM对此实现比较自由，不同的虚拟机实现具体不太一致，甚至有的虚拟机是把本地方法与虚拟机栈合并处理的，与虚拟机栈一样，同样存在OOM与StackOverflow异常</p>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/natives.png" alt="native" style="zoom: 67%;">
</div>



<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>刚才有提到，栈帧中FD中存在一项动态链接的数据，指向运行时常量区。这个运行时常量是及方法区的一部分。方法区是线程共享的一部分内存区域。用来存放JVM加载的类（包括方法，属性等），常量，静态变量等数据，另外编译后的代码指令也是放到此处的，因此此块区域叫方法区。方法区在虚拟机启动的时候创建。此区域是堆区的逻辑组成部分，但又与堆区不同，不严谨的说，在某些虚拟机实现中，此区域可能会被叫做<strong>永久代</strong>，这样垃圾回收器就可以把此区域当作堆区进行垃圾回收，自然，因此区域的特殊性，回收带来的回报是很低的。</p>
<p>另外，JVM规定，<strong>如果方法区无法满足申请分配的内存时，抛出OOM异常</strong></p>
<p>回到本节最开始的内容，运行时常量池时什么？方法区的一部分。常量池时class信息中的一部分，用于存放编译期生成的各种常量与符号引用。常量池最终会被加载到运行时常量池中。</p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对于大部分应用来说，堆区应该是最大的一块内存区域，是被所有线程共享的区域。基本所有对象的实例都是在此处被分配，JVM规范是这么定义，所有对象的实例和数组都要在堆上分配（非绝对，见深入理解Java虚拟机）。</p>
<p>堆是内回收的主要区域，对于使用分代算法的虚拟机来说，此区域包括新生代和老年代。另外与方法区一样，<strong>也会抛出OOM异常</strong></p>
<p>关于垃圾回收相关内容，可以参考后续的文章</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是JVM运行时内存的一部分，诞生于Java 1.4中加入的NIO，一种基于Channel于Buffer的IO方式，利用Native直接在堆外分配内存。然后通过一个存储在Java堆的DirectByteBuffer对象作为此内存的引用进行操作。在某一些场景中可以显著提高性能，也有可能会发生OOM</p>
<h4 id="Java新版修改"><a href="#Java新版修改" class="headerlink" title="Java新版修改"></a>Java新版修改</h4><p>另外，<strong>方法区（method area）</strong>只是<strong>JVM规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而<strong>永久代</strong>是<strong>Hotspot</strong>虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。</p>
<p>在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在本地内存的CodeCache区域，其他都存放在永久代PermGen；<br>在Java 7中，Symbol的存储从PermGen移动到了本地内存，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）<br>在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间<strong>Metaspace</strong></p>
<p>好了说了这么多与Java内存分配的东西。那么到底对象是怎么创建的呢？</p>
<h2 id="Java对象创建"><a href="#Java对象创建" class="headerlink" title="Java对象创建"></a>Java对象创建</h2><p>Java是一门面向对象的语言，无时无刻不伴随着对象的创建，与C++不同的是，java所有的方法都必须由class作为载体，无对象无方法。对象创建流程如下</p>
<ul>
<li>通过字节码new的参数从常量池中查找是否有对应的class符号引用</li>
<li>检测class文件是否被加载，解析，初始化<ul>
<li>未加载，执行类加载过程</li>
</ul>
</li>
<li>未新对象分配内存并置0</li>
<li>调用构造方法</li>
</ul>
<h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>想要知道如何new是如何从常量池中查找class的引用，需要知道class文件中究竟放的是什么内容。因此我们首先分析下class文件的结构。class文件一种以8位字节为基础的二进制流，和常见的二进制文件一样，也是由一定规则组成的，我们以下面一则简单的java程序来说明，class的基本结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIN = <span class="string">"Hello World! form constant"</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mAttribute;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAttribute = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(mAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(MAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.main();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完成后，我们得到一个class文件，我们通过hex friend工具分析class文件的基本组成部分。我们先分析前120个字节的内容，hex结果如下</p>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/hex.png" alt="hex120" style="zoom: 67%;">
</div>

<ul>
<li>可以看出来，class文件以0xCAFEBABE开始，这个0xCAFEBABE是class文件的魔数，用来标识此文件是class文件，关于此魔数的由来可以参考java之父的解释 <a href="https://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">Java class file </a>。当然不难想到，Java的logo就是一杯咖啡。</li>
<li>紧接着0x00000034  ，前2个字节0x0000代表minjor次版本号，0x0034主版本号，及十进制的52.0。</li>
<li>紧接着的是常量池的相关内容，常量池个数+常量表，常量池的内容通常是实际上常量表个数+1，其中多出来的一个是指不指向常量池的项目·，0x0034翻译成十进制即52，即后面共有51个常量。每一项都拥有一个常量类型标志tag，长度为1个字节，比如说第一个常量类型是 0x0A，0x0A表示什么类型呢？</li>
</ul>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/constant.png" alt="constant" style="zoom: 67%;">
</div>

<p>表中u1表示一个字节，u2两个字节。查表可知，0x0A（10进制的10）表示<strong>Constant_methodref_info</strong>，此类型的格式是tag+index(方法的类描述符)+index(方法名称与类型描述符)，我们可以得到<strong>Constant_methodref_info</strong>的对应的类描述符是0x000C，即索引是第12个项目，方法名称和类型指向0x0021，换成10进制33，即对应索引为33的<strong>Constan_NameAndType</strong>，按照此中方式我们不难整理出来，所有的常量的内容。但是一个个人工对太复杂了，java给我们提供了现有的工具<strong>javap</strong>，可以用来解析</p>
<div align="center">
  <img src="/images/placeholder.png" alt="javap" style="zoom: 67%;" data-src="./从java对象创建说起/javap.png" class="lazyload">
</div>

<p>如何便可以知道，0x0A方法是Object的构造函数。当然还有我们定义的一些常量字符串，不难看出，常量池存放的内容是 字面量与符号引用，字面量可以理解为我们java语言中经常接触到的常量，比如说文本字符串，final常量等。符号引用则是编译相关的内容。符号引用包括以下方面的内容 1. 类和接口的全限定名，全限定名是什么意思呢？大概可以理解成我可以通过此限定找到对应满足要求的接口或者类，比如说上图中的#12，我可以通过限定名<strong>java/lang/Object</strong>找到对应的Object类 2. 方法的名称与描述符，举例说明即图中 #11 中关于main方法的描述符<strong>com/jvm/test/Main.main:()V</strong>表示方法为com.jvm.test.Main类中存在一个名为main的方法，参数为空，返回值为V即void，关于描述符的定义，后面会有详细的说明 3. 字段的名称与描述符，后面会有详细说明，如图是hex中常量池的所有内容</p>
<div align="center">
  <img src="/images/placeholder.png" alt="constants" style="zoom: 67%;" data-src="./从java对象创建说起/constants.png" class="lazyload">
</div>

<ul>
<li>继续，常量池后面的是访问标志，用两个字节表示，访问标志如下, 也是我们常见的能用在定义类，接口，枚举等常见的一些字段。参见下表可知，我们的Main.class是public，对应的标志是ACC_PUBLIC, 因为ACC_SUPER始终为true，所以我们得到的访问标志值是<br>$$<br>0x0020 | 0x0001 = 0x0021<br>$$<br>由常量池中的hex图片可知，访问标志值就是0x0021。</li>
</ul>
<div align="center">
  <img src="/images/placeholder.png" alt="constants" style="zoom: 67%;" data-src="./从java对象创建说起/access_flag.png" class="lazyload">
</div>

<ul>
<li>访问标志后面接的是 类索引和接口索引，因为接口是可以多实现的，因此这个接口索引是一个数组，通过这些索引，class可以确定其继承关系。如图是Main类的继承关系，0x0007指向常量池中的第7哥索引值，通过上图中javap的输出可知，当前类是<strong>com/jvm/test/Main</strong>, 当前类的父类是 0x000C对应的索引是<strong>java/lang/Object</strong>，0x0000表示当前类有0个接口。</li>
</ul>
<div align="center">
  <img src="/images/placeholder.png" alt="class" style="zoom: 67%;" data-src="./从java对象创建说起/class.png" class="lazyload">
</div>

<ul>
<li><p>确定完继承关系后，可以继续分析接下来的内容，字段表，简单来说就是一些类变量或者实例变量在class文件中的布局，java中通常用可以用来标识一个变量有，<strong>访问控制修饰符（public/private/protected，static，final，volatile，transient）+ 数据类型（基本类型/数组/对象）+ 字段名称</strong> 因为我们可能存在多个字段所以此部分的内容一般是 </p>
<blockquote>
<p>n字段个数2bytes + n * (访问标志2bytes + 名字常量池索引2bytes + 描述符常量池索引 + 属性表相关内容) 属性相关内容留着后续说明</p>
</blockquote>
<p>其中，访问标志值通位操作或计算得到而成，具体对应的标志值如图</p>
<div align="center">
<img src="/images/placeholder.png" alt="field" style="zoom: 67%;" data-src="./从java对象创建说起/field.png" class="lazyload">
</div>
另外，关于描述符此处需要好好说以下，描述符的作用是用来描述字段的类型或者函数的参数列表以及返回值，常见的描述符如下，
<div align="center">
<img src="/images/placeholder.png" alt="descriptor" style="zoom: 67%;" data-src="./从java对象创建说起/descriptor.png" class="lazyload">
</div>

<p>通过此分析，我们可以自己计算这一块的class内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIN = <span class="string">"Hello World! form constant"</span>;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; mAttribute;</span><br></pre></td></tr></table></figure>
<p>因为类Main中有两个变量(换成16进制即0x0002)，第一个修饰符是<br>$$<br>0x0001 | 0x0008 | 0x0010 = 0x0019<br>$$<br>变量名称为<strong>MAIN</strong>，通过查看javap打印得知，其常量池索引为0x000D(#13), 描述符为<strong>Ljava/lang/String;</strong> 其常量池索引为0x000E, 如果属性值我们暂不讨论的化，那么其字段对应的16进制为， 其中…代表属性相关内容，暂时不表</p>
<blockquote>
<p>0x 00 02 00 19 00 0D 00 0E … 00 02 00 10 00 11 …</p>
</blockquote>
<p>可以与hex对比可知，正如我们计算的这样</p>
</li>
<li><p>除了属性我们没有说明外，基本字段已经说完，后面就可以继续说方法表。方法与字段基本一致，也是访问标识 + 名称索引 + 参数索引 + 属性表，不同的是方法的修饰符与变量不同，方法无法使用volatile或者transient修饰，倒是多了native, synchronized, abstract, strictfp等修饰</p>
<div align="center">
<img src="/images/placeholder.png" alt="method" style="zoom: 67%;" data-src="./从java对象创建说起/method.png" class="lazyload">
</div>


</li>
</ul>
<p>比如说Main类中的方法个数为一个构造函数，两个main方法，故共有3个方法</p>
<div align="center">
  <img src="/images/placeholder.png" alt="methods" style="zoom: 67%;" data-src="./从java对象创建说起/methods.png" class="lazyload">
</div>
目前方法的定义已经说清楚，那么方法内部的实现呢？即code是放在哪里的呢？当然一致都在属性表中，接着我们就来说说这期盼已久的属性表

<p>属性表在class文件中算是最复杂的一部分，首先其分类比较多，根据作用不同，放置的位置也不一样，一些列举部分属性表：</p>
<ul>
<li><p>属性为ConstantValue，字段表中，一般是static定义的常量值，比如说我们Main类中定义了一个叫做<strong>MAIN</strong>的常量，对应的字段表中存在的属性表存放的内容如下图。可以理解成常量MAIN对应的字段是 0x 00 19 00 0D 00 0E 后面的 0x 00 01表示有一个属性表，第一个属性值为 0x 00 0F，查对应常量池可知第一个属性表内容ConstantValue，即常量值，具体的内容放在紧接着的 0x 00 00 00 02字节的数据, 具体内容在常量池中的索引为0x 00 08 即 <strong>Hello world,from constant</strong>。ConstantValue只支持基本的数据类型和字符串并且被final static修饰的常量（不同javac可能实现不完全一致），如果只是被static修饰或者非基本数据类型和常量是放在<clinit>方法中被初始化的。</clinit></p>
<div align="center">
  <img src="/images/placeholder.png" alt="field_attr" style="zoom: 67%;" data-src="./从java对象创建说起/field_attr.png" class="lazyload">
</div>

<p>另一个变量mAttribute中的属性表是什么内容呢？00 02 00 10 00 11 后面 0x 00 01同样表示一个属性表，0x 00 12在常量池中的索引内容是Signature，对应的长度是0x00 00 00 02字节，内容在常量池的索引是0x 00 13即Ljava/util/List&lt;Ljava/lang/String;&gt;; Signature可用于方法表，类，字段表中。用来记录范型擦除前的类型</p>
</li>
<li><p>SourceFile，常用语类文件，记录java源文件的名称。一般情况下名与文件名相同，不难想到内部类可能不一致。在混淆后可以通过SourceFile找到类原始文件，，从而定位错误等。但是此属性可选，不一定需要存在。我们hex显示Main.class的值</p>
<blockquote>
<p>ox 00 1F(SourceFile) 00 00 00 02(长度) 00 20(Main.java) </p>
</blockquote>
</li>
<li><p>Deprecated与Synthetic，Deprecated可用于方法表，类文件，字段表中表示此内容已经不推荐使用，Synthetic用于类，方法表或者字段中表示此由编译器生成</p>
</li>
<li><p>Exceptions用于方法表，用于记录方法抛出的异常，不是方法内部的异常，如果我们对Main.java进行改造，在Main方法中抛出异常，得到的class文件中关于Main方法就是这样子的，0x 00 1F在常量池对应的Exceptions（此常量池为修改后便意Main.class重新得到的常量池，非上文），属性长度与0x 00 00 00 06，异常的个数为0x 00 02，对应常量池中的数据 0x 00 20与 0x 00 21即java/lang/ExceptionInInitializerError与java/lang/NumberFormatException</p>
<div align="center">
  <img src="/images/placeholder.png" alt="exception" style="zoom: 67%;" data-src="./从java对象创建说起/exception.png" class="lazyload">
</div>
</li>
<li><p>Code属性表，java方法中的代码在编译完成后会放在code属性表中，如下图，atttibute_name_index即当前属性在常量池中的索引，一般固定是Code</p>
<div align="center">
  <img src="/images/placeholder.png" alt="code" style="zoom: 67%;" data-src="./从java对象创建说起/code_info.png" class="lazyload">
</div> 

<div align="center">
  <img src="/images/placeholder.png" alt="code_attr" style="zoom: 67%;" data-src="./从java对象创建说起/code_attr.png" class="lazyload">
</div> 

<p>我们单独拎出来Code的具体内容具体解释，首先是max stack是我们在虚拟机栈中的栈帧的中的OperandStack的最大深度，此处为0x02。本地变量表为0x00，也是栈帧中的变量表大小，以Slot为单位，在栈帧中我们有详细介绍，包括this(非static方法)，参数，局部变量，异常参数(try catch中的参数)等，但是不是所有局部变量的大小的总和，因为一些作用域的问题，此部分可以复用。然后就是code字节码内容</p>
<blockquote>
<p>0x BB 00 07 59 B7 00 0A 4C 2B B7 00 0B B1</p>
</blockquote>
<p>code内容是一条条字节码组成， 每一个字节码指令都有一个与之对应的1byte数字，即操作码与其对应，详细见 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-7.html" target="_blank" rel="noopener">Opcode Mnemonics by Opcode</a> 每一条指令可能有一个或者多个参数，也可能没有，参考这个表我们可以得到对应的字节码指令，0xBB查表可知为new指令，带有一个参数0x 00 07对应常量池中的<strong>com/jvm/test/Main</strong>，用来创建一个对象，并将其引用值压入栈顶。0x59，即dup，复制栈顶数值并将复制值压入栈顶，也就是说执行到这一句，操作数栈中有两个相同的引用。0xB7，invokespecial调用超类构造方法，实例初始化方法或者私有方法，方法名是0x 00 0A <strong>com/jvm/test/Main.<init></init></strong>，按照这个方式我们能够得到如下表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new #7  // class com/jvm/test/Main</span><br><span class="line">dup</span><br><span class="line">invokespecial #10 // Method "&lt;init&gt;":()V </span><br><span class="line">astore_1</span><br><span class="line">aload_1</span><br><span class="line">invokespecial #11 // Method main:()V</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>大概可以看出来，首先创建了Main对象，复制Main对象入栈，然后栈顶元素的无参构造函数，通过astore_1将栈顶引用型数值存入第二个本地变量(此处第一个变量为args)，然后通过aload_1把第二个引用类型的本地变量推到操作数栈顶，紧接着调用其main无参方法，最后返回。基本上和我们Java代码一致。</p>
</li>
<li><p>Code属性表中有一部分attribute叫LineNumberTable，用来记录字节码偏移与java源代码之间的对应关系。比如说main方法中的LineNumberTable是，0x00 17即常量池中的 LineNumberTable 字符串，后面跟着的4字节为Table属性的长度，即14个字节，后面0x 00 03是table的个数，即3个。第一个为0x00 00 00 15解析后的结论就是，code偏移为0字节的指令new，对应java源码在 0x 00 15即21行，第二个为偏移为8字节的指令aload_1，对应java源码在22行，最后偏移为12的指令在对应源码的23行。函数可以用来出现异常时候具体的行数信息，因此是非必须的</p>
<blockquote>
<p>0x 00 17 00 00 00 0E 00 03 00 00 00 15 00 08 00 16 00 0C 00 17</p>
</blockquote>
</li>
<li><p>另外一个Code属性值是LocalVariableTable，局部变量表，在栈帧中已经说了很多次了。0x0018常量池中的LocalVariableTable，接着是表的长度，22个字节，0x0002个变量，每一个变量的记录格式是 4字节的作用域(前两个字节开始，后两个字节标识长度) + 变量名称 + 描述符 + 在局部变量表Slot中的位置。按照这个方式我们来解析一下main方法的LocalVariableTable，第一个变量的作用于从0字节开始，长度13字节，即从方法开始到结束，也就是第一个参数的作用域是整个方法。变量的名字是0x00 1D即常量池中的args，描述符为0x00 1E即[Ljava/lang/String，也就是main方法的参数，最后是在Slot的位置0x0000。第二个参数作用域从8字节，长度为5字节，即从0x2B的到方法结束，即aload_1开始到方法结束，变量名称0x001B即main，描述符是0x001A，Lcom/jvm/test/Main;在Slot为1的位置</p>
<blockquote>
<p>00 18 00 00 00 16 00 02 00 00 00 0D 00 1D 00 1E 00 00 00 08 00 05 00 1B 00 1A  00 01</p>
</blockquote>
</li>
</ul>
<p>通过以上分析我们基本能知道一个class文件的基本结构是怎么样子的，但是人工一个个解析实在太繁琐啦，所以可以直接借助<strong>javap -verbose</strong>查看class相关信息。那么class是怎么被加载进内存的呢？</p>
<h4 id="Class文件加载"><a href="#Class文件加载" class="headerlink" title="Class文件加载"></a>Class文件加载</h4><p>说道class文件的加载，不得不提经典的三个过程，加载-连接-初始化和双亲委派模型，按照常规来说，加载链接初始化对于同一个class而言应该是串行的，但对于多个class而言则可能不一定，并且不是每一个阶段都是必须的，部分可以通过设置一些运行时参数进行省略。</p>
<div align="center">
  <img src="/images/placeholder.png" alt="load" style="zoom: 67%;" data-src="./从java对象创建说起/load.png" class="lazyload">
</div> 



<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>加载过程粗略的来讲就是把class二进制流加载到内存，具体来说，分为一下步骤</p>
<ol>
<li>通过类的全限定名称找到对应的二进制流，比如说限定名java/lang/Object，但是java对二进制流的来源不做限制，比如说可以在本地的class文件读取，或者是从网络获取，亦或是其他方式</li>
<li>把二进制的静态结构转化为方法区(内存)的运行时的数据结构</li>
<li>在内存中创建一个java.lang.Class对象instanceKlass，作为方法区对这个类的各种访问的入口。此Class对象是放在方法区中的。</li>
</ol>
<p>具体的加载由具体的类加载器完成，我们可以自己自定义类加载器完成我们想要加载的具体class内容。具体就是重载<strong>ClassLoader#loadClass</strong>方法。</p>
<p>对于数组而言，会有所不同，数组类本身并不是通过类加载器加载的，是由java虚拟机直接创建的。数组类的一般创建流程如下</p>
<ol>
<li>如果数组的组件类型(组件类型是指数组去掉一个维度的类型，比如说int[][]的组件类型就是int[])是引用类型，即是普通的对象，则通过上述方法去加载对应的class，否则继续上述步骤，只到加载对应的class为止</li>
<li>如果不是引用类型，比如说int，long，float之类的基本数据类型，虚拟机会把数组则使用Bootstrap ClassLoader加载</li>
<li>对于一个数组的类型的可见性，如果是引用类型则与引用类型一致，不是的话就是public</li>
</ol>
<p>加载完成后，需要在内存上实例化一个java.lang.Class对象，作为管理此外部对象访问方法区中的这些类型的外部接口，对于Hotspot虚拟机而言，是放到方法区的</p>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>连接阶段分为验证，准备，解析三个过程。</p>
<h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>我们不难想到一个问题，通过javac编译出来的class文件理论上不会有什么问题，但是我们不能排除class文件就一定没有问题，比如我们可以通过直接修改字节码文件达到攻击的目的。因此我们需要一个验证过程来保证class是正确无害的。验证过程不是必须但是却是很重要的一步，验证过程分为以下几步</p>
<p><strong>格式验证</strong></p>
<ul>
<li>是否已0xCAFEBABE开头</li>
<li>Major version &amp; minjor version是否受当前虚拟机支持</li>
<li>检查常量池tag，判断是否有不被支持的类型</li>
<li>指向常量池的索引是否有指向不存在的</li>
<li>…</li>
</ul>
<p>验证完成后，字节流便会被放到方法区存储，我们得到的就是一系列的数据结构。验证的最主要过程是保持输入的字符流能被正确的解析，要符合一个class的格式要求</p>
<p><strong>元数据验证</strong></p>
<ul>
<li>验证父类是否正确(只有Object无父类)</li>
<li>类继承关系是否正确(是否集成了final类)</li>
<li>非抽象类是否实现了父类所有抽象方法</li>
<li>…</li>
</ul>
<p>验证阶段的主要目的是对元数据的校检，保证符合java的语法规范</p>
<p><strong>字节码验证</strong></p>
<p>通过对数据流和控制流分析，确定程序语义合法，符合逻辑，主要针对方法</p>
<p><strong>符号引用验证</strong></p>
<p>保证所有的非自身的符号引用都是OK的，一般发生在解析阶段</p>
<ul>
<li>是否能通过常量池中的全限定名称找到具体的类</li>
<li>在指定类中是否能找到符合方法字段描述符的方法与字段</li>
<li>符号应用中的类，方法，字段的可见性</li>
<li>…</li>
</ul>
<h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p>准备阶段是正式为类变量（static修饰的变量）分配内存以及设置初始值的阶段，此内存在方法去分配，类变量与实例变量不同，实例变量是在对象创建的时候初始化，这里的设置初始值，是指把对应的值设置成默认的值，比如是int默认是0，bool默认false，比如说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> VARIABLE = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//在准备阶段不会设置成123，而是设置成0，设置成123实在&lt;clinit&gt;方法中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VARIABLE = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//一般会有ConstanValue，则会根据ConstanValue设定初置</span></span><br></pre></td></tr></table></figure>

<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>解析阶段是把符号引用换成对应的直接引用的过程。</p>
<blockquote>
<p>符号引用与直接引用区别，符号引用是一组用符号来描述引用的目标，直接引用则是指向引用目标的指针，或者内存相对偏移量等，直接引用说明目标是直接可用的，即已经被加载到内存中，符号引用则不然</p>
</blockquote>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>准备阶段已经对类变量进行了设置系统默认零值，初始化阶段则是把我们想要的默认值设置给对应的类变量或者初始化其他资源。简而言之，即调用类构造器的&lt;clinit&gt;方法。</p>
<ul>
<li>&lt;clinit&gt;方法是由编译器通过收集类变量的赋值和静态语句块的合并产生的，其中，静态语句块即由static{} 包裹的内容，静态语句块只能访问到定义在其之前的变量，之后的定义的变量只能赋值，不能访问</li>
<li>&lt;clinit&gt;方法不需要主动调用父类的&lt;clinit&gt;父类的方法，虚拟机会保证父类的&lt;clinit&gt;在其之前调用，所以Object的&lt;clinit&gt;是第一个被调用的&lt;clinit&gt;方法</li>
<li>&lt;clinit&gt;对于类或者接口来说不是必须的，如果一个类没有静态代码块和对类变量的赋值操作，此方法可以省略</li>
<li>对于接口而言，没有静态代码块，但是有静态变量，默认在调用接口的&lt;clinit&gt;方法前不会调用欺父类的。同样，接口的实现类在调用&lt;clinit&gt;也不会调用接口的&lt;clinit&gt;方法</li>
<li>虚拟机会保证&lt;clinit&gt;方法在多线程环境下是正常被调用，如果一个线程正在执行&lt;clinit&gt;，其他线程想要初始化这个类都会被阻塞</li>
<li>对于同一个类加载来说，&lt;clinit&gt;只会被调用一次</li>
</ul>
<h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><p>类加载器主要功能就是加载类，但不仅仅只是加载类，每一个类加载器都有其独一的命名空间，对于同一个类，如果使用的命名空间不一致，即使用的类加载器不一致，即对于同一个类而言，不同的类加载器加载，得到的对象是不想等的，不仅仅是对象的equal方法，包括 instanceof，isAssignableFrom等都是不同的。类加载器在收到加载类的请求时，不会立马去加载，而是请求其父加载器去加载，这就是类加载器的双亲委派机制。</p>
<h6 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h6><p>Java中的类加载器主要分为两种，一种是以C++写成的叫做bootstrap classloader，另外一种是以java作为编程语言，分为extension classloader，Applications classloader，以及自定义的classloader</p>
<ul>
<li>bootstrap classloader，启动类加载器，主要负责加载java自带的一些jar包，比如说dt.jar等</li>
<li>extension classloader，拓展类加载器，一般是加载jdk中ext目录下的jar包</li>
<li>application classloader，应用程序加载器，如果应用程序中最没有定义过自己的类加载器，我们自己的class一般是通过此进行加载</li>
</ul>
<p>这些类加载器模型的基本关系如下，当我们使用自定义的类加载器加载类时，它不会直接去加载，而是请求其父加载器aplication classloader加载，application classloader收到请求后也会直接加载，会交给其父加载器extension classloader，如此直到bootstrap classloder，如果bootstrap classloader无法加载请求的类，则交给子类加载器 extension classloader，如果其无法加载，继续子类加载器，一致如此，直到无法加载就抛出ClassNotFoundException异常</p>
<div align="center">
  <img src="/images/placeholder.png" alt="classloader" style="zoom: 67%;" data-src="./从java对象创建说起/classloader.jpeg" class="lazyload">
</div> 



<p>双亲委派机制自然也有它的问题，我们自己类加载器可以直接加载对应的类，或者如果在系统类中加载了自定义的类就无法实现了，经典的例子就是Java中的SPI</p>
<h4 id="堆上创建"><a href="#堆上创建" class="headerlink" title="堆上创建"></a>堆上创建</h4><p>类加载完成就可以创建具体对象啦，一个对象所占用的内存大小类加载完成后就已经确定，分配内存就等同于在堆上划分一块相同的大小的内存区域。划分的方法有两种方式，指针碰撞和空闲列表</p>
<ul>
<li>指针碰撞方式是指内存是规整的，一边是占用，一边是空闲，这样直接在空闲区域开辟对应大小的内存即可</li>
<li>空闲列表方式是内存不是规整的，虚拟机需要维护一张未被使用的列表，每一次分配的时候需要找到一块足够大的内存区域进行分配，并且需要空闲列表</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），关于垃圾回收的内容见后续文章。</p>
<p>另外一点需要注意的是，对象创建是一个很频繁的行为，因此不得不考虑的一个问题是线程安全，比如说当我正在分配内存的时候，对象指针可能还未指向对象就已经被重新分配了。解决方案也很简单，对一种采用同步处理，另一种是通过本地线程分配缓冲TLAB，不同的线程创建对象使用不同的内存空间，自然当TLAB已经使用完，无法再分配的时候，则使用同步方式处理</p>
<p>对象创建完成后，需要把非对象头外的分配到的内存空间设置零值，即基本数据结构值0，false等，对象设置成null</p>
<p>然后就是设置初始化对象头与调用对象的&lt;init&gt;方法</p>
<h5 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h5><p>在HotSpot虚拟机中，对象在内存中分为三块区域，对象头，实例数据，对齐填充</p>
<h6 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h6><p>对象头存储着对象自身运行时数据和类型指针</p>
<ul>
<li><p>运行时数据，包括HashCode，GC分代年龄，锁状态，线程锁等，这部分的数据在32位系统上是32bit，在64位在未开启指针压缩是64bit，这部分数据，官方称之为<strong>MarkWord</strong>， 根据锁状态，具体组成如下，关于锁在说明线程安全的时候会有涉及</p>
<div align="center">
  <img src="/images/placeholder.png" alt="markword" style="zoom: 67%;" data-src="./从java对象创建说起/markword.jpeg" class="lazyload">
</div> 
</li>
<li><p>类型指针，虚拟机通过这个指针判断当前对象是哪个类instanceKlass的实现</p>
</li>
</ul>
<p>两外，如果是数组的话，对象头中还必须有一块记录数组的大小</p>
<h6 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h6><p>实例数据是对象真正存储的有效信息，即类中定义的各种字段的内容，无论是从父类继承，还是自带的，另外变量的储存的顺序是按照longs/doubles,ints, shorts/chars, bytes/booleans,oops排列的，在此基础上，父类的变量在前。</p>
<h6 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h6><p>对齐填充不是必须存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p> 下面来分析一下，执行new A()的时候，JVM 做了什么工作。首先，如果这个类没有被加载过，JVM就会进行类的加载，并在JVM内部创建一个instanceKlass对象表示这个类的运行时元数据（相当于Java层的Class对象）。初始化对象的时候（执行invokespecial A），JVM就会创建一个instanceOopDesc对象表示这个对象的实例，然后进行Mark Word的填充，将元数据指针指向Klass对象，并填充实例变量。元数据(instanceKlass) 对象会存在元空间（方法区），而对象实例—— instanceOopDesc 会存在Java堆。Java虚拟机栈中会存有这个对象实例的引用。</p>
<div align="center">
  <img src="/images/placeholder.png" alt="object" style="zoom: 67%;" data-src="./从java对象创建说起/object.png" class="lazyload">
</div> 



<h5 id="调用-lt-init-gt-方法"><a href="#调用-lt-init-gt-方法" class="headerlink" title="调用&lt;init&gt;方法"></a>调用&lt;init&gt;方法</h5><p>Java对象在被创建时，会进行实例化操作。该部分操作封装在&lt;init&gt;方法中，并且子类的&lt;init&gt;方法中会首先对父类&lt;init&gt;方法的调用。Java对象实例化过程中对变量的的初始化赋值操作全部在&lt;init&gt;方法中进行，&lt;init&gt;方法显式的调用父类的&lt;init&gt;方法，实例域的声明以及实例初始化语句块同样的位置关系会影响编译器生成的&lt;init&gt;方法的字节码顺序，&lt;init&gt;方法以构造方法作为结束。</p>
<h4 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h4><p>如下分析，对象的reference是放在虚拟机栈中的，那么如何通过这个指针访问对应的对象呢？目前主流的方式有两种：</p>
<ul>
<li><p>句柄访问，使用句柄访问的话，需要在内存中维护一个句柄池，存放具体的对象</p>
<div align="center">
  <img src="/images/placeholder.png" alt="handle" style="zoom: 67%;" data-src="./从java对象创建说起/handle.png" class="lazyload">
</div>  
</li>
<li><p>直接指针访问，如果使用直接指针访问，那么Java堆中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象的地址。</p>
<div align="center">
  <img src="/images/placeholder.png" alt="pointer" style="zoom: 67%;" data-src="./从java对象创建说起/pointer.png" class="lazyload">
</div>  

</li>
</ul>
<p>两种方式各有优势，对于句柄访问的话如果我需要移动对象地址，只需要改句柄内容，不需要更改栈帧中的reference，使用直接指针的方式就是快，hotspot是采用此方式。</p>
<h3 id="常量池相关补充"><a href="#常量池相关补充" class="headerlink" title="常量池相关补充"></a>常量池相关补充</h3><p>额外的补充一些与常量池相关的知识点。</p>
<ol>
<li>String相关内容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern方String.intern() 是一个native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 =<span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s3 == s2);</span><br><span class="line"><span class="comment">//true，因为两个都是常量池中的String对</span></span><br></pre></td></tr></table></figure>

<p>String拼接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 =<span class="string">"str"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 =<span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str3 =<span class="string">"str"</span>+<span class="string">"ing"</span>; <span class="comment">//直接字符串拼接，常量池中的对象</span></span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2; <span class="comment">//对象拼接会在堆上创建的新的对象 </span></span><br><span class="line"><span class="built_in">String</span> str5 =<span class="string">"string"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5); <span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>基本数据类型常量池</li>
</ol>
<ul>
<li>Java 基本类型的包装类的大部分都实现了常量池技术，即Byte, Short, Integer, Long, Character, Boolean这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象，对应包装类的valueOf方法在[-128，127]间同样是从常量池中取得。</li>
<li>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// 输出true</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">33</span>);</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = Interger.valueOf(<span class="number">33</span>);</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// 输出true</span></span><br><span class="line"></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22); <span class="comment">// 输出false</span></span><br><span class="line"></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>  	
					
	  </div>     
	  

	<div class="bottom">
  <div class="other">
    <div class="meta">
      
      <i class="iconfont icon-category"></i>
      <a class="category-link" href="/categories/JVM/">JVM</a>

      

      
      <i class="iconfont icon-tag"></i>
      <a class="tag-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a> <a class="tag-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" rel="tag">对象创建</a>
      
    </div>

    <div class="operate">
      
      <span class="text">Share</span>
      <ul class="share">
	   			             
        <li class="iconfont 
		icon-share-qq 
		-mob-share-qq 
		item"></li>		
   	   			             
        <li class="iconfont 
		icon-share-weixin 
		-mob-share-weixin 
		item"></li>		
   	   			             
        <li class="iconfont 
		icon-share-weibo 
		-mob-share-weibo 
		item"></li>		
   	   
</ul>	

<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21d601593a1de"></script>
      
    </div>
  </div>


  
  <nav class="nav">
    <div class="link">
      
      <a href="/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="link-wrap">
        <strong class="caption">older</strong>
        
        <span class="title">
          Glide 源码分析
        </span>
      </a>
      
    </div>
    <div class="link">
      
    </div>
  </nav>
  
</div> 
	
<div class="comment">

    

    <div id="comment">
    </div>

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>

    <script src="//unpkg.com/valine@v1.1.8-beta/dist/Valine.min.js"></script>

    <script>
        new Valine({
            el: '#comment',
            notify: false,
            verify: false,
            app_id: 'cFM0eCo0CQ9xmBXmHi1eltol-gzGzoHsz',
            app_key: 'oh9tizsnvV2vNvWgqEvoNtQO',
            path: window.location.pathname,
            avatar: 'mm',
            guest_info: ['nick', 'mail']
        });
    </script>
    
</div>	
</article>

          </div> 
      </div>            
    
        <i id="toTop" class="iconfont icon-backtotop"></i>

  
    <div class="none" id="search">
    <div class="header">
        <input type="text" placeholder="输入你想搜索的" id="search-input" class="input">
        
        <i id="search-cancel" class="iconfont icon-cancel"></i>
    </div>

    <div id="search-result" class="result"></div>
</div>
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon lazyload" src="/images/placeholder.png" data-src="/images/favicon.png">  
      

         
            

            <a class="mobile-menu-link" href="/">首頁
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">歸檔
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">標籤
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">關於
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>
        
    



     
    


<footer class="footer">
	<div class="inner">
		<div class="copyright">
			&copy;
			
			2019
			Lemon

			<br>
			By <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>
	</div>
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>