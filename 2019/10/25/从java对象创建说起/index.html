<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  从Java对象创建说起 |   Lemon </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header-wrapper">

  <nav class="inner">
    <div class="title">
    </div>

    <ul class="menu">
      
      
      <li class="item">
        <a class="link" id="menu-home" href="/">
          <i class="iconfont icon-home">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-archives" href="/archives">
          <i class="iconfont icon-archives">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-tags" href="/tags">
          <i class="iconfont icon-tags">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-about" href="/about">
          <i class="iconfont icon-about">
        </i></a>
      </li>
      
      
      
      <li class="item">
        <a class="link" id="menu-search">
          <i class="iconfont icon-search">
        </i></a>
        

        
      
    </li></ul>
  </nav>
</header>

<header class="mobile-header-wrapper">
  <i id="mobile-toggle" class="iconfont icon-menu mobile-toggle"></i>
</header>   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          <article class="post slideDownMin">
  
	
<div class="header">
		<p class="title">	
			从java对象创建说起
		</p>
		<div class="info">	
			<time>
				Oct 25, 2019
			</time>

			
			
				<i class="iconfont icon-words"></i>
				<span class="words">8008
				</span>
			
		</div>
</div> 
	

    <script type="text/x-mathjax-config">
        var post = document.getElementsByClassName("post")[0];  
        MathJax.Hub.Config({
            showProcessingMessages: false,
            messageStyle: "none",    
            tex2jax: {
                inlineMath:  [ ["$", "$"] , ["\\(","\\)"]],
                displayMath: [ ["$$","$$"] , ["\\[","\\]"]],
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],
            },
            "HTML-CSS": {            
                showMathMenu: false
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub,post]);
    </script>
    <style>.MathJax{outline:0;}</style>

    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.2/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
 

	  <div class="typo post-content ">

		

			
					<p>试想一下，如果我们在代码中直接通过关键字new创建了一个对象，JVM会做那些工作从而保证我们后续的使用不出问题呢？java中内存究竟是怎么分配的呢？为什么java new的对象不需要手动释放？带着这些疑问我们一起来研究一下java中对象创建的相关知识。</p>
 <a id="more"></a>

<p>试想一下，如果我们在代码中直接通过关键字new创建了一个对象，JVM会做那些工作从而保证我们后续的使用不出问题呢？java中内存究竟是怎么分配的呢？为什么java new的对象不需要手动释放？带着这些疑问我们一起来研究一下java中对象创建的相关知识。</p>
<h2 id="Java运行时内存区域划分"><a href="#Java运行时内存区域划分" class="headerlink" title="Java运行时内存区域划分"></a>Java运行时内存区域划分</h2><p>如果经常看一些博客或者有过一些面试的经验，可能经常会看到或者听到这样的结论：”Java中通过new关键字创建对象后，对象是放在内存的堆区，对象的引用是放到栈区“。 那么什么是堆？什么是栈呢？</p>
<p>按照字面意思上来说，栈是常见的数据结构，遵循先进后出的规则，堆则相反。但是java中是怎么堆与栈区的到底分别是指哪一块区域，到底存放的是什么呢？通过阅读《深入理解Java虚拟机》与《Java虚拟机规范(Java SE 8版)》相关书籍，可以得到如下java运行时内存区域分配图</p>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/memory.png" alt="memory" style="zoom:50%;align:right"></div>

<p>最明显的内存分为线程共享与线程私有区域，所谓线程共享，是指所有线程都能访问到对应内存区域内容，线程私有则相反，内存只能被当前线程拥有者使用。我们一个个来详细说说这些区域。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器，用来指示当前线程运所执行的字节码指令的地址，不难猜到，此块区域并不需要特别大就已经能够满足需求。由于多线程的<strong>隔离</strong>，必须为每一条线程设置一块程序计数器标示线程运行的位置，等待CPU线程切换继续执行。</p>
<p>此处可能我们就会想到一个问题，如果当前线程执行的java方法，它应该存放下一次要执行字节码指令的地址，如果当前线程正在通过Jni执行native方法，那么，程序计数器存放的内容是什么呢？Java虚拟机规范规定，此时此内存的内容是undefined。正是因为这些特殊的性质，<strong>此区域JVM没有规定会出现任何形式的OOM</strong></p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>在线程创建的时候，Java虚拟机会为其创建一个单独的栈空间，规范中规定此区域不需要是连续的，栈常用的两个操作，压栈与弹栈，当线程执行到某个方法调用的时候，会把此方法相关内容，或者叫栈条目，如参数，局部变量，以及异常等入栈，栈条目通过被称为<strong>栈帧</strong>，方法执行结束，把对应栈条目弹出栈。在一个线程中的所有方法调用结束的时候，JVM会清空相应的栈内存，并在终止线程之前回收栈空间。</p>
<div align="center">
<img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/JVM.jpg" alt="JVM" style="zoom: 67%;">
</div>

<p>栈帧结构</p>
<ul>
<li>LVA，local variable array 本地变量表，变量表的大小由编译期决定，编译期间我们其实已经知道了变量的个数（参数和局部变量），局部变量的类型等，所以此区域不受运行时的修改，一旦编译完成不会再改变，是写在class文件中的。LVA的最小单位叫做变量槽Slot，一般一个Slot至少能存下一个boolean，byte，char，int，short，float，reference或者returnAddress（用来实现异常的处理，目前基本被异常表替代）的数据，对于long与double，JVM规定使用两个Slot存放。一般来说针对非static函数，一般第一个Slot存放的是此对象的引用，剩下的按照参数列表进行排序，参数存放完毕后，在根本方法体内部的变量循序和作用于分配其他Slot</li>
<li>OS，operand stack，操作栈，一种LIFO的数据结构，编译期间已经确定最大深度，用来记录运行过程中的内容或者存储计算结果。默认方法刚开始执行时，此空间为空，方法执行过程中会有各种字节码向操作栈中读写内容。</li>
<li>FD，frame data，包括比如方法返回地址，调试信息等。值得注意的是，其中包括一个叫做动态链接的数据，即一个引用指向运行时常量池中的该栈帧所在的方法。</li>
</ul>
<p><strong>JVM虚拟机规范中制定，此区域如果请求栈深度超出虚拟机最大允许的深度，则抛出StackOverflow异常，当然因为需要存储数据，如果申请不到内存，也是会发生OOM</strong></p>
<p>这个虚拟机栈是指上文存放对象引用的栈区么？从上面分析可知，粗略上来说，是的，因为栈帧中LVA存放的就是reference等数据。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>如虚拟机栈相同，虚拟机栈记录的是java的栈帧，本地方法则是对应的native方法的调用，当然JVM对此实现比较自由，不同的虚拟机实现具体不太一致，甚至有的虚拟机是把本地方法与虚拟机栈合并处理的，与虚拟机栈一样，同样存在OOM与StackOverflow异常</p>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/natives.png" alt="native" style="zoom: 67%;">
</div>



<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>刚才有提到，栈帧中FD中存在一项动态链接的数据，指向运行时常量区的方法。这个运行时常量区及方法区的一部分。方法区是线程共享的一部分内存区域。用来存放JVM加载的类（包括方法，属性等），常量，静态变量等数据。方法区在虚拟机启动的时候创建。此区域是堆区的逻辑组成部分，但又与堆区不同，不严谨的说，在某些虚拟机实现中，此区域可能会被叫做<strong>永久代</strong>，这样垃圾回收器就可以把此区域当作堆区进行垃圾回收，自然，因此区域的特殊性，回收带来的回报是很低的。</p>
<p>另外，JVM规定，<strong>如果方法区无法满足申请分配的内存时，抛出OOM异常</strong></p>
<p>回到本节最开始的内容，运行时常量池时什么？方法区的一部分。常量池时class信息中的一部分，用于存放编译期生成的各种常量与符号引用。常量池最终会被加载到运行时常量池中。</p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对于大部分应用来说，堆区应该是最大的一块内存区域，是被所有线程共享的区域。基本所有对象的实例都是在此处被分配，JVM规范是这么定义，所有对象的实例和数组都要在堆上分配（非绝对，见深入理解Java虚拟机）。</p>
<p>堆是内存回收的主要区域，对于使用分代算法的虚拟机来说，此区域包括新生代和老年代。另外与方法区一样，<strong>也会抛出OOM异常</strong></p>
<p>关于垃圾回收相关内容，可以参考后续的文章</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是JVM运行时内存的一部分，诞生于Java 1.4中加入的NIO，一种基于Channel于Buffer的IO方式，利用Native直接在堆外分配内存。然后通过一个存储在Java堆的DirectByteBuffer对象作为此内存的引用进行操作。在某一些场景中可以显著提高性能，也有可能会发生OOM</p>
<p>好了说了这么多与Java内存分配的东西。那么到底对象是怎么创建的呢？</p>
<h2 id="Java对象创建"><a href="#Java对象创建" class="headerlink" title="Java对象创建"></a>Java对象创建</h2><p>Java是一门面向对象的语言，无时无刻不伴随着对象的创建，与C++不同的是，java所有的方法都必须由class作为载体，无对象无方法。对象创流程如下</p>
<ul>
<li>通过字节码new的参数从常量池中查找是否有对应的class符号引用</li>
<li>检测class文件是否被加载，解析，初始化<ul>
<li>未加载，执行类加载过程</li>
</ul>
</li>
<li>未新对象分配内存并置0</li>
<li>调用构造方法</li>
</ul>
<h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>想要知道如何new是如何从常量池中查找class的引用，需要知道class文件中究竟放的是什么内容。因此我们首先分析下class文件的结构。class文件一种以8位字节为基础的二进制流，和常见的二进制文件一样，也是由一定规则组成的，我们以下面一则简单的java程序来说明，class的基本结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jvm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIN = <span class="string">"Hello World! form constant"</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mAttribute;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAttribute = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(mAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(MAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.main();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完成后，我们得到一个class文件，我们通过hex friend工具分析class文件的基本组成部分。我们先分析前120个字节的内容，hex结果如下</p>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/hex.png" alt="hex120" style="zoom: 67%;">
</div>

<ul>
<li>可以看出来，class文件以0xCAFEBABE开始，这个0xCAFEBABE是class文件的魔数，用来标识此文件是class文件，关于此魔数的由来可以参考java之父的解释 <a href="https://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">Java class file </a>。当然不难想到，Java的logo就是一杯咖啡。</li>
<li>紧接着0x00000034  ，前2个字节0x0000代表minjor次版本号，0x0034主版本号，及十进制的52.0。</li>
<li>紧接着的是常量池的相关内容，常量池个数+常量表，常量池的内容通常是实际上常量表个数+1，其中多出来的一个是指不指向常量池的项目·，0x0034翻译成十进制即52，即后面共有51个常量。每一项都拥有一个常量类型标志tag，长度为1个字节，比如说第一个常量类型是 0x0A，0x0A表示什么类型呢？</li>
</ul>
<div align="center">
  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/constant.png" alt="constant" style="zoom: 67%;">
</div>

<p>表中u1表示一个字节，u2两个字节。查表可知，0x0A（10进制的10）表示<strong>Constant_methodref_info</strong>，此类型的格式是tag+index(方法的类描述符)+index(方法名称与类型描述符)，我们可以得到<strong>Constant_methodref_info</strong>的对应的类描述符是0x000C，即索引是第12个项目，方法名称和类型指向0x0021，换成10进制33，即对应索引为33的<strong>Constan_NameAndType</strong>，按照此中方式我们不难整理出来，所有的常量的内容。但是一个个人工对太复杂了，java给我们提供了现有的工具<strong>javap</strong>，可以用来解析</p>
<div align="center">
  <img src="/images/placeholder.png" alt="javap" style="zoom: 67%;" data-src="./从java对象创建说起/javap.png" class="lazyload">
</div>

<p>如何便可以知道，0x0A方法是Object的构造函数。当然还有我们定义的一些常量字符串，不难看出，常量池存放的内容是 字面量与符号引用，字面量可以理解为我们java语言中经常接触到的常量，比如说文本字符串，final常量等。符号引用则是编译相关的内容。符号引用包括以下方面的内容 1. 类和接口的全限定名，全限定名是什么意思呢？大概可以理解成我可以通过此限定找到对应满足要求的接口或者类，比如说上图中的#12，我可以通过限定名<strong>java/lang/Object</strong>找到对应的Object类 2. 方法的名称与描述符，举例说明即图中 #11 中关于main方法的描述符<strong>com/jvm/test/Main.main:()V</strong>表示方法为com.jvm.test.Main类中存在一个名为main的方法，参数为空，返回值为V即void，关于描述符的定义，后面会有详细的说明 3. 字段的名称与描述符，后面会有详细说明，如图是hex中常量池的所有内容</p>
<div align="center">
  <img src="/images/placeholder.png" alt="constants" style="zoom: 67%;" data-src="./从java对象创建说起/constants.png" class="lazyload">
</div>

<ul>
<li>继续，常量池后面的是访问标志，用两个字节表示，访问标志如下, 也是我们常见的能用在定义类，接口，枚举等常见的一些字段。参见下表可知，我们的Main.class是public，对应的标志是ACC_PUBLIC, 因为ACC_SUPER始终为true，所以我们得到的访问标志值是<br>$$<br>0x0020 | 0x0001 = 0x0021<br>$$<br>由常量池中的hex图片可知，访问标志值就是0x0021。</li>
</ul>
<div align="center">
  <img src="/images/placeholder.png" alt="constants" style="zoom: 67%;" data-src="./从java对象创建说起/access_flag.png" class="lazyload">
</div>

<ul>
<li>访问标志后面接的是 类索引和接口索引，因为接口是可以多实现的，因此这个接口索引是一个数组，通过这些索引，class可以确定其继承关系。如图是Main类的继承关系，0x0007指向常量池中的第7哥索引值，通过上图中javap的输出可知，当前类是<strong>com/jvm/test/Main</strong>, 当前类的父类是 0x000C对应的索引是<strong>java/lang/Object</strong>，0x0000表示当前类有0个接口。</li>
</ul>
<div align="center">
  <img src="/images/placeholder.png" alt="class" style="zoom: 67%;" data-src="./从java对象创建说起/class.png" class="lazyload">
</div>

<ul>
<li><p>确定完继承关系后，可以继续分析接下来的内容，字段表，简单来说就是一些类变量或者实例变量在class文件中的布局，java中通常用可以用来标识一个变量有，<strong>访问控制修饰符（public/private/protected，static，final，volatile，transient）+ 数据类型（基本类型/数组/对象）+ 字段名称</strong> 因为我们可能存在多个字段所以此部分的内容一般是 </p>
<blockquote>
<p>n字段个数2bytes + n * (访问标志2bytes + 名字常量池索引2bytes + 描述符常量池索引 + 属性表相关内容) 属性相关内容留着后续说明</p>
</blockquote>
<p>其中，访问标志值通位操作或计算得到而成，具体对应的标志值如图</p>
<div align="center">
<img src="/images/placeholder.png" alt="field" style="zoom: 67%;" data-src="./从java对象创建说起/field.png" class="lazyload">
</div>
另外，关于描述符此处需要好好说以下，描述符的作用是用来描述字段的类型或者函数的参数列表以及返回值，常见的描述符如下，
<div align="center">
<img src="/images/placeholder.png" alt="descriptor" style="zoom: 67%;" data-src="./从java对象创建说起/descriptor.png" class="lazyload">
</div>

<p>通过此分析，我们可以自己计算这一块的class内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIN = <span class="string">"Hello World! form constant"</span>;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; mAttribute;</span><br></pre></td></tr></table></figure>
<p>因为类Main中有两个变量(换成16进制即0x0002)，第一个修饰符是<br>$$<br>0x0001 | 0x0008 | 0x0010 = 0x0019<br>$$<br>变量名称为<strong>MAIN</strong>，通过查看javap打印得知，其常量池索引为0x000D(#13), 描述符为<strong>Ljava/lang/String;</strong> 其常量池索引为0x000E, 如果属性值我们暂不讨论的化，那么其字段对应的16进制为， 其中…代表属性相关内容，暂时不表</p>
<blockquote>
<p>0x 00 02 00 19 00 0D 00 0E … 00 02 00 10 00 11 …</p>
</blockquote>
<p>可以与hex对比可知，正如我们计算的这样</p>
</li>
<li><p>除了属性我们没有说明外，基本字段已经说完，后面就可以继续说方法表。方法与字段基本一致，也是访问标识 + 名称索引 + 参数索引 + 属性表，不同的是方法的修饰符与变量不同，方法无法使用volatile或者transient修饰，倒是多了native, synchronized, abstract, strictfp等修饰</p>
<div align="center">
<img src="/images/placeholder.png" alt="method" style="zoom: 67%;" data-src="./从java对象创建说起/method.png" class="lazyload">
</div>


</li>
</ul>
<p>比如说Main类中的方法个数为一个构造函数，两个main方法，故共有3个方法</p>
<div align="center">
  <img src="/images/placeholder.png" alt="methods" style="zoom: 67%;" data-src="./从java对象创建说起/methods.png" class="lazyload">
</div>
目前方法的定义已经说清楚，那么方法内部的实现呢？即code是放在哪里的呢？当然一致都在属性表中，接着我们就来说说这期盼已久的属性表

<ul>
<li><p>属性表在class文件中算是最复杂的一部分，首先其分类比较多，根据作用不同，放置的位置也不一样，一般可以分为以下几种：</p>
<ul>
<li><p>属性为ConstantValue，字段表中，一般是static定义的常量值，比如说我们Main类中定义了一个叫做<strong>MAIN</strong>的常量，对应的字段表中存在的属性表存放的内容如下图。可以理解成常量MAIN对应的字段是 0x 00 19 00 0D 00 0E 后面的 0x 00 01表示有一个属性表，第一个属性值为 0x 00 0F，查对应常量池可知第一个属性表内容ConstantValue，即常量值，具体的内容放在紧接着的 0x 00 00 00 02字节的数据, 具体内容在常量池中的索引为0x 00 08 即 <strong>Hello world,from constant</strong>。ConstantValue只支持基本的数据类型和字符串并且被final static修饰的常量（不同javac可能实现不完全一致），如果只是被static修饰或者非基本数据类型和常量是放在<clinit>方法中被初始化的。</clinit></p>
<div align="center">
  <img src="/images/placeholder.png" alt="field_attr" style="zoom: 67%;" data-src="./从java对象创建说起/field_attr.png" class="lazyload">
</div>

<p>另一个变量mAttribute中的属性表是什么内容呢？00 02 00 10 00 11 后面 0x 00 01同样表示一个属性表，0x 00 12在常量池中的索引内容是Signature，对应的长度是0x00 00 00 02字节，内容在常量池的索引是0x 00 13即Ljava/util/List&lt;Ljava/lang/String;&gt;; Signature可用于方法表，类，字段表中。用来记录范型擦除前的类型</p>
</li>
<li><p>SourceFile，常用语类文件，记录java源文件的名称。一般情况下名与文件名相同，不难想到内部类可能不一致。在混淆后可以通过SourceFile找到类原始文件，，从而定位错误等。但是此属性可选，不一定需要存在。我们hex显示Main.class的值</p>
<blockquote>
<p>ox 00 1F(SourceFile) 00 00 00 02(长度) 00 20(Main.java) </p>
</blockquote>
</li>
<li><p>Deprecated与Synthetic，Deprecated可用于方法表，类文件，字段表中表示此内容已经不推荐使用，Synthetic用于类，方法表或者字段中表示此由编译器生成</p>
</li>
<li><p>Exceptions用于方法表，用于记录方法抛出的异常，不是方法内部的异常，如果我们对Main.java进行改造，在Main方法中抛出异常，得到的class文件中关于Main方法就是这样子的，0x 00 1F在常量池对应的Exceptions（此常量池为修改后便意Main.class重新得到的常量池，非上文），属性长度与0x 00 00 00 06，异常的个数为0x 00 02，对应常量池中的数据 0x 00 20与 0x 00 21即java/lang/ExceptionInInitializerError与java/lang/NumberFormatException</p>
<div align="center">
  <img src="/images/placeholder.png" alt="exception" style="zoom: 67%;" data-src="./从java对象创建说起/exception.png" class="lazyload">
</div>
</li>
<li><p>Code属性表，java方法中的代码在编译完成后会放在code属性表中，如下图，atttibute_name_index即当前属性在常量池中的索引，一般固定是Code</p>
<div align="center">
  <img src="/images/placeholder.png" alt="code" style="zoom: 67%;" data-src="./从java对象创建说起/code_info.png" class="lazyload">
</div> 

<div align="center">
  <img src="/images/placeholder.png" alt="code_attr" style="zoom: 67%;" data-src="./从java对象创建说起/code_attr.png" class="lazyload">
</div> 

<p>我们单独拎出来Code的具体内容具体解释，首先是max stack是我们在虚拟机栈中的栈帧的中的OperandStack的最大深度，此处为0x02。本地变量表为0x00，也是栈帧中的变量表大小，以Slot为单位，在栈帧中我们有详细介绍，包括this(非static方法)，参数，局部变量，异常参数(try catch中的参数)等，但是不是所有局部变量的大小的总和，因为一些作用域的问题，此部分可以复用。然后就是code字节码内容</p>
<blockquote>
<p>0x BB 00 07 59 B7 00 0A 4C 2B B7 00 0B B1</p>
</blockquote>
<p>code内容是一条条字节码组成， 每一个字节码指令都有一个与之对应的1byte数字，即操作码与其对应，详细见 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-7.html" target="_blank" rel="noopener">Opcode Mnemonics by Opcode</a> 每一条指令可能有一个或者多个参数，也可能没有，参考这个表我们可以得到对应的字节码指令，0xBB查表可知为new指令，带有一个参数0x 00 07对应常量池中的<strong>com/jvm/test/Main</strong>，用来创建一个对象，并将其引用值压入栈顶。0x59，即dup，复制栈顶数值并将复制值压入栈顶，也就是说执行到这一句，操作数栈中有两个相同的引用。0xB7，invokespecial调用超类构造方法，实例初始化方法或者私有方法，方法名是0x 00 0A <strong>com/jvm/test/Main.<init></init></strong>，按照这个方式我们能够得到如下表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new #7     				// class com/jvm/test/Main</span><br><span class="line">dup</span><br><span class="line">invokespecial #10 // Method "&lt;init&gt;":()V </span><br><span class="line">astore_1</span><br><span class="line">aload_1</span><br><span class="line">invokespecial #11 // Method main:()V</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>大概可以看出来，首先创建了Main对象，复制Main对象入栈，然后栈顶元素的无参构造函数，通过astore_1将栈顶引用型数值存入第二个本地变量(此处第一个变量为args)，然后通过aload_1把第二个引用类型的本地变量推到操作数栈顶，紧接着调用其main无参方法，最后返回。基本上和我们Java代码一致。</p>
</li>
</ul>
</li>
</ul>
  	
					
	  </div>     
	  

	<div class="bottom">
  <div class="other">
    <div class="meta">
      
      <i class="iconfont icon-category"></i>
      <a class="category-link" href="/categories/JVM/">JVM</a>

      

      
      <i class="iconfont icon-tag"></i>
      <a class="tag-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a> <a class="tag-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" rel="tag">对象创建</a>
      
    </div>

    <div class="operate">
      
      <span class="text">Share</span>
      <ul class="share">
	   			             
        <li class="iconfont 
		icon-share-qq 
		-mob-share-qq 
		item"></li>		
   	   			             
        <li class="iconfont 
		icon-share-weixin 
		-mob-share-weixin 
		item"></li>		
   	   			             
        <li class="iconfont 
		icon-share-weibo 
		-mob-share-weibo 
		item"></li>		
   	   
</ul>	

<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21d601593a1de"></script>
      
    </div>
  </div>


  
  <nav class="nav">
    <div class="link">
      
      <a href="/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="link-wrap">
        <strong class="caption">older</strong>
        
        <span class="title">
          Glide 源码分析
        </span>
      </a>
      
    </div>
    <div class="link">
      
    </div>
  </nav>
  
</div> 
	
<div class="comment">

    

    <div id="comment">
    </div>

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>

    <script src="//unpkg.com/valine@v1.1.8-beta/dist/Valine.min.js"></script>

    <script>
        new Valine({
            el: '#comment',
            notify: false,
            verify: false,
            app_id: 'cFM0eCo0CQ9xmBXmHi1eltol-gzGzoHsz',
            app_key: 'oh9tizsnvV2vNvWgqEvoNtQO',
            path: window.location.pathname,
            avatar: 'mm',
            guest_info: ['nick', 'mail']
        });
    </script>
    
</div>	
</article>

          </div> 
      </div>            
    
        <i id="toTop" class="iconfont icon-backtotop"></i>

  
    <div class="none" id="search">
    <div class="header">
        <input type="text" placeholder="Typing Something here." id="search-input" class="input">
        
        <i id="search-cancel" class="iconfont icon-cancel"></i>
    </div>

    <div id="search-result" class="result"></div>
</div>
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon lazyload" src="/images/placeholder.png" data-src="/images/favicon.png">  
      

         
            

            <a class="mobile-menu-link" href="/">Home
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">Archives
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">Tags
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">About
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">Search </a>                 
            
         
      
</div>
        
    



     
    


<footer class="footer">
	<div class="inner">
		<div class="copyright">
			&copy;
			
			2019
			Lemon

			<br>
			By <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>
	</div>
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>