<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Android渲染机制 | 姜雷12138</title>
  
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class="cover post half">
      
        
  <h1 class="title">姜雷12138不定期更新的日常</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder>
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class="menu navgation">
  <ul class="h-list">
    
      
        <li>
          <a class="nav home" href="/" id="home">
            <i class="fas fa-rss fa-fw"></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/projects/" id="projects">
            <i class="fas fa-code-branch fa-fw"></i>&nbsp;项目
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/friends/" rel="nofollow" id="friends">
            <i class="fas fa-link fa-fw"></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/" rel="nofollow" id="about">
            <i class="fas fa-info-circle fa-fw"></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          姜雷12138
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/" rel="nofollow" id="blogcategories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/" rel="nofollow" id="blogtags">
									<i class="fas fa-hashtag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-clock fa-fw"></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/" id="projects">
								<i class="fas fa-code-branch fa-fw"></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/" rel="nofollow" id="friends">
								<i class="fas fa-link fa-fw"></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/" rel="nofollow" id="https:xaoxuu.comwikimaterial-x">
								<i class="fas fa-book fa-fw"></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2018/10/01/Android渲染机制/">
        Android渲染机制
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://jianglei12138.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>姜雷12138</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2018-10-01</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Android学习/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Android学习</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。</p>
 <a id="more"></a>
<h1 id="Android渲染机制"><a href="#Android渲染机制" class="headerlink" title="Android渲染机制"></a>Android渲染机制</h1><p>关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。</p>
<h2 id="从Activity-setContentView说起"><a href="#从Activity-setContentView说起" class="headerlink" title="从Activity#setContentView说起"></a>从Activity#setContentView说起</h2><p>一般创建应用时，Activity是承载我们视图的首要选择。为了能够正常显示视图，我们一般会通过调用 <code>Activity#setContentView</code> 方法来进行加载。但是，这个方法究竟调用了什么方法实现真正展现视图的？又是如何现实的呢？从源码最终我们能看到，<code>setContentView</code> 最终的实现位于  <strong>PhoneWindow</strong> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mContentParent是PhoneWindow内容的根布局，首先检测mContentParent</span></span><br><span class="line">    <span class="comment">// 创建或者不空移除子View，防止重复的调用setContentView</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scene是Kitkat引入的场景API, 可以通过Transition来实现带有动画的场景切换</span></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// inflater对应的view attach到mContentParent中</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们所使用的View最终都会被添加到mContentParent中，mContentParent究竟是一个什么样的ViewGroup呢？首先看一下mContentParent的创建与初始化，其初始化代码位于installDecor中，由于代码量比较多，此处只摘取部分重要内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 创建Decor</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处可以简化为 new DecorView()</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由Decor创建mContentParent</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDecorContentParent = decorContentParent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处callback是指后面的Activity传入的callback，详情见后面分析</span></span><br><span class="line">            mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">            <span class="keyword">if</span> (mDecorContentParent.getTitle() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> localFeatures = getLocalFeatures();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((localFeatures &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mTitleView = findViewById(R.id.title);</span><br><span class="line">            <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                    <span class="keyword">if</span> (titleContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        titleContainer.setVisibility(View.GONE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mTitleView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mContentParent.setForeground(<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTitleView.setText(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDecor.getBackground() == <span class="keyword">null</span> &amp;&amp; mBackgroundFallbackResource != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面述代码，我们能够了解以下几个事实</p>
<ul>
<li>创建mDecor，mDecor的创建过程比较简单，通过直接实例化DecorView</li>
<li>通过generateLayout创建mContentParent</li>
<li>创建mContentParent后会去找到DecorContentParent/TitleView，然后对UI进行修改</li>
</ul>
<p>那么generateLayout究竟是怎么实现的呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略解析设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inflate the window decor.</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">// System.out.println("Features: 0x" + Integer.toHexString(features));</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        <span class="comment">// System.out.println("Title Icons!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with only a progress bar (and title).</span></span><br><span class="line">        <span class="comment">// XXX Need to have a no-title version of embedded windows.</span></span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">        <span class="comment">// System.out.println("Progress!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with a custom title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogCustomTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no other features and not embedded, only need a title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("Title!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println("Simple!");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处把上述的layout inflater之后添加到mDecorView中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mContentParent即mDecor的子View ID为ID_ANDROID_CONTENT(com.android.internal.R.id.content)</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ProgressBar progress = getCircularProgressBar(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (progress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            progress.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侧滑退出Activity实现</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        registerSwipeCallbacks(contentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generateLayout方法就是根据mLocalFeatures寻找到对应的layout。这些layout位置位于frameworks/base/core/res/res/layout/目录下。这些所有的layout都有一个id为 <strong>com.android.internal.R.id.content</strong> 的FrameLayout，而这个FrameLayout就是放置我们自定义布局ContentView的mContentParent，也就是我们Acitivity所传递过来的View最终都都会被添加到这个FrameLayout中</p>
<p><img src="/2018/10/01/Android渲染机制/content_layout.png" alt="content_layout"></p>
<p><strong>本节知识点</strong></p>
<ol>
<li>Scene结合Transiation实现场景动画切换 <a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">Android Transition Framework</a></li>
<li>最简单实现侧滑退出Activity requestWindowFeature使用 <strong>PhoneWindow#requestFeature</strong></li>
</ol>
<h2 id="DecorView是什么？"><a href="#DecorView是什么？" class="headerlink" title="DecorView是什么？"></a>DecorView是什么？</h2><p>经过上面的分析，我们知道DecorView是PhoneWindow的独有ViewGroup，也是承载我们Acitiviy视图的RootView，DecorView是FrameLayout子类。到目前为止我们能可以看到一个普通Activity大致的布局如下。</p>
<p><img src="/2018/10/01/Android渲染机制/decor_view.png" alt="Activity层级"></p>
<p>其中：</p>
<ol>
<li>DecorView是Activity的RootView，其他所有View都是其直接或者间接子View</li>
<li>decor_content_parent即上述分析的DecorContentParent，包括常用的ActionBar/Toolbar和我们自己添加的View</li>
<li>navigationBarBackground与statusBarBackground两个View只是为了占用空间，预留给状态栏和导航栏使用，具体的实现位于 <strong>PhoneStatusBarView</strong></li>
</ol>
<p><strong>本节知识点</strong></p>
<ol>
<li>Android里阴影实现的一种方式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initShadowPaints</span><span class="params">(Paint shadowPaint, <span class="keyword">int</span> shadowSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startColor  = <span class="number">0x2a000000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> endColor    = <span class="number">0x00000000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> middleColor = (startColor + endColor) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    shadowPaint.setShader(</span><br><span class="line">            <span class="keyword">new</span> LinearGradient(</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, shadowSize,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;startColor, middleColor, endColor&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0f</span>, <span class="number">0.3f</span>, <span class="number">1f</span>&#125;, Shader.TileMode.CLAMP</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View是什么时候显示的？"><a href="#View是什么时候显示的？" class="headerlink" title="View是什么时候显示的？"></a>View是什么时候显示的？</h2><p>DecorView是我们Activity的根布局，那么他又是怎么显示出来的呢？如果看过ActivityThread源码的话，就会知道在 <strong>ActivityThread#performLaunchActivity</strong> 中创建Activity之后，便会调用 <strong>Activity#attach</strong> 方法。<br>完成此方法调用后，ActivityThread会调用 <strong>Activity#performCreate</strong> 进而调用 <strong>Activity#onCreate</strong> 之后就是我们上述分析的setContentView流程了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, Window window,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处callback的接口定义见下方列举的内容</span></span><br><span class="line">    <span class="comment">// 除了一些关于触摸相关的Activity有对应的实现外</span></span><br><span class="line">    <span class="comment">// 其他Activity中都是空实现</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Thread</span></span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// ActivityThread 此处并不是一个Thread</span></span><br><span class="line">    <span class="comment">// 主线程并不是一个线程</span></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处会调用PhoneWindow父类中的setWindowManager方法</span></span><br><span class="line">    <span class="comment">// 最终获得一个WindowManagerImpl实例</span></span><br><span class="line">    <span class="comment">// 此实例中保存了一个PhoneWindow的属性</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mParent也是Activity，具体使用见知识点</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此mWindowManager如上包含一个PhoneWindow的引用</span></span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window.Callback部分接口列举</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyShortcutEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTrackballEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchGenericMotionEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowAttributesChanged</span><span class="params">(WindowManager.LayoutParams attrs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContentChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们建立了 <strong>Activity</strong> <strong>PhoneWindow</strong> <strong>WindowManager</strong> 的三者之间的联系，简单的用下图表示。总结来说</p>
<ol>
<li>Activity中持有WindowManager与Window的引用，Window通过直接new PhoneWindow得到，WindowManager通过Window提供的接口取得</li>
<li>PhoneWindow中有一系列的成员变量，一般是各种回调，是通过Activity直接设置过来的，都是Activity相同实例。然后Activity通过Window的方法实现初始化Window中的成员变量WindowManager</li>
<li>WindowManager通过上述方法，在创建Window成员变量WindowManager的同时，把Window设置给WindowManager实现双向关联</li>
</ol>
<p><img src="/2018/10/01/Android渲染机制/activity_window_windowmanager.jpg" alt="Activity-Window-WindowManager"></p>
<p>在说剩下的之前，我们要先了解一个既定的事实，View只有被add到WindowManager中才能正常的显示到屏幕上，那么View究竟是怎么被添加到WindowManager中的呢？onCreate之后只是把View添加到DecorView的一个子View中，并没有显示的操作。通过阅读Activity源码中的注释我们知道，在onStart之后，View才被真正的显示出来。</p>
<blockquote>
<p>Activity#onStart Called when the activity is becoming visible to the user.</p>
</blockquote>
<p>大胆猜想，DecorView是在onStart后，onResume前被添加到WindowManager。继续跟ActivityThread中的源码，<strong>ActivityThread#handleResumeActivity -&gt; ActivityThread#performResumeActivity -&gt; Activity#performResume -&gt; Activity#onResume</strong> 看下来你会发现根本没有DecorView的操作，甚至连Window都没有。也就是说在onResume之前，View都是不可见的？其实注释中也是说Activity可见，并没有说明View可见。功夫不负有心人，最终我们在ActivityThread中找到了这部分的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终调用onResume</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 隐藏DecorView</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        <span class="comment">// Activity的TYPE为TYPE_BASE_APPLICATION</span></span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 把DecorView添加到WindowManager中，此时View并不可见，前面有隐藏</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="comment">// 使View可见</span></span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity#makeVisible</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完View的显示时机，我们禁想到一个问题，那就是Activity中的一些明显View的生命周期中的回调，如上述Callback中一些接口的实现，是不是在DecorView中回调的呢。带着这样的疑问，我们先看下Callback到底被设置到了哪里</p>
<ol>
<li>Activity在创建PhoneWindow后，通过调用 <strong>Window#setCallback</strong> 方法传递给PhoneWindow， 并且Window提供了 <strong>Window#getCallback</strong> 方法</li>
<li>setContentView后在PhoneWindow中创建mContentParent后，调用 <strong>DecorContentParent#setWindowCallback</strong></li>
<li>DecorContentParent是一个接口，具体实现在ActionBarView</li>
</ol>
<p>找到所有相关联的类，就能很简单的找到对应的调用，ActionBarView与PhoneWindow，通过callback控制Menu相关的情况。其他的方法，正如我们所料，都是在DecorView被回调，即Activity中所有的有关触摸，按键，onAttachedToWindow与onDetachedFromWindow等都是在DecorView中调用的。</p>
<p><strong>本节知识点</strong></p>
<ol>
<li>Activity中的parent属性，<a href="https://blog.csdn.net/simplebam/article/details/79381754" target="_blank" rel="noopener">android:parentActivityName使用</a></li>
<li>UML图的使用</li>
<li>ActivityThread的大致套路</li>
<li>View真正显示时机</li>
<li>Activity中CallBack接口的回调时机</li>
</ol>
<h2 id="View是如何显示出来的？"><a href="#View是如何显示出来的？" class="headerlink" title="View是如何显示出来的？"></a>View是如何显示出来的？</h2><p>以上分析我们基于这样一个事实，那就是 <strong>“View只要被添加到WindowManager中，才能被正常显示”</strong>，那这个只要add后就能显示的神奇操作是怎么实现的呢？从以上分析我们得知，DecorView通过addView添加到WindowManager中，那么这个WindowManager是如何创建的呢，在attach中通过 <strong>context.getSystemService(Context.WINDOW_SERVICE)</strong> 创建了WindowManager，并设置到PhoneWindow中。一如往常使用getSystemService获得对应的实例。但是不同的是调用getSystemService时使用的context是从ActivityThread直接传递过来的。最终由ActivityThread#createBaseContextForActivity创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContextImpl <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> displayId;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            <span class="keyword">this</span>, r.packageInfo, r.activityInfo, </span><br><span class="line">            r.token, displayId, r.overrideConfig);</span><br><span class="line">    <span class="keyword">return</span> appContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终实现我们得到此getSystemService实现位于 <strong>ContextImpl#getSystemService</strong>，直接调用    <strong>SystemServiceRegistry.getSystemService</strong> 获取对应的Service。SystemServiceRegistry存放了一个SYSTEM_SERVICE_FETCHERS静态HashMap，存放所有的SystemService，我们能拿到的所有Service都是从此处创建获取。我们使用的WINDOW_SERVICE具体实现为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接new WindowManagerImpl</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx);</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>WindowManager创建时，会初始化一个成员变量WindowManagerGlobal，此类为单例类，之后的所有addView，updateViewLayout，removeView都是借助WindowManagerGlobal实现。一个进程中每次调用getSystemService都会创建一个WindowManager实例，但是所有的操作都是委托给同一个WindowManagerGlobal实现。具体添加一个View的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// 如果有父Window，再添加子View的时候需要适当的对父Window做适当的调整</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                            mRoots.get(i).loadSystemProperties();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 系统属性发生修改的回调</span></span><br><span class="line">            SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 之前removeView还未完成</span></span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前添加的View TYPE为SUB_WINDOW, 则需要确认父WINDOW</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ViewRootImpl，并把所有的操作委托给ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新View LayoutParam</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是addView，updateViewLayout还是removeView都是在WindowManagerGlobal封装好一层，交给ViewRootImpl去处理。</p>
<p><img src="/2018/10/01/Android渲染机制/widowmanagerglobal.png" alt="WindowManagerGlobal窗口管理"></p>
<p><strong>本节知识点</strong></p>
<ol>
<li>使用WindowManagerGlobal可以拿到当前进程任何地方获取所有的View</li>
<li>系统属性修改回调 <strong>SystemProperties#addChangeCallback</strong></li>
</ol>
<h2 id="ViewRootImpl是什么？"><a href="#ViewRootImpl是什么？" class="headerlink" title="ViewRootImpl是什么？"></a>ViewRootImpl是什么？</h2><p>从上面我们了解到所有的视图操作都是交给ViewRootImpl去处理的，那么这个ViewRootImpl到底是什么呢？我们看下构造函数的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从WindowManagerGlobal中获取一个IWindowSession的实例</span></span><br><span class="line">    <span class="comment">// 它是ViewRootImpl和WindowManagerService进行通信的代理</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WindowLeaked实例，如果Window未正常释放，会抛出此异常</span></span><br><span class="line">    <span class="comment">// 异常在WindowManagerGlobal抛出，此处只负责创建</span></span><br><span class="line">    mLocation = <span class="keyword">new</span> WindowLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// W类是ViewRootImpl的内部类，继承于IWindow.Stub，会接收来自WMS的回调</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 每一个View都需要依赖于具体的窗口才能显示，View与窗口的关系则是放在View.AttachInfo中</span></span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>,</span><br><span class="line">            context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助功能回调</span></span><br><span class="line">    mAccessibilityManager = AccessibilityManager.getInstance(context);</span><br><span class="line">    mAccessibilityManager.addAccessibilityStateChangeListener(</span><br><span class="line">            mAccessibilityInteractionConnectionManager, mHandler);</span><br><span class="line">    mHighContrastTextManager = <span class="keyword">new</span> HighContrastTextManager();</span><br><span class="line">    mAccessibilityManager.addHighTextContrastStateChangeListener(</span><br><span class="line">            mHighContrastTextManager, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewConfiguration这个类主要定义了UI中所使用到的标准常量</span></span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是一个未经任何处理的事件处理场所</span></span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个mChoreographer，接收底层的Vsync信号重绘</span></span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line"></span><br><span class="line">    mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line"></span><br><span class="line">    loadSystemProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewRootImpl构造函数中创建了大量的重要对象外，在成员变量定义时也创建了几个相对比较重要的成员变量</p>
<ol>
<li>mHander，从名称上看此处应该是一个Handler，具体定义位于 ViewRootImpl.ViewRootHandler，用于将某些应在主线程的操作放到主线程中执行，一般这些操作来自于WMS</li>
<li>mSurface，一个空的Surface</li>
</ol>
<p><strong>本节知识点</strong></p>
<ol>
<li>ViewConfiguration中获取一些View相关</li>
</ol>
<p>在看ViewRootImpl的具体实现之前，需要有一些预备知识。</p>
<h3 id="Surface是什么？"><a href="#Surface是什么？" class="headerlink" title="Surface是什么？"></a>Surface是什么？</h3><p>Android官方文档中是这样描述Surface</p>
<blockquote>
<p>Handle onto a raw buffer that is being managed by the screen compositor.<br>A Surface is generally created by or from a consumer of image buffers (such as a SurfaceTexture, MediaRecorder, or Allocation), and is handed to some kind of producer (such as OpenGL, MediaPlayer, or CameraDevice) to draw into.</p>
</blockquote>
<p>这个描述可以知道：Surface是用来管理一个raw buffer类，Surface本身是由screen compositor来管理的。但是raw buffer具体是什么，screen compositor又是什么，Surface是如何管理一个raw buffer，而它又是怎样被compositor来管理，后续我们会具体来分析。Surface是我们绘制的基础。</p>
<p>从上面我们可以看到，ViewRootImpl在初始化的时候创建了一个Surface对象，通过调用其默认构造函数，默认构造函数中无任何的实现代码，目前我们那到的仍然是一个内容为空的对象。Surface主要代码不在java层，主要的实现位于Native。那么究竟是在哪里创建的呢？从后面的代码中，在我们可以在relayoutWindow函数中发现通过调用 <strong>IWindowSession#relayout</strong> 最终把Surface传递给WMS，即应用程序进程的Surface创建过程是由WMS服务来完成，WMS服务通过Binder跨进程方式将创建好Surface返回给应用程序进程，Binder相关内容在此不表。</p>
<p><strong>IWindowSession#relayout</strong> 的具体实现位于 <strong>Session#relayout</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        MergedConfiguration mergedConfiguration, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mService即WindowManagerService即WMS</span></span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看WMS中关于relayoutWindow中关于Surface的实现主要是调用   <strong>WindowManagerService#createSurfaceControl</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowSurfaceController surfaceController = </span><br><span class="line">        winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见Surface主要通过 <strong>WindowSurfaceController#getSurface</strong> 获得，WindowSurfaceController则通过 <strong>WindowStateAnimator#createSurfaceLocked</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">(<span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.setHasSurface(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>, windowType, ownerUid);</span><br><span class="line"></span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是对直接new做了封装，WindowSurfaceController的构造函数中初始化SurfaceControl，嗯哼，出现我们常见的一个类。常用截图接口 <strong>SurfaceControl#screenshot</strong>，后面就不得不看native代码了，SurfaceControl构造函数中主要调用nativeCreate方法。</p>
<p>nativeCreate实现位于 <strong>android_view_SurfaceControl.cpp#nativeCreate</strong> 中，具体如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint windowType, jint ownerUid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传递过来的sessionObj取得native层的SurfaceComposerClient</span></span><br><span class="line">    <span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">client</span><span class="params">(android_view_SurfaceSession_getClient(env, sessionObj)</span>)</span>;</span><br><span class="line">    SurfaceControl *parent = reinterpret_cast&lt;SurfaceControl*&gt;(parentObject);</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    status_t err = client-&gt;createSurfaceChecked(</span><br><span class="line">            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);</span><br><span class="line">    <span class="keyword">if</span> (err == NAME_NOT_FOUND) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        jniThrowException(env, OutOfResourcesException, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <strong>SurfaceComposerClient#createSurfaceChecked</strong> 创建了对应的SurafceControl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceComposerClient::createSurfaceChecked(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        sp&lt;SurfaceControl&gt;* outSurface,</span><br><span class="line">        uint32_t flags,</span><br><span class="line">        SurfaceControl* parent,</span><br><span class="line">        int32_t windowType,</span><br><span class="line">        int32_t ownerUid)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    status_t err = mStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != nullptr) &#123;</span><br><span class="line">            parentHandle = parent-&gt;getHandle();</span><br><span class="line">        &#125;</span><br><span class="line">        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,</span><br><span class="line">                windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="keyword">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mClient 即 ISurfaceComposerClient， 此处为跨进程调用，最终实现位于 <strong>SurfaceFlinger#Client.cpp</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">status_t Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    class MessageCreateLayer : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        status_t result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        uint32_t w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">status_t <span class="title">getResult</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function">virtual bool <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用SurfaceFlinger#createLayer</span></span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> static_cast&lt;MessageCreateLayer*&gt;(msg.get())-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终调用的方法是 <strong>SurfaceFlinger#createLayer</strong> 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceFlinger::createLayer(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        int32_t windowType, int32_t ownerUid, sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    String8 uniqueName = getUniqueLayerName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此flags由</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createBufferLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:</span><br><span class="line">            result = createColorLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags,</span><br><span class="line">                    handle, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// window type is WINDOW_TYPE_DONT_SCREENSHOT from SurfaceControl.java</span></span><br><span class="line">    <span class="comment">// TODO b/64227542</span></span><br><span class="line">    <span class="keyword">if</span> (windowType == <span class="number">441731</span>) &#123;</span><br><span class="line">        windowType = <span class="number">2024</span>; <span class="comment">// TYPE_NAVIGATION_BAR_PANEL</span></span><br><span class="line">        layer-&gt;setPrimaryDisplayOnly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    layer-&gt;setInfo(windowType, ownerUid);</span><br><span class="line"></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer, *parent);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;saveSurfaceCreation(layer);</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续不需要再深入，留待以后讲SurfaceFlinger后再深入了解。目前我们知道最终通过SurfaceFlinger创建Layer，并把Layer的代理对象, gdp就是图像缓冲区代理对象 返回给SurfaceComposerClient方便创建SurfaceControl。</p>
<p>到目前为止，我们得到了native的SurfaceControl，所有对象已经准备完毕，上文说道，最终  <strong>WindowSurfaceController#getSurface</strong> 获取Surface对象内容，大胆的猜测，此方法最终返回的其实是SurfaceFlinger创建的这块layer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WindowSurfaceController#getSurface</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Surface#copyFrom</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"other must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    <span class="keyword">if</span> (surfaceControlPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</span><br><span class="line">                <span class="string">"null SurfaceControl native object. Are you using a released SurfaceControl?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面就是通过jni调用把使用SurfaceControl来填充Surface</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceControl#getSurface</span></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateSurfaceLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    <span class="comment">// mGraphicBufferProducer即上文提到的dgp，图像缓冲区代理对象</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/01/Android渲染机制/surface.png" alt="Surface的创建"></p>
<p>总结一下Surface的创建过程：</p>
<ol>
<li>每一个Window都有且只有一个ViewRootImpl对象，在该对象中会创建一个java层的内容为空的Surface；</li>
<li>当应用程序向WMS服务请求relayout Window，WMS服务在WMS进程创建一个SurfaceController</li>
<li>WMS服务在创建SurfaceController过程中，在自身进程空间创建一个java层的SurfaceControl对象，SurfaceControl创建时会调用jni创建native的SurfaceControl对象。具体实现 <strong>SurfaceComposerClient#createSurfaceChecked</strong> </li>
<li>SurfaceComposerClient通过Binder调用请求<strong>SurfaceFlinger#createLayer</strong>在它的进程空间为当前创建的Surface创建对应的Layer对象，并向WMS返回IGraphicBufferProducer代理对象。SurfaceComposerClient通过此代理对象创建native的SurfaceControl。</li>
<li>WMS服务在再通过 <strong>SurfaceController.getSurface</strong> 使用SurfaceControl填充我们需要的Surface</li>
</ol>
<p><strong>其他总结</strong></p>
<ol>
<li><strong>SurfaceControl#screenshot</strong> 使用</li>
<li>跨进程调用的实现，使用</li>
<li>JNI静态注册，动态注册，基本使用</li>
<li>SurfaceFlinger的基本功能</li>
</ol>
<h3 id="Choreographer是什么？"><a href="#Choreographer是什么？" class="headerlink" title="Choreographer是什么？"></a>Choreographer是什么？</h3><p>Android系统加入Choreographer这个类的目的来处理输入(Input)、动画(Animation)、绘制(Draw)三个操作。Choreographer接收显示系统底层传上来的垂直同步信号(VSync信号)，在下一个帧渲染时控制执行这些操作。</p>
<p> <strong>理想状态下的choreographer</strong><br><img src="/2018/10/01/Android渲染机制/choreographer.png" alt="理想状态下的choreographer"></p>
<p> <strong>丢帧状态下的choreographer</strong><br><img src="/2018/10/01/Android渲染机制/choreographer_jank.png" alt="丢帧状态下的choreographer"></p>
<p>Choreographer的基本原理如此，下面看下怎么实现的。Choreographer使用ThreadLocal保存Choreographer实例，保证每个Thread只存在一个Choreographer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Looper looper = Looper.myLooper();</span><br><span class="line">            <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Input callback.  Runs first.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Animation callback.  Runs before traversals.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Traversal callback.  Handles layout and draw.  </span></span><br><span class="line"><span class="comment">// Runs after all other asynchronous messages have been handled.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Commit callback.  Handles post-draw operations for the frame.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_COMMIT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">FrameInfo mFrameInfo = <span class="keyword">new</span> FrameInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个线程对应一个Looper，每个线程对应一个Choreographer</span></span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同type初始化不同CallbackQueue，共4中如上</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上功能有</p>
<ol>
<li>初始化FrameHandler，接收处理消息。使用Handler的原因是保证所有的操作都是在同一个线程实现的</li>
<li>初始化FrameDisplayEventReceiver，FrameDisplayEventReceiver用来接收垂直同步信号。FrameDisplayEventReceiver继承于DisplayEventReceiver。当垂直同步信号过来后会回调 <strong>DisplayEventReceiver#dispatchVsync</strong> 方法，最终调用到onVsync方法</li>
<li>初始化mLastFrameTimeNanos(上一个frame的渲染时间)以及mFrameIntervalNanos(帧率,fps，一般手机上为1s/60)。</li>
<li>初始化了大小为4的CallbackQueue</li>
<li>初始化mFrameInfo用来保存当前帧的信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called when a vertical sync pulse is received.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否丢帧</span></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                + <span class="string">"one at a time."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules a single vertical sync pulse to be delivered when the next</span></span><br><span class="line"><span class="comment">// display frame begins.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Choreographer对外提供了postCallback与postFrameCallback，最终这两个方法调用的都是同一个方法 <strong>Choreographer#postCallbackDelayedInternal</strong> ，postFrameCallback的TYPE为CALLBACK_ANIMATION</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delayMillis为0， 直接调用scheduleFrameLocked等待下一次Vsync到来</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中postCallback的具体流程如下。</p>
<p><img src="/2018/10/01/Android渲染机制/choreographer_process.png" alt="choreographer机制"></p>
<p>doFrame中做了些什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从不同的Queue中取出对应的Runnable执行，会取空队列</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本节知识点</strong></p>
<ol>
<li>获取设备刷新率，私有方法 <strong>Choreographer##getRefreshRate</strong>，一般不可靠，直接写死</li>
<li>可以在任何地方使用 <strong>Choreographer#postFrameCallback</strong>，与 <strong>View#post</strong> 或者 <strong>Handler#post</strong> 区别是不会立马执行，要等下一个垂直信号过来才会执行</li>
</ol>
<h3 id="ViewRootImpl-setView实现"><a href="#ViewRootImpl-setView实现" class="headerlink" title="ViewRootImpl#setView实现"></a>ViewRootImpl#setView实现</h3><p>了解以上两个基础知识后，剩下的就是看ViewRootImpl是怎么实现View的绘制显示的。 <strong>ViewRootImpl#setView</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">            mFallbackEventHandler.setView(view);</span><br><span class="line"></span><br><span class="line">            mWindowAttributes.copyFrom(attrs);</span><br><span class="line">            <span class="keyword">if</span> (mWindowAttributes.packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowAttributes.packageName = mBasePackageName;</span><br><span class="line">            &#125;</span><br><span class="line">            attrs = mWindowAttributes;</span><br><span class="line">            mClientWindowLayoutFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// RootViewSurfaceTaker即DecorView</span></span><br><span class="line">            <span class="comment">// Activity可以像SurfaceView一样，接管Surface，直接操作Surface</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                mSurfaceHolderCallback =</span><br><span class="line">                        ((RootViewSurfaceTaker)view).willYouTakeTheSurface();</span><br><span class="line">                <span class="keyword">if</span> (mSurfaceHolderCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mSurfaceHolder = <span class="keyword">new</span> TakenSurfaceHolder();</span><br><span class="line">                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);</span><br><span class="line">                    mSurfaceHolder.addCallback(mSurfaceHolderCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compute surface insets required to draw at specified Z value.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Use real shadow insets for a constant max Z.</span></span><br><span class="line">            <span class="keyword">if</span> (!attrs.hasManualSurfaceInsets) &#123;</span><br><span class="line">                attrs.setSurfaceInsets(view, <span class="keyword">false</span> <span class="comment">/*manual*/</span>, <span class="keyword">true</span> <span class="comment">/*preservePrevious*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 硬件加速，此处会创建ThreadedRenderer，见后文硬件加速的详细介绍</span></span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">// 第一次requestLayout</span></span><br><span class="line">            requestLayout();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果Window支持触摸，需要添加InputChannel通过WMS传递事件</span></span><br><span class="line">            <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把当前Window添加到WMS，此时Surface还未准备好不能绘制</span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPendingOverscanInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            mPendingContentInsets.set(mAttachInfo.mContentInsets);</span><br><span class="line">            mPendingStableInsets.set(mAttachInfo.mStableInsets);</span><br><span class="line">            mPendingVisibleInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to add window -- unknown error code "</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Activity接管触摸操作</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                mInputQueueCallback =</span><br><span class="line">                    ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建WindowInputEventReceiver接收触摸事件</span></span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把当前View的parent设置为当前ViewRootImpl</span></span><br><span class="line">            <span class="comment">// Parent需要实现ViewParent</span></span><br><span class="line">            view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ViewRootImpl#setView</strong> 中调用比较重要的接口requestLayout，requestLayout操作主要调用 <strong>ViewRootImpl#scheduleTraversals</strong>，具体实现如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler的SyncBarrier，见总结</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在Choreographer中post一个CALLBACK_TRAVERSAL，下一次垂直同步的时候执行 TraversalRunnable#doTraversal，进而performTraversals</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            <span class="comment">// 在Choreographer中post一个CALLBACK_INPUT，下一次垂直同步的时候执行 TraversalRunnable#doConsumeBatchedInput</span></span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知ThreadedRenderer即将有新的frame到来</span></span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduleTraversals主要完成了向Choreographer中post CALLBACK_TRAVERSAL与CALLBACK_INPUT两种类型的callback，等待重绘和触摸事件的到来，关于触摸的实现我们暂时不管，主要看绘制的实现。</p>
<p><strong>本节知识点</strong></p>
<ol>
<li>在MessageQueue中添加一个特殊的SyncBarrier作为一个标记，在这个标记被移除之前，当前MessageQueue队列中排在它后面的其它非异步的message不会被handler处理</li>
</ol>
<h3 id="ViewRootImpl-performTraversals流程"><a href="#ViewRootImpl-performTraversals流程" class="headerlink" title="ViewRootImpl#performTraversals流程"></a>ViewRootImpl#performTraversals流程</h3><p>由于performTraversals代码量相对较大，只是我目前见过一个函数行数最多的，大概800行左右，看起来可能不是那么直观。一般自定义的View时候，一般 onMeasure onLayout onDraw三个方法，performTraversals大致也是这几个流程。</p>
<h4 id="测量阶段"><a href="#测量阶段" class="headerlink" title="测量阶段"></a>测量阶段</h4><p>doTraversal的第一阶段，会对整个控件树进行第一次测量，在此阶段会控件树所显示所需要的尺寸，在这个阶段，控件树中的所有View都会被调用到 <strong>View#onMeasure</strong> 方法，一般是从父布局中调用子View的onMeasure方法，父布局通过onMeasure的参数来把传达的参数给到子View， <strong>View#onMeasure</strong> 的具体定义如下，MeasureSpec虽然是一个整形，但却是一个复合型的变量, 其中前两位是测量模式，剩下的30位是width或者height。MeasureSpec只是子View作为设定自身大小参考，只是个参考，要多大，还是View自己说了算，但是View一旦超过父布局大小，界面可能显示不了。测量模式包括三种，UNSPECIFIED、EXACTLY、AT_MOST。</p>
<ol>
<li>UNSPECIFIED：父控件对子控件不加任何束缚，子元素可以得到任意想要的大小，这种MeasureSpec一般是由父控件自身的特性决定的。比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示，这个时候，size一般就没什么意义。</li>
<li>EXACTLY：父控件为子View指定确切大小，希望子View完全按照自己给定尺寸来处理，这时的MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数（MATCH_PARENT）来确定的。</li>
<li>AT_MOST：父控件为子元素指定最大参考尺寸，希望子View的尺寸不要超过这个尺寸，这种模式也是父控件根据自身的MeasureSpec跟子View的布局参数（WRAP_CONTENT）来确定的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存放根View宽高</span></span><br><span class="line"><span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line"><span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">...    </span><br><span class="line"></span><br><span class="line"><span class="comment">// WMS给定的最新Window Size</span></span><br><span class="line">Rect frame = mWinFrame;</span><br><span class="line"><span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">    mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">        <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></span><br><span class="line">        Point size = <span class="keyword">new</span> Point();</span><br><span class="line">        mDisplay.getRealSize(size);</span><br><span class="line">        desiredWindowWidth = size.x;</span><br><span class="line">        desiredWindowHeight = size.y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">        desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用控件树 onAttachedToWindow</span></span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    desiredWindowWidth = frame.width();</span><br><span class="line">    desiredWindowHeight = frame.height();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WMS 单方面修好了mWidth、mHeight强制重绘</span></span><br><span class="line">    <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当setView过mLayoutRequested才为true</span></span><br><span class="line"><span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类似悬浮窗</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></span><br><span class="line">                Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Configuration config = res.getConfiguration();</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终测量</span></span><br><span class="line">    windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终多有的操作都是交给measureHierarchy进行控件树的测量。多次协商后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 对于MATCH_PARENT或者直接写死不需要</span></span><br><span class="line">    <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// 首先使用最期望的宽度限制进行测量，常量</span></span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</span><br><span class="line">        res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> baseSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">            baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">            childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">            <span class="comment">// 第一次测量</span></span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测测量结果</span></span><br><span class="line">            <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</span><br><span class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">                <span class="comment">// 第二次测量</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!goodMeasure) &#123;</span><br><span class="line">        <span class="comment">// 第三次测量</span></span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> windowSizeMayChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见最终是调用了performMeasure方法来进行测量， 最终调用的地方 <strong>View#measure(childWidthMeasureSpec, childHeightMeasureSpec)</strong> measure也是对onMeasure的封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传递getSuggestedMinimumWidth()的意义在于当mode为UNSPECIFIED时需要获取size</span></span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么使用mininum？</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，应用层的测量几乎完成，剩下的是与WMS做相关的沟通，主要以relayoutWindow为核心，其主要是通过mWindowSession调用relayout方法使用，注意relayout中回把mSurface传给WMS,其中有些硬件加速相关的代码，暂时不表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame,</span><br><span class="line">            mPendingMergedConfiguration, mSurface);</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本节知识点</strong></p>
<ol>
<li>三种测量模式</li>
</ol>
<h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p>布局阶段主要完成控件树的布局和一些透明度区域的收集，以及与WMS协商。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">        || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line"><span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By this point all views have been sized and positioned</span></span><br><span class="line">    <span class="comment">// We can compute the transparent area</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// start out transparent</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> AVOID THAT CALL BY CACHING THE RESULT?</span></span><br><span class="line">        host.getLocationInWindow(mTmpLocation);</span><br><span class="line">        mTransparentRegion.set(mTmpLocation[<span class="number">0</span>], mTmpLocation[<span class="number">1</span>],</span><br><span class="line">                mTmpLocation[<span class="number">0</span>] + host.mRight - host.mLeft,</span><br><span class="line">                mTmpLocation[<span class="number">1</span>] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">        host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">            mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// reconfigure window manager</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局最重要调用performLayout，其最重要的实现是 <strong>View#layout</strong>，layout中通过setFrame设置View的LTRB，setFrame中检测到size发生改变或者第一次调用会调用onSizeChange方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>
<p>布局的另一阶段是计算窗口的透明区域，方便后续底层SurafceFlinger做合成，类似在Surface上挖了一个洞。可以直接透过这个窗口看下后面的内容，常见于视频播放器。这一机制常用于SurfaceView。</p>
<h4 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h4><p>测量与布局完成后，既可以绘制了。 绘制的判断不多，主要调用performDraw方法。performDraw方法主要是调用draw方法。draw方法中关于动画的处理我们暂时不处理，主要看具体的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里Android提供了两种绘图的方法。软件绘制与硬件绘制。由于内容相对较多，后面拆成两个小节来处理。</p>
<h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><p>软件绘制，是由CPU主导绘图，所有的操作由CPU来完成。适用于一些二维的绘图，底层调用的是Skia库。下面看下ViewRootImpl是如何进行软件绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到绘制Canvas，此处可能会修改dirty的值</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先清空成透明</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最终绘制方法</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放Canvas</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中我们可以看到直接通过 <strong>Surface#lockCanvas</strong> 取得Canvas，然后偶就可以通过此Canvas进行绘制，那么这个lockCanvas究竟做了些什么？看代码其实只是调用的 <strong>android_view_Surface#nativeLockCanvas</strong> 方法。此方法实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Surface</span></span><br><span class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算脏区</span></span><br><span class="line">    <span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">    Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ANativeWindow_Buffer结构体保存 w h stride format bits</span></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                         convertPixelFormat(outBuffer.format),</span><br><span class="line">                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888</span><br><span class="line">                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,</span><br><span class="line">                                         GraphicsJNI::defaultColorSpace());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Bitmap</span></span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    <span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    bitmap.setInfo(info, bpr);</span><br><span class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmap.setPixels(outBuffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">        bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Canvas</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip rect</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">                dirtyRect.right, dirtyRect.bottom, SkClipOp::kIntersect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改脏区</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用 <strong>Surface#lock</strong> 获取ANativeWindow_Buffer，里面存放Surface的具体宽，高，stride以及内存等信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindow_Buffer</span> &#123;</span></span><br><span class="line">    <span class="comment">/// The number of pixels that are shown horizontally.</span></span><br><span class="line">    <span class="keyword">int32_t</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The number of pixels that are shown vertically.</span></span><br><span class="line">    <span class="keyword">int32_t</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The number of *pixels* that a line in the buffer takes in</span></span><br><span class="line">    <span class="comment">/// memory. This may be &gt;= width.</span></span><br><span class="line">    <span class="keyword">int32_t</span> stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The format of the buffer. One of AHARDWAREBUFFER_FORMAT_*</span></span><br><span class="line">    <span class="keyword">int32_t</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The actual bits.</span></span><br><span class="line">    <span class="keyword">void</span>* bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Do not touch.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">6</span>];</span><br><span class="line">&#125; ANativeWindow_Buffer;</span><br></pre></td></tr></table></figure>
<p>之后通过所有的绘制操作，都是在这块Surface上进行绘制。关于Skia的绘制实现不表。后面即听过 <strong>View.draw(canvas)</strong> 把对应的View显示内容绘制到Surface上。后面我们详细分析这个方法。最后通过 <strong>Surface.unlockCanvasAndPost(canvas)</strong> 释放Canvas</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 硬件操作暂时不管</span></span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 软件实现</span></span><br><span class="line">            unlockSwCanvasAndPost(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        nativeRelease(mLockedObject);</span><br><span class="line">        mLockedObject = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和lockCanvas一样最终调用也是native中的nativeUnlockCanvasAndPost方法，实现位于 android_view_Surface.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detach the canvas from the surface</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlock surface</span></span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就来分析具体的绘制流程 <strong>View#draw</strong> 方法。draw方法的注释其实已经写明了绘制的过程</p>
<blockquote>
<p>Draw traversal performs several drawing steps which must be executed in the appropriate order:</p>
<ol>
<li>Draw the background</li>
<li>If necessary, save the canvas’ layers to prepare for fading</li>
<li>Draw view’s content</li>
<li>Draw children</li>
<li>If necessary, draw the fading edges and restore layers</li>
<li>Draw decorations (scrollbars for instance)</li>
</ol>
</blockquote>
<h4 id="绘制背景"><a href="#绘制背景" class="headerlink" title="绘制背景"></a>绘制背景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断是否是 “实心” 控件，所谓的实心控件是指后续的onDraw绘制内容能够完整的覆盖掉View的所有区域，此时为了提高绘制效率就不需要绘制背景，自定义View时可以通过重写isOpaque()方法实现。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line">    <span class="comment">// 如果不是</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用硬件加速绘制</span></span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RenderNode renderNode = mBackgroundRenderNode;</span><br><span class="line">        <span class="keyword">if</span> (renderNode != <span class="keyword">null</span> &amp;&amp; renderNode.isValid()) &#123;</span><br><span class="line">            setBackgroundRenderNodeProperties(renderNode);</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软件绘制， 这里有一点需要注意的地方就是两次平移操作</span></span><br><span class="line">    <span class="comment">// 在最开始调用draw方法之前其实ViewRootImpl是有对移动操作做单独的处理的</span></span><br><span class="line">    <span class="comment">// 此处把对应的操作给回滚了，是为了保证背景不会随着滚动而滚动</span></span><br><span class="line">    <span class="comment">// 当然绘制结束后需要恢复translate</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在说下面的准备绘制渐变框之前，需要单独的提一下不表示所有的控件都需要绘制这个所谓的渐变框的，因此第2步和第5部步是可以省略的。</p>
<h4 id="准备绘制渐变框"><a href="#准备绘制渐变框" class="headerlink" title="准备绘制渐变框"></a>准备绘制渐变框</h4><p>所谓的渐变，其实就是我们常见的诸如ListView等控件在拖动到顶部或者底部后弹出来的渐变效果，如下图。渐变框可以通过android:fadingEdge设置渐变的方向，android:fadingEdgeLength来设置渐变框的长度</p>
<p><img src="/2018/10/01/Android渲染机制/fade.jpeg" alt="渐变效果"></p>
<p>此步骤只是设置了通过计算当前需要绘制的渐变框位置与区域，然后保存layer</p>
<h4 id="绘制内容"><a href="#绘制内容" class="headerlink" title="绘制内容"></a>绘制内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接调用onDraw方法绘制其内容，View中此方法为空实现，一般自定义View重写此方法</span></span><br><span class="line"><span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br></pre></td></tr></table></figure>
<h4 id="绘制子控件"><a href="#绘制子控件" class="headerlink" title="绘制子控件"></a>绘制子控件</h4><p>之后便是绘制子控件的流程，由于不是所有控件都有子空间，因此在View中此方法为空实现，ViewGroup中才有具体的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip操作，有时候子控件大小可能超过当前ViewGroup，一般超出区域会直接忽略掉</span></span><br><span class="line">    <span class="comment">// 可以通过ViewGroup#setClipToPadding修改</span></span><br><span class="line">    <span class="keyword">int</span> clipSaveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> more = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">            ? <span class="keyword">null</span> : buildOrderedChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取View的绘制顺序，View的绘制顺序会影响重叠时候的显示效果。先绘制的View会被后续绘制的View覆盖</span></span><br><span class="line">        <span class="comment">// 可以通过getChildDrawingOrder来设置绘制顺序，默认实现是先加入则先绘制</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        canvas.restoreToCount(clipSaveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mGroupFlags might have been updated by drawChild()</span></span><br><span class="line">    flags = mGroupFlags;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>决定了绘制顺序后，ViewGroup便会通过 drawChild方法绘制子控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意不是子控件draw(canvas)接口</span></span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处调用了子View的 <strong>View.draw(ViewGroup,Canvas,long)</strong>，大致经历以下操作</p>
<ol>
<li>进行动画的计算，将计算结果存储一个Transformation中</li>
<li>计算控件内容的滚动量</li>
<li>使用Canvas.save()保存Canvas的当前状态。此时Canvas的坐标系为父控件的坐标系。在随后将Canvas变换到此空间的坐标系并完成绘制后，会通过Canvas.restoreTo()将Canvas重置到此时的状态，以便Canvas可以继续用来绘制父控件的下一个子控件</li>
<li>第一次变换，对应控件位置与滚动</li>
<li>将动画产生的变换矩阵应用到Canvas中。主要是各种Animation，如SacleAnimation等</li>
<li>将控件自身的变换矩阵应用到Canvas中</li>
<li>设置剪裁。这个和dispatchDraw()中的裁剪工作不同：dispatchDraw()中的裁剪是为了保证所有的子控件绘制的内容不得越过父控件的边界。此处是指子控件的绘制内容不得超出子控件自身的边界，由setClipChildren()方法启用或禁用</li>
<li>使用变换过的Canvas进行最终绘制，调用dispatchDraw()或者draw(Canvas)两个方法</li>
<li>恢复Canvas的状态到一切开始之前，使得父控件的dispatchDraw()便可以将这个Canvas交给下一个子控件的draw(ViewGroup, Canvas, long)方法</li>
</ol>
<p><img src="/2018/10/01/Android渲染机制/draw.png" alt="控件树绘制的完整流程"></p>
<h4 id="绘制渐变框"><a href="#绘制渐变框" class="headerlink" title="绘制渐变框"></a>绘制渐变框</h4><p>如第2步所示，不细讲</p>
<h4 id="绘制装饰"><a href="#绘制装饰" class="headerlink" title="绘制装饰"></a>绘制装饰</h4><p>此操作用来绘制一些滚动条，ViewOverlay等，ViewOverlay它是位于View视图层顶部的一个附加层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">    mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDrawForeground(canvas);</span><br></pre></td></tr></table></figure>
<p>简单的对软件绘制流程的总结<br><img src="/2018/10/01/Android渲染机制/sw_process.png" alt="软件绘制"></p>
<p><strong>本节知识点</strong></p>
<ol>
<li><strong>View#isOpaque()</strong> 提高绘制效率</li>
<li>ViewOverlay的使用</li>
</ol>
<h3 id="硬件加速绘制"><a href="#硬件加速绘制" class="headerlink" title="硬件加速绘制"></a>硬件加速绘制</h3><p>倘若窗口使用硬件加速，则ViewRootImpl会创建一个ThreadedRenderer并保存在mAttachInfo中，见ViewRootImpl#setView中enableHardwareAcceleration。ThreadedRenderer是用于硬件加速的渲染器，它封装了硬件加速的图形库，并以Android与硬件加速图形库的中间层的身份存在。它负责从Android的Surface生成一个HardwareLayer，供硬件加速图形库作为绘制的输出目标，并提供一系列工厂方法用于创建硬件加速绘制过程中所需的DisplayList、DisplayListCanvas等工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">    mAttachInfo.mHardwareAccelerated = <span class="keyword">false</span>;</span><br><span class="line">    mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hardwareAccelerated =</span><br><span class="line">            (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hardwareAccelerated) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建ThreadedRenderer</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,</span><br><span class="line">                    attrs.getTitle().toString());</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setWideGamut(wideGamut);</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mHardwareAccelerated =</span><br><span class="line">                        mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadedRenderer <span class="title">create</span><span class="params">(Context context, <span class="keyword">boolean</span> translucent, String name)</span> </span>&#123;</span><br><span class="line">    ThreadedRenderer renderer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isAvailable()) &#123;</span><br><span class="line">        renderer = <span class="keyword">new</span> ThreadedRenderer(context, translucent, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ThreadedRenderer(Context context, <span class="keyword">boolean</span> translucent, String name) &#123;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br><span class="line">    mRootNode = RenderNode.adopt(rootNodePtr);</span><br><span class="line">    mRootNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// native 代理。后续详解</span></span><br><span class="line">    mNativeProxy = nCreateProxy(translucent, rootNodePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上代码可知，在开启硬件加速状态下，<strong>ViewRootImpl#enableHardwareAcceleration</strong> 创建了ThreadedRenderer实例，ThreadedRenderer在构造函数中通过调用native方法nCreateRootRenderNode创建了一个RootRenderNode，native对应会创建一个RootRenderNode对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>软件绘制流程我们知道大致经历了 lockCanvas -&gt; draw -&gt; unlockCanvasAndPost三个阶段。对比这三个阶段，我们看下硬件加速的实现方式。入口函数即 <strong>ThreadedRenderer#draw</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记开始绘制，mFrameInfo保存着当前帧的信息</span></span><br><span class="line">    <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">    choreographer.mFrameInfo.markDrawStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新DisplayList</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面会分析这个实现</span></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_LOST_SURFACE_REWARD_IF_FOUND) != <span class="number">0</span>) &#123;</span><br><span class="line">        setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        attachInfo.mViewRootImpl.mSurface.release();</span><br><span class="line">        <span class="comment">// Invalidate since we failed to draw. This should fetch a Surface</span></span><br><span class="line">        <span class="comment">// if it is still needed or do nothing if we are no longer drawing</span></span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Record View#draw()"</span>);</span><br><span class="line">    updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">            canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">            callbacks.onPreDraw(canvas);</span><br><span class="line"></span><br><span class="line">            canvas.insertReorderBarrier();</span><br><span class="line">            canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">            canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">            callbacks.onPostDraw(canvas);</span><br><span class="line">            canvas.restoreToCount(saveCount);</span><br><span class="line">            mRootNodeNeedsUpdate = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mRootNode.end(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DisplayListCanvas <span class="title">start</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DisplayListCanvas.obtain(<span class="keyword">this</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比软件绘制的实现，直接通过lockCanvas获取Canvas，硬件加速会直接调用， <strong>RenderNode#start</strong> 方法直接获取到DisplayListCanvas。而<strong>RenderNode#start</strong>方法则是通过 <strong>DisplayListCanvas#obtain</strong> 获取DisplayListCanvas</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> DisplayListCanvas <span class="title">obtain</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从对象池中取出所需对象，不存在创建，重载需要重置</span></span><br><span class="line">    DisplayListCanvas canvas = sPool.acquire();</span><br><span class="line">    <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas = <span class="keyword">new</span> DisplayListCanvas(node, width, height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,</span><br><span class="line">                width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.mNode = node;</span><br><span class="line">    canvas.mWidth = width;</span><br><span class="line">    canvas.mHeight = height;</span><br><span class="line">    <span class="keyword">return</span> canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DisplayListCanvas 构造函数中会通过nCreateDisplayListCanvas在native层中创建一个对应Canvas对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(jlong renderNodePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* Canvas::create_recording_canvas(<span class="keyword">int</span> width, <span class="keyword">int</span> height, uirenderer::RenderNode* renderNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用OpenGL RecordingCanvas，构造函数中会初始化 DisplayList</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::RecordingCanvas(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了Canvas，我们就有了绘图的工具。紧接我们就可以绘制控件及其子控件了，回到updateRootDisplayList方法，绘制子控件的实现 <strong>canvas.drawRenderNode(view.updateDisplayListIfDirty())</strong> 那么这个 <strong>View#updateDisplayListIfDirty</strong> 做了些什么操作？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RenderNode renderNode = mRenderNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">            || !renderNode.isValid()</span><br><span class="line">            || (mRecreateDisplayList)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> height = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> layerType = getLayerType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和ThreaderRender中使用相同，通过renderNode#start接口获取DisplayListCanvas</span></span><br><span class="line">        <span class="keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                computeScroll();</span><br><span class="line"></span><br><span class="line">                canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">                <span class="comment">// 最终回归到我们软件绘制中draw与dispatchDraw方法</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                    dispatchDraw(canvas);</span><br><span class="line">                    drawAutofilledHighlight(canvas);</span><br><span class="line">                    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                        mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">            setDisplayListProperties(renderNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatchDraw方法和软件绘制相同，几乎没有额外的操作，具体也是在ViewGroup中才会有实现，主要目的是确认子控件的绘制顺序，最终调用也是 drawChild接口，进而 <strong>View#draw(Canvas canvas, ViewGroup parent, long drawingTime)</strong> 这个draw方法与软件绘制最大的不同在于， 会去调用(DisplayListCanvas) canvas).drawRenderNode(renderNode)，关于这个方法的解释，参见后面的详细解释。后续和软件绘制基本没有什么区别，不同的是传入的Canvas是DisplayListCanvas。</p>
<p>从以上操作我们能隐隐约约看出来点什么，这里创建的所有Canvas都是一种Recording Canvas，并且无任何真正的像软件绘制中Canvas.draw这种绘制操作，不难猜测，此处的Canvas应该只是录制了RenderNode的一些操作，具体的绘制不在此。具体是怎么实现录制的呢，回到updateRootDisplayList方法，刚才我们看到通过 Render的start与end接口，录制了根View的绘制操作，而具体的实现则是通过 <strong>DisplayListCanvas#drawRenderNode</strong> 实现，把View的RenderNode录制下来，drawRenderNode的实现特别简单，直接调用了native接口nDrawRenderNode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_DisplayListCanvas_drawRenderNode</span><span class="params">(jlong canvasPtr, jlong renderNodePtr)</span> </span>&#123;</span><br><span class="line">    Canvas* canvas = reinterpret_cast&lt;Canvas*&gt;(canvasPtr);</span><br><span class="line">    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    canvas-&gt;drawRenderNode(renderNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RecordingCanvas::drawRenderNode(RenderNode* renderNode) &#123;</span><br><span class="line">    auto&amp;&amp; stagingProps = renderNode-&gt;stagingProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把添加renderNode封装成一个RenderNodeOp，添加到Canvas中</span></span><br><span class="line">    RenderNodeOp* op = alloc().create_trivial&lt;RenderNodeOp&gt;(</span><br><span class="line">            Rect(stagingProps.getWidth(), stagingProps.getHeight()),</span><br><span class="line">            *(mState.currentSnapshot()-&gt;transform), getRecordedClip(), renderNode);</span><br><span class="line">    <span class="keyword">int</span> opIndex = addOp(op);</span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(opIndex &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新mDisplayList</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = mDisplayList-&gt;addChild(op);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the chunk's child indices</span></span><br><span class="line">        DisplayList::Chunk&amp; chunk = mDisplayList-&gt;chunks.back();</span><br><span class="line">        chunk.endChildIndex = childIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (renderNode-&gt;stagingProperties().isProjectionReceiver()) &#123;</span><br><span class="line">            <span class="comment">// use staging property, since recording on UI thread</span></span><br><span class="line">            mDisplayList-&gt;projectionReceiveIndex = opIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文说过DisplayListCanvas其实不参与真正的绘制，只是记录绘制的操作Op。对应我们在onDraw方法中自己的一些操作，drawBitmap，drawColor之类，DisplayListCanvas也会封装成对应的Op</p>
<p><img src="/2018/10/01/Android渲染机制/op.png" alt="Op"></p>
<p>这样我们就不难得出这样的结论，每一个View中都包含一个RenderNode，此Node对应Native中的RenderNode，而ViewRootImpl则对应RootRenderNode，每一个RenderNode包含DisplayList，DisplayList又有多个Op组成。</p>
<p><img src="/2018/10/01/Android渲染机制/hw_draw.jpg" alt="硬件加速绘制流程"></p>
<p>按照软件绘制的套路，我们先后续的操作 <strong>mRootNode.end(canvas)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(DisplayListCanvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">    nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">    canvas.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_RenderNode_setDisplayList</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject clazz, jlong renderNodePtr, jlong displayListPtr)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    DisplayList* newData = <span class="keyword">reinterpret_cast</span>&lt;DisplayList*&gt;(displayListPtr);</span><br><span class="line">    renderNode-&gt;setStagingDisplayList(newData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderNode::setStagingDisplayList(DisplayList* displayList) &#123;</span><br><span class="line">    mValid = (displayList != <span class="literal">nullptr</span>);</span><br><span class="line">    mNeedsDisplayListSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">delete</span> mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = displayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结一下硬件加速绘制流程</p>
<ol>
<li>利用View的RenderNode获取一个DisplayListCanvas</li>
<li>利用DisplayListCanvas构建并缓存所有的DrawOp</li>
<li>将DisplayListCanvas缓存的DrawOp填充到RenderNode</li>
<li>将根View的缓存DrawOp设置到RootRenderNode中，完成构建</li>
</ol>
<p>以上我们了解具体的录制流程，但是最终是在何处绘制的呢？这时候我们就要回到ThreaderRenderer的构造函数中。还记得那个native代理嘛，看下其具体实现。具体的实现位于Native中，创建一个RenderProxy对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = reinterpret_cast&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode,</span><br><span class="line">                         IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance()), mContext(nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CanvasContext是一个继承IFrameCallback的类，IFrameCallback</span></span><br><span class="line">    mContext = mRenderThread.queue().runSync([&amp;]() -&gt; CanvasContext* &#123;</span><br><span class="line">        <span class="keyword">return</span> CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在updateRootDisplayList之后会调用 nSyncAndDrawFrame， 这个就是绘制的具体实现的部分了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(frameInfoSize != UI_THREAD_FRAME_INFO_SIZE,</span><br><span class="line">            <span class="string">"Mismatched size expectations, given %d expected %d"</span>,</span><br><span class="line">            frameInfoSize, UI_THREAD_FRAME_INFO_SIZE);</span><br><span class="line">    RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    env-&gt;GetLongArrayRegion(frameInfo, <span class="number">0</span>, frameInfoSize, proxy-&gt;frameInfo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体通过syncAndDrawFrame实现绘制</span></span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame() &#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DrawFrameTask::drawFrame() &#123;</span><br><span class="line">    mSyncResult = SyncResult::OK;</span><br><span class="line">    mSyncQueued = systemTime(CLOCK_MONOTONIC);</span><br><span class="line">    postAndWait();</span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    <span class="function">AutoMutex <span class="title">_lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把run方法放到mRenderThread线程中执行</span></span><br><span class="line">    mRenderThread-&gt;queue().post([<span class="keyword">this</span>]() &#123; run(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处会阻塞主线程</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    bool canUnblockUiThread;</span><br><span class="line">    bool canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述代码可知，在主线程通知 <strong>DrawFrameTask#drawFrame</strong> 后，drawFrame调用postAndWait方法，等待mLock释放，此时主线程会被阻塞。为什么此处需要阻塞主线程？其实可以通过后面的在RenderThread执行的run方法来确认原因，后面会有关于是否需要立马释放主线程，还是等待绘制完在释放是需要通过syncFrameState返回值来判断的，原因是因为RenderThread与主线程同时持有了一些绘制帧信息。在绘制之前需要同步保证相同，具体的实现位于 prepareTree 中，具体实现此处不表。如果想要查看具体的绘制流程可以参考 <a href="https://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> vsync = mFrameInfo[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FrameInfoIndex::Vsync)];</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(vsync);</span><br><span class="line">    <span class="keyword">bool</span> canDraw = mContext-&gt;makeCurrent();</span><br><span class="line">    mContext-&gt;unpinImages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mLayers[i]-&gt;apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    mContext-&gt;setContentDrawBounds(mContentDrawBounds);</span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is after the prepareTree so that any pending operations</span></span><br><span class="line">    <span class="comment">// (RenderNode tree state, prefetched layers, etc...) will be flushed.</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mContext-&gt;hasSurface()) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::LostSurfaceRewardIfFound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a surface but can't draw we must be stopped</span></span><br><span class="line">            mSyncResult |= SyncResult::ContextIsStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!info.out.canDrawThisFrame) &#123;</span><br><span class="line">        mSyncResult |= SyncResult::FrameDropped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderThread被唤醒，开始渲染，大致流程如下：</p>
<ol>
<li>先进行DrawOp的合并</li>
<li>接着绘制特殊的Layer</li>
<li>绘制其余所有的DrawOpList</li>
<li>调用swapBuffers将前面已经绘制好的图形缓冲区提交给Surface Flinger合成和显示。</li>
</ol>
<p>对比软件绘制递归调用流程</p>
<p><img src="/2018/10/01/Android渲染机制/sw_hw_difference.png" alt="对比"></p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-04-27T00:56:21+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>last updated at Apr 27, 2019</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Activity启动流程/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Activity启动流程</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/View的现实流程/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>View的现实流程</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/硬件加速/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>硬件加速</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/软件绘制/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>软件绘制</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://jianglei12138.github.io/2018/10/01/Android渲染机制/&title=Android渲染机制 | 姜雷12138&summary=关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://jianglei12138.github.io/2018/10/01/Android渲染机制/&title=Android渲染机制 | 姜雷12138&summary=关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://jianglei12138.github.io/2018/10/01/Android渲染机制/&title=Android渲染机制 | 姜雷12138&summary=关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;Previous</h6>
                            <h4>
                                <a href="/2019/02/20/Glide源码分析/" rel="prev" title="Glide 源码分析">
                                  
                                      Glide 源码分析
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Glide/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>Glide</a> <a class="tag" href="/tags/图像加载/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>图像加载</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>Next&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2018/06/26/从进程起源说起/" rel="prev" title="从进程起源说起">
                                    
                                        从进程起源说起
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Zygote进程/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>Zygote进程</a> <a class="tag" href="/tags/app-process/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>app_process</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Android渲染机制',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <img class="avatar" src="https://avatars3.githubusercontent.com/u/17866650?s=460&v=4">
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:jianglei12138@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/jianglei12138" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=95279873" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;TOC</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android渲染机制"><span class="toc-text">Android渲染机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从Activity-setContentView说起"><span class="toc-text">从Activity#setContentView说起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DecorView是什么？"><span class="toc-text">DecorView是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View是什么时候显示的？"><span class="toc-text">View是什么时候显示的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View是如何显示出来的？"><span class="toc-text">View是如何显示出来的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewRootImpl是什么？"><span class="toc-text">ViewRootImpl是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Surface是什么？"><span class="toc-text">Surface是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Choreographer是什么？"><span class="toc-text">Choreographer是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewRootImpl-setView实现"><span class="toc-text">ViewRootImpl#setView实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewRootImpl-performTraversals流程"><span class="toc-text">ViewRootImpl#performTraversals流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#测量阶段"><span class="toc-text">测量阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#布局阶段"><span class="toc-text">布局阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制阶段"><span class="toc-text">绘制阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软件绘制"><span class="toc-text">软件绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制背景"><span class="toc-text">绘制背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#准备绘制渐变框"><span class="toc-text">准备绘制渐变框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制内容"><span class="toc-text">绘制内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制子控件"><span class="toc-text">绘制子控件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制渐变框"><span class="toc-text">绘制渐变框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制装饰"><span class="toc-text">绘制装饰</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件加速绘制"><span class="toc-text">硬件加速绘制</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/" rel="nofollow" id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/projects/" href="/projects/" id="projects">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/material-x/" href="https://xaoxuu.com/wiki/material-x/" rel="nofollow" id="https:xaoxuu.comwikimaterial-x">
          
            <i class="fas fa-book fa-fw" aria-hidden="true"></i>
          
          主题文档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Categories</div>
  
    <a class="rightBtn" rel="nofollow" href="/blog/categories/" title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Android学习/" href="/categories/Android学习/"><div class="name">Android学习</div><div class="badge">(5)</div></a></li>
        
          <li><a class="flat-box" title="/categories/源码分析/" href="/categories/源码分析/"><div class="name">源码分析</div><div class="badge">(2)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Hot Tags</div>
  
    <a class="rightBtn" rel="nofollow" href="/blog/tags/" title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/Activity启动流程/" style="font-size: 14px; color: #999">Activity启动流程</a> <a href="/tags/Android图形架构/" style="font-size: 14px; color: #999">Android图形架构</a> <a href="/tags/Android图形组件/" style="font-size: 14px; color: #999">Android图形组件</a> <a href="/tags/App启动流程/" style="font-size: 14px; color: #999">App启动流程</a> <a href="/tags/Glide/" style="font-size: 14px; color: #999">Glide</a> <a href="/tags/Main-Handler/" style="font-size: 14px; color: #999">Main Handler</a> <a href="/tags/RxJava2/" style="font-size: 14px; color: #999">RxJava2</a> <a href="/tags/Screen-Tearing/" style="font-size: 14px; color: #999">Screen Tearing</a> <a href="/tags/View的现实流程/" style="font-size: 14px; color: #999">View的现实流程</a> <a href="/tags/Zygote进程/" style="font-size: 14px; color: #999">Zygote进程</a> <a href="/tags/app-process/" style="font-size: 14px; color: #999">app_process</a> <a href="/tags/framebuffer原理/" style="font-size: 14px; color: #999">framebuffer原理</a> <a href="/tags/图像加载/" style="font-size: 14px; color: #999">图像加载</a> <a href="/tags/多缓冲区/" style="font-size: 14px; color: #999">多缓冲区</a> <a href="/tags/数据流/" style="font-size: 14px; color: #999">数据流</a> <a href="/tags/硬件加速/" style="font-size: 14px; color: #999">硬件加速</a> <a href="/tags/软件绘制/" style="font-size: 14px; color: #999">软件绘制</a>
    </div>
  </section>


          
        
      
        
          
          
            



          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:jianglei12138@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/jianglei12138" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=95279873" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
  <div>
    Use
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">material-x</a>
    as theme
    
      , 
      total visits
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      times
    
    . 
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/d5/b004c81a13aea401375d03b1258ecadbfcbaa7.jpg", "https://img.vim-cn.com/4c/8e7294998989454b2dcd2624373d5a699c4414.jpg"],
          {
            duration: "6000",
            fade: "1500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/d5/b004c81a13aea401375d03b1258ecadbfcbaa7.jpg", "https://img.vim-cn.com/4c/8e7294998989454b2dcd2624373d5a699c4414.jpg"],
          {
            duration: "6000",
            fade: "1500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "Copied";
  let COPY_FAILURE = "Copy failed";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
