<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姜雷12138</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jianglei12138.github.io/"/>
  <updated>2019-11-17T17:16:19.172Z</updated>
  <id>https://jianglei12138.github.io/</id>
  
  <author>
    <name>姜雷12138</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从java对象创建说起</title>
    <link href="https://jianglei12138.github.io/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/"/>
    <id>https://jianglei12138.github.io/2019/10/25/从java对象创建说起/</id>
    <published>2019-10-25T15:25:41.000Z</published>
    <updated>2019-11-17T17:16:19.172Z</updated>
    
    <content type="html"><![CDATA[<p>试想一下，如果我们在代码中直接通过关键字new创建了一个对象，JVM会做那些工作从而保证我们后续的使用不出问题呢？java中内存究竟是怎么分配的呢？为什么java new的对象不需要手动释放？带着这些疑问我们一起来研究一下java中对象创建的相关知识。</p> <a id="more"></a><h2 id="Java运行时内存区域划分"><a href="#Java运行时内存区域划分" class="headerlink" title="Java运行时内存区域划分"></a>Java运行时内存区域划分</h2><p>如果经常看一些博客或者有过一些面试的经验，可能经常会看到或者听到这样的结论：”Java中通过new关键字创建对象后，对象是放在内存的堆区，对象的引用是放到栈区“。 那么什么是堆？什么是栈呢？</p><p>按照字面意思上来说，栈是常见的数据结构，遵循先进后出的规则，堆则相反。但是java中是怎么堆与栈区的到底分别是指哪一块区域，到底存放的是什么呢？通过阅读《深入理解Java虚拟机》与《Java虚拟机规范(Java SE 8版)》相关书籍，可以得到如下java运行时内存区域分配图</p><div align="center">  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/memory.png" alt="memory" style="zoom:50%;align:right"></div><p>最明显的内存分为线程共享与线程私有区域，所谓线程共享，是指所有线程都能访问到对应内存区域内容，线程私有则相反，内存只能被当前线程拥有者使用。我们一个个来详细说说这些区域。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器，用来指示当前线程运所执行的字节码指令的地址，不难猜到，此块区域并不需要特别大就已经能够满足需求。由于多线程的<strong>隔离</strong>，必须为每一条线程设置一块程序计数器标示线程运行的位置，等待CPU线程切换继续执行。</p><p>此处可能我们就会想到一个问题，如果当前线程执行的java方法，它应该存放下一次要执行字节码指令的地址，如果当前线程正在通过Jni执行native方法，那么，程序计数器存放的内容是什么呢？Java虚拟机规范规定，此时此内存的内容是undefined。正是因为这些特殊的性质，<strong>此区域JVM没有规定会出现任何形式的OOM</strong></p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>在线程创建的时候，Java虚拟机会为其创建一个单独的栈空间，规范中规定此区域不需要是连续的，栈常用的两个操作，压栈与弹栈，当线程执行到某个方法调用的时候，会把此方法相关内容，或者叫栈条目，如参数，局部变量，以及异常等入栈，栈条目通过被称为<strong>栈帧</strong>，方法执行结束，把对应栈条目弹出栈。在一个线程中的所有方法调用结束的时候，JVM会清空相应的栈内存，并在终止线程之前回收栈空间。</p><div align="center"><img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/JVM.jpg" alt="JVM" style="zoom: 67%;"></div><p>栈帧结构</p><ul><li>LVA，local variable array 本地变量表，变量表的大小由编译期决定，编译期间我们其实已经知道了变量的个数（参数和局部变量），局部变量的类型等，所以此区域不受运行时的修改，一旦编译完成不会再改变，是写在class文件中的。LVA的最小单位叫做变量槽Slot，一般一个Slot至少能存下一个boolean，byte，char，int，short，float，reference或者returnAddress（用来实现异常的处理，目前基本被异常表替代）的数据，对于long与double，JVM规定使用两个Slot存放。一般来说针对非static函数，一般第一个Slot存放的是此对象的引用，剩下的按照参数列表进行排序，参数存放完毕后，在根本方法体内部的变量循序和作用于分配其他Slot</li><li>OS，operand stack，操作栈，一种LIFO的数据结构，编译期间已经确定最大深度，用来记录运行过程中的内容或者存储计算结果。默认方法刚开始执行时，此空间为空，方法执行过程中会有各种字节码向操作栈中读写内容。</li><li>FD，frame data，包括比如方法返回地址，调试信息等。值得注意的是，其中包括一个叫做动态链接的数据，即一个引用指向运行时常量池中的该栈帧所在的方法。</li></ul><p><strong>JVM虚拟机规范中制定，此区域如果请求栈深度超出虚拟机最大允许的深度，则抛出StackOverflow异常，当然因为需要存储数据，如果申请不到内存，也是会发生OOM</strong></p><p>这个虚拟机栈是指上文存放对象引用的栈区么？从上面分析可知，粗略上来说，是的，因为栈帧中LVA存放的就是reference等数据。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>如虚拟机栈相同，虚拟机栈记录的是java的栈帧，本地方法则是对应的native方法的调用，当然JVM对此实现比较自由，不同的虚拟机实现具体不太一致，甚至有的虚拟机是把本地方法与虚拟机栈合并处理的，与虚拟机栈一样，同样存在OOM与StackOverflow异常</p><div align="center">  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/natives.png" alt="native" style="zoom: 67%;"></div><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>刚才有提到，栈帧中FD中存在一项动态链接的数据，指向运行时常量区。这个运行时常量是及方法区的一部分。方法区是线程共享的一部分内存区域。用来存放JVM加载的类（包括方法，属性等），常量，静态变量等数据，另外编译后的代码指令也是放到此处的，因此此块区域叫方法区。方法区在虚拟机启动的时候创建。此区域是堆区的逻辑组成部分，但又与堆区不同，不严谨的说，在某些虚拟机实现中，此区域可能会被叫做<strong>永久代</strong>，这样垃圾回收器就可以把此区域当作堆区进行垃圾回收，自然，因此区域的特殊性，回收带来的回报是很低的。</p><p>另外，JVM规定，<strong>如果方法区无法满足申请分配的内存时，抛出OOM异常</strong></p><p>回到本节最开始的内容，运行时常量池时什么？方法区的一部分。常量池时class信息中的一部分，用于存放编译期生成的各种常量与符号引用。常量池最终会被加载到运行时常量池中。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对于大部分应用来说，堆区应该是最大的一块内存区域，是被所有线程共享的区域。基本所有对象的实例都是在此处被分配，JVM规范是这么定义，所有对象的实例和数组都要在堆上分配（非绝对，见深入理解Java虚拟机）。</p><p>堆是内回收的主要区域，对于使用分代算法的虚拟机来说，此区域包括新生代和老年代。另外与方法区一样，<strong>也会抛出OOM异常</strong></p><p>关于垃圾回收相关内容，可以参考后续的文章</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是JVM运行时内存的一部分，诞生于Java 1.4中加入的NIO，一种基于Channel于Buffer的IO方式，利用Native直接在堆外分配内存。然后通过一个存储在Java堆的DirectByteBuffer对象作为此内存的引用进行操作。在某一些场景中可以显著提高性能，也有可能会发生OOM</p><h4 id="Java新版修改"><a href="#Java新版修改" class="headerlink" title="Java新版修改"></a>Java新版修改</h4><p>另外，<strong>方法区（method area）</strong>只是<strong>JVM规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而<strong>永久代</strong>是<strong>Hotspot</strong>虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。</p><p>在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在本地内存的CodeCache区域，其他都存放在永久代PermGen；<br>在Java 7中，Symbol的存储从PermGen移动到了本地内存，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）<br>在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间<strong>Metaspace</strong></p><p>好了说了这么多与Java内存分配的东西。那么到底对象是怎么创建的呢？</p><h2 id="Java对象创建"><a href="#Java对象创建" class="headerlink" title="Java对象创建"></a>Java对象创建</h2><p>Java是一门面向对象的语言，无时无刻不伴随着对象的创建，与C++不同的是，java所有的方法都必须由class作为载体，无对象无方法。对象创建流程如下</p><ul><li>通过字节码new的参数从常量池中查找是否有对应的class符号引用</li><li>检测class文件是否被加载，解析，初始化<ul><li>未加载，执行类加载过程</li></ul></li><li>未新对象分配内存并置0</li><li>调用构造方法</li></ul><h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>想要知道如何new是如何从常量池中查找class的引用，需要知道class文件中究竟放的是什么内容。因此我们首先分析下class文件的结构。class文件一种以8位字节为基础的二进制流，和常见的二进制文件一样，也是由一定规则组成的，我们以下面一则简单的java程序来说明，class的基本结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIN = <span class="string">"Hello World! form constant"</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mAttribute;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAttribute = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(mAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(MAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.main();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，我们得到一个class文件，我们通过hex friend工具分析class文件的基本组成部分。我们先分析前120个字节的内容，hex结果如下</p><div align="center">  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/hex.png" alt="hex120" style="zoom: 67%;"></div><ul><li>可以看出来，class文件以0xCAFEBABE开始，这个0xCAFEBABE是class文件的魔数，用来标识此文件是class文件，关于此魔数的由来可以参考java之父的解释 <a href="https://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">Java class file </a>。当然不难想到，Java的logo就是一杯咖啡。</li><li>紧接着0x00000034  ，前2个字节0x0000代表minjor次版本号，0x0034主版本号，及十进制的52.0。</li><li>紧接着的是常量池的相关内容，常量池个数+常量表，常量池的内容通常是实际上常量表个数+1，其中多出来的一个是指不指向常量池的项目·，0x0034翻译成十进制即52，即后面共有51个常量。每一项都拥有一个常量类型标志tag，长度为1个字节，比如说第一个常量类型是 0x0A，0x0A表示什么类型呢？</li></ul><div align="center">  <img src="/2019/10/25/%E4%BB%8Ejava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AF%B4%E8%B5%B7/constant.png" alt="constant" style="zoom: 67%;"></div><p>表中u1表示一个字节，u2两个字节。查表可知，0x0A（10进制的10）表示<strong>Constant_methodref_info</strong>，此类型的格式是tag+index(方法的类描述符)+index(方法名称与类型描述符)，我们可以得到<strong>Constant_methodref_info</strong>的对应的类描述符是0x000C，即索引是第12个项目，方法名称和类型指向0x0021，换成10进制33，即对应索引为33的<strong>Constan_NameAndType</strong>，按照此中方式我们不难整理出来，所有的常量的内容。但是一个个人工对太复杂了，java给我们提供了现有的工具<strong>javap</strong>，可以用来解析</p><div align="center">  <img src="/images/placeholder.png" alt="javap" style="zoom: 67%;" data-src="./从java对象创建说起/javap.png" class="lazyload"></div><p>如何便可以知道，0x0A方法是Object的构造函数。当然还有我们定义的一些常量字符串，不难看出，常量池存放的内容是 字面量与符号引用，字面量可以理解为我们java语言中经常接触到的常量，比如说文本字符串，final常量等。符号引用则是编译相关的内容。符号引用包括以下方面的内容 1. 类和接口的全限定名，全限定名是什么意思呢？大概可以理解成我可以通过此限定找到对应满足要求的接口或者类，比如说上图中的#12，我可以通过限定名<strong>java/lang/Object</strong>找到对应的Object类 2. 方法的名称与描述符，举例说明即图中 #11 中关于main方法的描述符<strong>com/jvm/test/Main.main:()V</strong>表示方法为com.jvm.test.Main类中存在一个名为main的方法，参数为空，返回值为V即void，关于描述符的定义，后面会有详细的说明 3. 字段的名称与描述符，后面会有详细说明，如图是hex中常量池的所有内容</p><div align="center">  <img src="/images/placeholder.png" alt="constants" style="zoom: 67%;" data-src="./从java对象创建说起/constants.png" class="lazyload"></div><ul><li>继续，常量池后面的是访问标志，用两个字节表示，访问标志如下, 也是我们常见的能用在定义类，接口，枚举等常见的一些字段。参见下表可知，我们的Main.class是public，对应的标志是ACC_PUBLIC, 因为ACC_SUPER始终为true，所以我们得到的访问标志值是<br>$$<br>0x0020 | 0x0001 = 0x0021<br>$$<br>由常量池中的hex图片可知，访问标志值就是0x0021。</li></ul><div align="center">  <img src="/images/placeholder.png" alt="constants" style="zoom: 67%;" data-src="./从java对象创建说起/access_flag.png" class="lazyload"></div><ul><li>访问标志后面接的是 类索引和接口索引，因为接口是可以多实现的，因此这个接口索引是一个数组，通过这些索引，class可以确定其继承关系。如图是Main类的继承关系，0x0007指向常量池中的第7哥索引值，通过上图中javap的输出可知，当前类是<strong>com/jvm/test/Main</strong>, 当前类的父类是 0x000C对应的索引是<strong>java/lang/Object</strong>，0x0000表示当前类有0个接口。</li></ul><div align="center">  <img src="/images/placeholder.png" alt="class" style="zoom: 67%;" data-src="./从java对象创建说起/class.png" class="lazyload"></div><ul><li><p>确定完继承关系后，可以继续分析接下来的内容，字段表，简单来说就是一些类变量或者实例变量在class文件中的布局，java中通常用可以用来标识一个变量有，<strong>访问控制修饰符（public/private/protected，static，final，volatile，transient）+ 数据类型（基本类型/数组/对象）+ 字段名称</strong> 因为我们可能存在多个字段所以此部分的内容一般是 </p><blockquote><p>n字段个数2bytes + n * (访问标志2bytes + 名字常量池索引2bytes + 描述符常量池索引 + 属性表相关内容) 属性相关内容留着后续说明</p></blockquote><p>其中，访问标志值通位操作或计算得到而成，具体对应的标志值如图</p><div align="center"><img src="/images/placeholder.png" alt="field" style="zoom: 67%;" data-src="./从java对象创建说起/field.png" class="lazyload"></div>另外，关于描述符此处需要好好说以下，描述符的作用是用来描述字段的类型或者函数的参数列表以及返回值，常见的描述符如下，<div align="center"><img src="/images/placeholder.png" alt="descriptor" style="zoom: 67%;" data-src="./从java对象创建说起/descriptor.png" class="lazyload"></div><p>通过此分析，我们可以自己计算这一块的class内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIN = <span class="string">"Hello World! form constant"</span>;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; mAttribute;</span><br></pre></td></tr></table></figure><p>因为类Main中有两个变量(换成16进制即0x0002)，第一个修饰符是<br>$$<br>0x0001 | 0x0008 | 0x0010 = 0x0019<br>$$<br>变量名称为<strong>MAIN</strong>，通过查看javap打印得知，其常量池索引为0x000D(#13), 描述符为<strong>Ljava/lang/String;</strong> 其常量池索引为0x000E, 如果属性值我们暂不讨论的化，那么其字段对应的16进制为， 其中…代表属性相关内容，暂时不表</p><blockquote><p>0x 00 02 00 19 00 0D 00 0E … 00 02 00 10 00 11 …</p></blockquote><p>可以与hex对比可知，正如我们计算的这样</p></li><li><p>除了属性我们没有说明外，基本字段已经说完，后面就可以继续说方法表。方法与字段基本一致，也是访问标识 + 名称索引 + 参数索引 + 属性表，不同的是方法的修饰符与变量不同，方法无法使用volatile或者transient修饰，倒是多了native, synchronized, abstract, strictfp等修饰</p><div align="center"><img src="/images/placeholder.png" alt="method" style="zoom: 67%;" data-src="./从java对象创建说起/method.png" class="lazyload"></div></li></ul><p>比如说Main类中的方法个数为一个构造函数，两个main方法，故共有3个方法</p><div align="center">  <img src="/images/placeholder.png" alt="methods" style="zoom: 67%;" data-src="./从java对象创建说起/methods.png" class="lazyload"></div>目前方法的定义已经说清楚，那么方法内部的实现呢？即code是放在哪里的呢？当然一致都在属性表中，接着我们就来说说这期盼已久的属性表<p>属性表在class文件中算是最复杂的一部分，首先其分类比较多，根据作用不同，放置的位置也不一样，一些列举部分属性表：</p><ul><li><p>属性为ConstantValue，字段表中，一般是static定义的常量值，比如说我们Main类中定义了一个叫做<strong>MAIN</strong>的常量，对应的字段表中存在的属性表存放的内容如下图。可以理解成常量MAIN对应的字段是 0x 00 19 00 0D 00 0E 后面的 0x 00 01表示有一个属性表，第一个属性值为 0x 00 0F，查对应常量池可知第一个属性表内容ConstantValue，即常量值，具体的内容放在紧接着的 0x 00 00 00 02字节的数据, 具体内容在常量池中的索引为0x 00 08 即 <strong>Hello world,from constant</strong>。ConstantValue只支持基本的数据类型和字符串并且被final static修饰的常量（不同javac可能实现不完全一致），如果只是被static修饰或者非基本数据类型和常量是放在<clinit>方法中被初始化的。</clinit></p><div align="center">  <img src="/images/placeholder.png" alt="field_attr" style="zoom: 67%;" data-src="./从java对象创建说起/field_attr.png" class="lazyload"></div><p>另一个变量mAttribute中的属性表是什么内容呢？00 02 00 10 00 11 后面 0x 00 01同样表示一个属性表，0x 00 12在常量池中的索引内容是Signature，对应的长度是0x00 00 00 02字节，内容在常量池的索引是0x 00 13即Ljava/util/List&lt;Ljava/lang/String;&gt;; Signature可用于方法表，类，字段表中。用来记录范型擦除前的类型</p></li><li><p>SourceFile，常用语类文件，记录java源文件的名称。一般情况下名与文件名相同，不难想到内部类可能不一致。在混淆后可以通过SourceFile找到类原始文件，，从而定位错误等。但是此属性可选，不一定需要存在。我们hex显示Main.class的值</p><blockquote><p>ox 00 1F(SourceFile) 00 00 00 02(长度) 00 20(Main.java) </p></blockquote></li><li><p>Deprecated与Synthetic，Deprecated可用于方法表，类文件，字段表中表示此内容已经不推荐使用，Synthetic用于类，方法表或者字段中表示此由编译器生成</p></li><li><p>Exceptions用于方法表，用于记录方法抛出的异常，不是方法内部的异常，如果我们对Main.java进行改造，在Main方法中抛出异常，得到的class文件中关于Main方法就是这样子的，0x 00 1F在常量池对应的Exceptions（此常量池为修改后便意Main.class重新得到的常量池，非上文），属性长度与0x 00 00 00 06，异常的个数为0x 00 02，对应常量池中的数据 0x 00 20与 0x 00 21即java/lang/ExceptionInInitializerError与java/lang/NumberFormatException</p><div align="center">  <img src="/images/placeholder.png" alt="exception" style="zoom: 67%;" data-src="./从java对象创建说起/exception.png" class="lazyload"></div></li><li><p>Code属性表，java方法中的代码在编译完成后会放在code属性表中，如下图，atttibute_name_index即当前属性在常量池中的索引，一般固定是Code</p><div align="center">  <img src="/images/placeholder.png" alt="code" style="zoom: 67%;" data-src="./从java对象创建说起/code_info.png" class="lazyload"></div> <div align="center">  <img src="/images/placeholder.png" alt="code_attr" style="zoom: 67%;" data-src="./从java对象创建说起/code_attr.png" class="lazyload"></div> <p>我们单独拎出来Code的具体内容具体解释，首先是max stack是我们在虚拟机栈中的栈帧的中的OperandStack的最大深度，此处为0x02。本地变量表为0x00，也是栈帧中的变量表大小，以Slot为单位，在栈帧中我们有详细介绍，包括this(非static方法)，参数，局部变量，异常参数(try catch中的参数)等，但是不是所有局部变量的大小的总和，因为一些作用域的问题，此部分可以复用。然后就是code字节码内容</p><blockquote><p>0x BB 00 07 59 B7 00 0A 4C 2B B7 00 0B B1</p></blockquote><p>code内容是一条条字节码组成， 每一个字节码指令都有一个与之对应的1byte数字，即操作码与其对应，详细见 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-7.html" target="_blank" rel="noopener">Opcode Mnemonics by Opcode</a> 每一条指令可能有一个或者多个参数，也可能没有，参考这个表我们可以得到对应的字节码指令，0xBB查表可知为new指令，带有一个参数0x 00 07对应常量池中的<strong>com/jvm/test/Main</strong>，用来创建一个对象，并将其引用值压入栈顶。0x59，即dup，复制栈顶数值并将复制值压入栈顶，也就是说执行到这一句，操作数栈中有两个相同的引用。0xB7，invokespecial调用超类构造方法，实例初始化方法或者私有方法，方法名是0x 00 0A <strong>com/jvm/test/Main.<init></init></strong>，按照这个方式我们能够得到如下表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new #7  // class com/jvm/test/Main</span><br><span class="line">dup</span><br><span class="line">invokespecial #10 // Method "&lt;init&gt;":()V </span><br><span class="line">astore_1</span><br><span class="line">aload_1</span><br><span class="line">invokespecial #11 // Method main:()V</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>大概可以看出来，首先创建了Main对象，复制Main对象入栈，然后栈顶元素的无参构造函数，通过astore_1将栈顶引用型数值存入第二个本地变量(此处第一个变量为args)，然后通过aload_1把第二个引用类型的本地变量推到操作数栈顶，紧接着调用其main无参方法，最后返回。基本上和我们Java代码一致。</p></li><li><p>Code属性表中有一部分attribute叫LineNumberTable，用来记录字节码偏移与java源代码之间的对应关系。比如说main方法中的LineNumberTable是，0x00 17即常量池中的 LineNumberTable 字符串，后面跟着的4字节为Table属性的长度，即14个字节，后面0x 00 03是table的个数，即3个。第一个为0x00 00 00 15解析后的结论就是，code偏移为0字节的指令new，对应java源码在 0x 00 15即21行，第二个为偏移为8字节的指令aload_1，对应java源码在22行，最后偏移为12的指令在对应源码的23行。函数可以用来出现异常时候具体的行数信息，因此是非必须的</p><blockquote><p>0x 00 17 00 00 00 0E 00 03 00 00 00 15 00 08 00 16 00 0C 00 17</p></blockquote></li><li><p>另外一个Code属性值是LocalVariableTable，局部变量表，在栈帧中已经说了很多次了。0x0018常量池中的LocalVariableTable，接着是表的长度，22个字节，0x0002个变量，每一个变量的记录格式是 4字节的作用域(前两个字节开始，后两个字节标识长度) + 变量名称 + 描述符 + 在局部变量表Slot中的位置。按照这个方式我们来解析一下main方法的LocalVariableTable，第一个变量的作用于从0字节开始，长度13字节，即从方法开始到结束，也就是第一个参数的作用域是整个方法。变量的名字是0x00 1D即常量池中的args，描述符为0x00 1E即[Ljava/lang/String，也就是main方法的参数，最后是在Slot的位置0x0000。第二个参数作用域从8字节，长度为5字节，即从0x2B的到方法结束，即aload_1开始到方法结束，变量名称0x001B即main，描述符是0x001A，Lcom/jvm/test/Main;在Slot为1的位置</p><blockquote><p>00 18 00 00 00 16 00 02 00 00 00 0D 00 1D 00 1E 00 00 00 08 00 05 00 1B 00 1A  00 01</p></blockquote></li></ul><p>通过以上分析我们基本能知道一个class文件的基本结构是怎么样子的，但是人工一个个解析实在太繁琐啦，所以可以直接借助<strong>javap -verbose</strong>查看class相关信息。那么class是怎么被加载进内存的呢？</p><h4 id="Class文件加载"><a href="#Class文件加载" class="headerlink" title="Class文件加载"></a>Class文件加载</h4><p>说道class文件的加载，不得不提经典的三个过程，加载-连接-初始化和双亲委派模型，按照常规来说，加载链接初始化对于同一个class而言应该是串行的，但对于多个class而言则可能不一定，并且不是每一个阶段都是必须的，部分可以通过设置一些运行时参数进行省略。</p><div align="center">  <img src="/images/placeholder.png" alt="load" style="zoom: 67%;" data-src="./从java对象创建说起/load.png" class="lazyload"></div> <h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>加载过程粗略的来讲就是把class二进制流加载到内存，具体来说，分为一下步骤</p><ol><li>通过类的全限定名称找到对应的二进制流，比如说限定名java/lang/Object，但是java对二进制流的来源不做限制，比如说可以在本地的class文件读取，或者是从网络获取，亦或是其他方式</li><li>把二进制的静态结构转化为方法区(内存)的运行时的数据结构</li><li>在内存中创建一个java.lang.Class对象instanceKlass，作为方法区对这个类的各种访问的入口。此Class对象是放在方法区中的。</li></ol><p>具体的加载由具体的类加载器完成，我们可以自己自定义类加载器完成我们想要加载的具体class内容。具体就是重载<strong>ClassLoader#loadClass</strong>方法。</p><p>对于数组而言，会有所不同，数组类本身并不是通过类加载器加载的，是由java虚拟机直接创建的。数组类的一般创建流程如下</p><ol><li>如果数组的组件类型(组件类型是指数组去掉一个维度的类型，比如说int[][]的组件类型就是int[])是引用类型，即是普通的对象，则通过上述方法去加载对应的class，否则继续上述步骤，只到加载对应的class为止</li><li>如果不是引用类型，比如说int，long，float之类的基本数据类型，虚拟机会把数组则使用Bootstrap ClassLoader加载</li><li>对于一个数组的类型的可见性，如果是引用类型则与引用类型一致，不是的话就是public</li></ol><p>加载完成后，需要在内存上实例化一个java.lang.Class对象，作为管理此外部对象访问方法区中的这些类型的外部接口，对于Hotspot虚拟机而言，是放到方法区的</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>连接阶段分为验证，准备，解析三个过程。</p><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>我们不难想到一个问题，通过javac编译出来的class文件理论上不会有什么问题，但是我们不能排除class文件就一定没有问题，比如我们可以通过直接修改字节码文件达到攻击的目的。因此我们需要一个验证过程来保证class是正确无害的。验证过程不是必须但是却是很重要的一步，验证过程分为以下几步</p><p><strong>格式验证</strong></p><ul><li>是否已0xCAFEBABE开头</li><li>Major version &amp; minjor version是否受当前虚拟机支持</li><li>检查常量池tag，判断是否有不被支持的类型</li><li>指向常量池的索引是否有指向不存在的</li><li>…</li></ul><p>验证完成后，字节流便会被放到方法区存储，我们得到的就是一系列的数据结构。验证的最主要过程是保持输入的字符流能被正确的解析，要符合一个class的格式要求</p><p><strong>元数据验证</strong></p><ul><li>验证父类是否正确(只有Object无父类)</li><li>类继承关系是否正确(是否集成了final类)</li><li>非抽象类是否实现了父类所有抽象方法</li><li>…</li></ul><p>验证阶段的主要目的是对元数据的校检，保证符合java的语法规范</p><p><strong>字节码验证</strong></p><p>通过对数据流和控制流分析，确定程序语义合法，符合逻辑，主要针对方法</p><p><strong>符号引用验证</strong></p><p>保证所有的非自身的符号引用都是OK的，一般发生在解析阶段</p><ul><li>是否能通过常量池中的全限定名称找到具体的类</li><li>在指定类中是否能找到符合方法字段描述符的方法与字段</li><li>符号应用中的类，方法，字段的可见性</li><li>…</li></ul><h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p>准备阶段是正式为类变量（static修饰的变量）分配内存以及设置初始值的阶段，此内存在方法去分配，类变量与实例变量不同，实例变量是在对象创建的时候初始化，这里的设置初始值，是指把对应的值设置成默认的值，比如是int默认是0，bool默认false，比如说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> VARIABLE = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//在准备阶段不会设置成123，而是设置成0，设置成123实在&lt;clinit&gt;方法中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VARIABLE = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//一般会有ConstanValue，则会根据ConstanValue设定初置</span></span><br></pre></td></tr></table></figure><h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>解析阶段是把符号引用换成对应的直接引用的过程。</p><blockquote><p>符号引用与直接引用区别，符号引用是一组用符号来描述引用的目标，直接引用则是指向引用目标的指针，或者内存相对偏移量等，直接引用说明目标是直接可用的，即已经被加载到内存中，符号引用则不然</p></blockquote><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>准备阶段已经对类变量进行了设置系统默认零值，初始化阶段则是把我们想要的默认值设置给对应的类变量或者初始化其他资源。简而言之，即调用类构造器的&lt;clinit&gt;方法。</p><ul><li>&lt;clinit&gt;方法是由编译器通过收集类变量的赋值和静态语句块的合并产生的，其中，静态语句块即由static{} 包裹的内容，静态语句块只能访问到定义在其之前的变量，之后的定义的变量只能赋值，不能访问</li><li>&lt;clinit&gt;方法不需要主动调用父类的&lt;clinit&gt;父类的方法，虚拟机会保证父类的&lt;clinit&gt;在其之前调用，所以Object的&lt;clinit&gt;是第一个被调用的&lt;clinit&gt;方法</li><li>&lt;clinit&gt;对于类或者接口来说不是必须的，如果一个类没有静态代码块和对类变量的赋值操作，此方法可以省略</li><li>对于接口而言，没有静态代码块，但是有静态变量，默认在调用接口的&lt;clinit&gt;方法前不会调用欺父类的。同样，接口的实现类在调用&lt;clinit&gt;也不会调用接口的&lt;clinit&gt;方法</li><li>虚拟机会保证&lt;clinit&gt;方法在多线程环境下是正常被调用，如果一个线程正在执行&lt;clinit&gt;，其他线程想要初始化这个类都会被阻塞</li><li>对于同一个类加载来说，&lt;clinit&gt;只会被调用一次</li></ul><h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><p>类加载器主要功能就是加载类，但不仅仅只是加载类，每一个类加载器都有其独一的命名空间，对于同一个类，如果使用的命名空间不一致，即使用的类加载器不一致，即对于同一个类而言，不同的类加载器加载，得到的对象是不想等的，不仅仅是对象的equal方法，包括 instanceof，isAssignableFrom等都是不同的。类加载器在收到加载类的请求时，不会立马去加载，而是请求其父加载器去加载，这就是类加载器的双亲委派机制。</p><h6 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h6><p>Java中的类加载器主要分为两种，一种是以C++写成的叫做bootstrap classloader，另外一种是以java作为编程语言，分为extension classloader，Applications classloader，以及自定义的classloader</p><ul><li>bootstrap classloader，启动类加载器，主要负责加载java自带的一些jar包，比如说dt.jar等</li><li>extension classloader，拓展类加载器，一般是加载jdk中ext目录下的jar包</li><li>application classloader，应用程序加载器，如果应用程序中最没有定义过自己的类加载器，我们自己的class一般是通过此进行加载</li></ul><p>这些类加载器模型的基本关系如下，当我们使用自定义的类加载器加载类时，它不会直接去加载，而是请求其父加载器aplication classloader加载，application classloader收到请求后也会直接加载，会交给其父加载器extension classloader，如此直到bootstrap classloder，如果bootstrap classloader无法加载请求的类，则交给子类加载器 extension classloader，如果其无法加载，继续子类加载器，一致如此，直到无法加载就抛出ClassNotFoundException异常</p><div align="center">  <img src="/images/placeholder.png" alt="classloader" style="zoom: 67%;" data-src="./从java对象创建说起/classloader.jpeg" class="lazyload"></div> <p>双亲委派机制自然也有它的问题，我们自己类加载器可以直接加载对应的类，或者如果在系统类中加载了自定义的类就无法实现了，经典的例子就是Java中的SPI</p><h4 id="堆上创建"><a href="#堆上创建" class="headerlink" title="堆上创建"></a>堆上创建</h4><p>类加载完成就可以创建具体对象啦，一个对象所占用的内存大小类加载完成后就已经确定，分配内存就等同于在堆上划分一块相同的大小的内存区域。划分的方法有两种方式，指针碰撞和空闲列表</p><ul><li>指针碰撞方式是指内存是规整的，一边是占用，一边是空闲，这样直接在空闲区域开辟对应大小的内存即可</li><li>空闲列表方式是内存不是规整的，虚拟机需要维护一张未被使用的列表，每一次分配的时候需要找到一块足够大的内存区域进行分配，并且需要空闲列表</li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），关于垃圾回收的内容见后续文章。</p><p>另外一点需要注意的是，对象创建是一个很频繁的行为，因此不得不考虑的一个问题是线程安全，比如说当我正在分配内存的时候，对象指针可能还未指向对象就已经被重新分配了。解决方案也很简单，对一种采用同步处理，另一种是通过本地线程分配缓冲TLAB，不同的线程创建对象使用不同的内存空间，自然当TLAB已经使用完，无法再分配的时候，则使用同步方式处理</p><p>对象创建完成后，需要把非对象头外的分配到的内存空间设置零值，即基本数据结构值0，false等，对象设置成null</p><p>然后就是设置初始化对象头与调用对象的&lt;init&gt;方法</p><h5 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h5><p>在HotSpot虚拟机中，对象在内存中分为三块区域，对象头，实例数据，对齐填充</p><h6 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h6><p>对象头存储着对象自身运行时数据和类型指针</p><ul><li><p>运行时数据，包括HashCode，GC分代年龄，锁状态，线程锁等，这部分的数据在32位系统上是32bit，在64位在未开启指针压缩是64bit，这部分数据，官方称之为<strong>MarkWord</strong>， 根据锁状态，具体组成如下，关于锁在说明线程安全的时候会有涉及</p><div align="center">  <img src="/images/placeholder.png" alt="markword" style="zoom: 67%;" data-src="./从java对象创建说起/markword.jpeg" class="lazyload"></div> </li><li><p>类型指针，虚拟机通过这个指针判断当前对象是哪个类instanceKlass的实现</p></li></ul><p>两外，如果是数组的话，对象头中还必须有一块记录数组的大小</p><h6 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h6><p>实例数据是对象真正存储的有效信息，即类中定义的各种字段的内容，无论是从父类继承，还是自带的，另外变量的储存的顺序是按照longs/doubles,ints, shorts/chars, bytes/booleans,oops排列的，在此基础上，父类的变量在前。</p><h6 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h6><p>对齐填充不是必须存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><p> 下面来分析一下，执行new A()的时候，JVM 做了什么工作。首先，如果这个类没有被加载过，JVM就会进行类的加载，并在JVM内部创建一个instanceKlass对象表示这个类的运行时元数据（相当于Java层的Class对象）。初始化对象的时候（执行invokespecial A），JVM就会创建一个instanceOopDesc对象表示这个对象的实例，然后进行Mark Word的填充，将元数据指针指向Klass对象，并填充实例变量。元数据(instanceKlass) 对象会存在元空间（方法区），而对象实例—— instanceOopDesc 会存在Java堆。Java虚拟机栈中会存有这个对象实例的引用。</p><div align="center">  <img src="/images/placeholder.png" alt="object" style="zoom: 67%;" data-src="./从java对象创建说起/object.png" class="lazyload"></div> <h5 id="调用-lt-init-gt-方法"><a href="#调用-lt-init-gt-方法" class="headerlink" title="调用&lt;init&gt;方法"></a>调用&lt;init&gt;方法</h5><p>Java对象在被创建时，会进行实例化操作。该部分操作封装在&lt;init&gt;方法中，并且子类的&lt;init&gt;方法中会首先对父类&lt;init&gt;方法的调用。Java对象实例化过程中对变量的的初始化赋值操作全部在&lt;init&gt;方法中进行，&lt;init&gt;方法显式的调用父类的&lt;init&gt;方法，实例域的声明以及实例初始化语句块同样的位置关系会影响编译器生成的&lt;init&gt;方法的字节码顺序，&lt;init&gt;方法以构造方法作为结束。</p><h4 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h4><p>如下分析，对象的reference是放在虚拟机栈中的，那么如何通过这个指针访问对应的对象呢？目前主流的方式有两种：</p><ul><li><p>句柄访问，使用句柄访问的话，需要在内存中维护一个句柄池，存放具体的对象</p><div align="center">  <img src="/images/placeholder.png" alt="handle" style="zoom: 67%;" data-src="./从java对象创建说起/handle.png" class="lazyload"></div>  </li><li><p>直接指针访问，如果使用直接指针访问，那么Java堆中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象的地址。</p><div align="center">  <img src="/images/placeholder.png" alt="pointer" style="zoom: 67%;" data-src="./从java对象创建说起/pointer.png" class="lazyload"></div>  </li></ul><p>两种方式各有优势，对于句柄访问的话如果我需要移动对象地址，只需要改句柄内容，不需要更改栈帧中的reference，使用直接指针的方式就是快，hotspot是采用此方式。</p><h3 id="常量池相关补充"><a href="#常量池相关补充" class="headerlink" title="常量池相关补充"></a>常量池相关补充</h3><p>额外的补充一些与常量池相关的知识点。</p><ol><li>String相关内容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象</p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern方String.intern() 是一个native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 =<span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s3 == s2);</span><br><span class="line"><span class="comment">//true，因为两个都是常量池中的String对</span></span><br></pre></td></tr></table></figure><p>String拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 =<span class="string">"str"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 =<span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str3 =<span class="string">"str"</span>+<span class="string">"ing"</span>; <span class="comment">//直接字符串拼接，常量池中的对象</span></span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2; <span class="comment">//对象拼接会在堆上创建的新的对象 </span></span><br><span class="line"><span class="built_in">String</span> str5 =<span class="string">"string"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5); <span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>基本数据类型常量池</li></ol><ul><li>Java 基本类型的包装类的大部分都实现了常量池技术，即Byte, Short, Integer, Long, Character, Boolean这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象，对应包装类的valueOf方法在[-128，127]间同样是从常量池中取得。</li><li>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// 输出true</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">33</span>);</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = Interger.valueOf(<span class="number">33</span>);</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// 输出true</span></span><br><span class="line"></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22); <span class="comment">// 输出false</span></span><br><span class="line"></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试想一下，如果我们在代码中直接通过关键字new创建了一个对象，JVM会做那些工作从而保证我们后续的使用不出问题呢？java中内存究竟是怎么分配的呢？为什么java new的对象不需要手动释放？带着这些疑问我们一起来研究一下java中对象创建的相关知识。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://jianglei12138.github.io/categories/JVM/"/>
    
    
      <category term="内存分配" scheme="https://jianglei12138.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="对象创建" scheme="https://jianglei12138.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析</title>
    <link href="https://jianglei12138.github.io/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jianglei12138.github.io/2019/02/20/Glide源码分析/</id>
    <published>2019-02-20T15:47:52.000Z</published>
    <updated>2019-03-10T14:14:12.853Z</updated>
    
    <content type="html"><![CDATA[<p>Android图片加载框架的发展，经历了从最初的ImageLoder到Piasso，Glide，Fresco三足鼎立的过程，其中无论是Picasso还是Glide，他们的共同点都是用起来特别方便，通过链式调用，几乎可以一行代码解决大部分的需求。本文基于Glide最新的版本4.8，对Glide源码做一些简要的分析。<br> <a id="more"></a></p><p>Android图片加载框架的发展，经历了从最初的ImageLoder到Piasso，Glide，Fresco三足鼎立的过程。以下是关于这三个常用框架的一些数据上的对比。</p><table><thead><tr><th align="center"></th><th align="left">Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td align="center">开发者</td><td align="left">square</td><td>bumptech</td><td>facebook</td></tr><tr><td align="center">Star/Issue</td><td align="left">16K+/1400+</td><td>24K+/3100+</td><td>15K+/1900+</td></tr><tr><td align="center">最新版本</td><td align="left">2.71828</td><td>4.8.0</td><td>1.11.0</td></tr></tbody></table><p>从上述表中我们可以看到，Glide相对其他两个有更多的star与issue，本文就简单分析一下Glide的源码。Glide是由<a href="https://github.com/bumptech" target="_blank" rel="noopener">bumptech</a>开发的图片加载框架，也是Google推荐使用的图片加载框架。</p><h2 id="Glide的使用"><a href="#Glide的使用" class="headerlink" title="Glide的使用"></a>Glide的使用</h2><p>除去常用的png，jpg外，Glide还支持 Gif、WebP，甚至是 Video等，当然这些都是建立在一些第三方库的基础上实现的，比如说gifencoder等。</p><p>无论是上文说到的Picasso还是Glide，他们的共同点都是用起来特别方便，通过Glide的链式调用，几乎可以一行代码解决大部分的需求。本文基于Glide最新的版本4.8，相较于Glide 3，Glide 4在一些代码易读性，易写性，可扩展性等方面都有了不错的提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = <span class="keyword">new</span> RequestOptions()</span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE);</span><br><span class="line">        .placeholder(R.drawable.loading);</span><br><span class="line">Glide.with(<span class="keyword">this</span>).load(url).apply(options).into(imageView);</span><br></pre></td></tr></table></figure><h2 id="Glide架构"><a href="#Glide架构" class="headerlink" title="Glide架构"></a>Glide架构</h2><p><img src="/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/framework.png" alt="framework"><br>如图是我在网上找到的一张关于glide架构图。可以看到Glide相对还是比较复杂的，此次我们只分析其中的部分实现，即Registry与RequestManager，了解一下Glide加载一张图片的大致流程。</p><h2 id="Glide源码分析"><a href="#Glide源码分析" class="headerlink" title="Glide源码分析"></a>Glide源码分析</h2><p>了解过Glide使用后，我们便可以着手分析Glide源码了，后面我们一边结合设计模式，一遍分析Glide的实现。</p><h3 id="1-Glide的初始化"><a href="#1-Glide的初始化" class="headerlink" title="1. Glide的初始化"></a>1. Glide的初始化</h3><p>从Glide源码入手，我们逐层分析Glide是如何创建的，首先从with接口入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever().get(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于with的调用可以简化如上，可以看到通过 <strong>Glide#get</strong>方法获取到Glide实例，那么这个get方法究竟做了些什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Glide glide;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isInitializing;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInitializing) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isInitializing = <span class="keyword">true</span>;</span><br><span class="line">   initializeGlide(context);</span><br><span class="line">    isInitializing = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见创建采用了单例模式，单例模式是我们最长见、最常用的设计模式之一，是一种对象创建型模式。</p><blockquote><p><strong>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</strong></p></blockquote><p>关于单例的实现有很多种优秀的解决方案，所谓青菜萝卜各有所爱，Glide使用了双重检查锁的方案，并且为了防止可能出现的重复创建，使用了布尔变量标识是否初始化完成。此处需要注意的一点是，我们开发过程中常用的单利可能不会传递一个参数Context，如果需要，需要特殊注意对Context的使用，避免不必要的内存泄漏。</p><p>按照惯例，创建Glide实例最终应该由 <strong>initializeGlide</strong> 完成，具体实现如下, 其中关于GlideModule的实现，目前我们只需要知道是用来修改Glide的加载策略以及设置缓存等即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GlideBuilder顾名思义，创建Glide</span></span><br><span class="line">    initializeGlide(context, <span class="keyword">new</span> GlideBuilder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">    Context applicationContext = context.getApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Glide 4支持通过注解AppGlideModule, 由于GlideModule即将废弃，不做介绍</span></span><br><span class="line">    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">        annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">        ? annotationGeneratedModule.getRequestManagerFactory() : <span class="keyword">null</span>;</span><br><span class="line">    builder.setRequestManagerFactory(factory);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">        annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处真正创建glide对象</span></span><br><span class="line">    Glide glide = builder.build(applicationContext);</span><br><span class="line">    <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">        <span class="keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">        annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">    &#125;</span><br><span class="line">    Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来可以看到 <strong>initializeGlide</strong> 只做了两件事情，初始化GeneratedAppGlideModule，并通过GlideBuilder 创建glide。终于我们看到Glide实例的创建，继续跟下去可以看到，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">build</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">      memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.Builder(context).build();</span><br><span class="line">      connectivityMonitorFactory = <span class="keyword">new</span> DefaultConnectivityMonitorFactory();</span><br><span class="line"></span><br><span class="line">      bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">      arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">      memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">      diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line"></span><br><span class="line">      engine =</span><br><span class="line">          <span class="keyword">new</span> Engine(</span><br><span class="line">              memoryCache,</span><br><span class="line">              diskCacheFactory,</span><br><span class="line">              GlideExecutor.newDiskCacheExecutor(),</span><br><span class="line">              GlideExecutor.newSourceExecutor(),</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">              GlideExecutor.newAnimationExecutor(),</span><br><span class="line">              isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultRequestListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaultRequestListeners = Collections.emptyList();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestManagerRetriever requestManagerRetriever =</span><br><span class="line">        <span class="keyword">new</span> RequestManagerRetriever(requestManagerFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptions.lock(),</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        isLoggingRequestOriginsEnabled);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Glide#build</strong>创建了Glide的引擎，bitmp池，内存缓存，磁盘缓冲，加载资源和读取资源的线程池，缓存方式等，关于RequestManagerRetriever的介绍，参见第二节。最终调用Glide的构造函数创建Glide对象。</p><h3 id="2-Registry机制"><a href="#2-Registry机制" class="headerlink" title="2. Registry机制"></a>2. Registry机制</h3><p>Glide构造函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Glide(</span><br><span class="line">    <span class="meta">@NonNull</span> Context context,</span><br><span class="line">    <span class="meta">@NonNull</span> Engine engine,</span><br><span class="line">    <span class="meta">@NonNull</span> MemoryCache memoryCache,</span><br><span class="line">    <span class="meta">@NonNull</span> BitmapPool bitmapPool,</span><br><span class="line">    <span class="meta">@NonNull</span> ArrayPool arrayPool,</span><br><span class="line">    <span class="meta">@NonNull</span> RequestManagerRetriever requestManagerRetriever ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    registry = <span class="keyword">new</span> Registry();</span><br><span class="line">    registry</span><br><span class="line">        .append(ByteBuffer.class, <span class="keyword">new</span> ByteBufferEncoder())</span><br><span class="line">        .append(InputStream.class, <span class="keyword">new</span> StreamEncoder(arrayPool))</span><br><span class="line">        <span class="comment">/* Bitmaps */</span></span><br><span class="line">        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)</span><br><span class="line">        <span class="comment">/* BitmapDrawables */</span></span><br><span class="line">        .append(</span><br><span class="line">        Registry.BUCKET_BITMAP_DRAWABLE,</span><br><span class="line">        ByteBuffer.class,</span><br><span class="line">        BitmapDrawable.class,</span><br><span class="line">        <span class="keyword">new</span> BitmapDrawableDecoder&lt;&gt;(resources, byteBufferBitmapDecoder))</span><br><span class="line">        <span class="comment">/* GIFs */</span></span><br><span class="line">        .append(</span><br><span class="line">        Registry.BUCKET_GIF,</span><br><span class="line">        InputStream.class,</span><br><span class="line">        GifDrawable.class,</span><br><span class="line">        <span class="keyword">new</span> StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool))</span><br><span class="line">        <span class="comment">/* GIF Frames */</span></span><br><span class="line">        .append(</span><br><span class="line">        GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance())</span><br><span class="line">        .append(</span><br><span class="line">        Registry.BUCKET_BITMAP,</span><br><span class="line">        GifDecoder.class,</span><br><span class="line">        Bitmap.class,</span><br><span class="line">        <span class="keyword">new</span> GifFrameResourceDecoder(bitmapPool))</span><br><span class="line">        <span class="comment">/* Drawables */</span></span><br><span class="line">        .append(Uri.class, Drawable.class, resourceDrawableDecoder)</span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(</span><br><span class="line">        Bitmap.class,</span><br><span class="line">        BitmapDrawable.class,</span><br><span class="line">        <span class="keyword">new</span> BitmapDrawableTranscoder(resources));</span><br><span class="line">    ...</span><br><span class="line">    glideContext =</span><br><span class="line">        <span class="keyword">new</span> GlideContext(</span><br><span class="line">        context,</span><br><span class="line">        arrayPool,</span><br><span class="line">        registry,</span><br><span class="line">        <span class="keyword">new</span> ImageViewTargetFactory(),</span><br><span class="line">        defaultRequestOptions,</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        engine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Glide构造函数中注册了大量的Transcoder, Encoder与Decoder（负责一些资源如jpg, svg, video, gif等加载，持久化等），所有的这些操作由一个个独立的模块实现，这些模块由Registry负责管理。Registry是Glide内部实现的模块挂接中心，它建立了功能需求和实现模块之间的映射关系，使这些模块能够根据需求进行灵活的挂载，模块和模块之间又相互独立互不影响，很好地实现了系统功能的解耦。  在Registry内部提供了对如下几种类型模块的挂载支持</p><ul><li>数据加载模块 ModelLoaderRegistry</li><li>存储模块，提供通用的数据持久化功能 EncoderRegistry</li><li>资源解码模块，把各种类型的数据decode成bitmap或者drawable资源 ResourceDecoderRegistry</li><li>资源存储模块，相比EncoderRegistry此只是资源bitmap，drawable等持久化模块 ResourceEncoderRegistry</li><li>数据流重定向模块  DataRewinderRegistry</li><li>数据转换模块，将不同类似的资源转换，如bitmap -&gt; drawable</li><li>图片header解析模块 ImageHeaderParserRegistry</li></ul><p>关于模块间的关系和Glide支持的部分模块可以参考如下UML图，关于ModelLoaderRegistry模块，可以看到支持Okhttp作为网络请求或者你可以自定义任意的网络请求工具，只要实现ModelLoaderFactory接口即可，甚至，对于所有的模块，如果不能够满足你的需求，完全可以自定义属于自己的模块。</p><p><img src="/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/registry.jpg" alt="registry"></p><p>这里，其实就有那么一点点策略模式的味道了。结合UML类图可以看到，对于任意的模块，其具体实现类就是具体的策略，将接口的定义与具体模块实现策略分开，符合“依赖倒转原则”。在有新的比如说endcoder时，只需要增加一个新的实现了Encoder具体策略类即可。</p><blockquote><p><strong>策略模式：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。策略模式是一种对象行为型模式。</strong></p></blockquote><p>至此，Glide初始化完毕。</p><h3 id="3-RequestManager的创建"><a href="#3-RequestManager的创建" class="headerlink" title="3. RequestManager的创建"></a>3. RequestManager的创建</h3><p>Glide的所有一切以with开始，into结束，with支持context, activity, view, fragment参数等，Glide正是使用此，来完成基本的初始化与调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever().get(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getRequestManagerRetriever得到的对象其实就是在初始化Glide的时候构造函数传入的，由GlideBuilder创建的RequestManagerRetriever，RequestManagerRetriever提供了一系列静态方法用来创建RequestManager或者直接从Actiivty或者fragment取得已经创建的RequestManager，关于如何获取，见get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你有去翻<strong>RequestManagerRetriever#get</strong>实现，你会发现get方法有很多重载函数，但无一例外，所有的get函数最开始都有关于当前线程的检测，为什么要去检测是否则主线程？后面会有简单的注释。另外我们需要了解一个事实是：</p><blockquote><p>Glide实现中图片的加载任务会与activity或者Fragment的生命周期绑定，当界面执行onStop的使用自动暂停，而当执行onStart的时候又会自动重新开启，同样的，动态Gif图的加载也是如此，以用来节省电量，同时Glide会对网络状态做监听，当网络状态发生改变时，会重启失败的任务，以减少任务因网络连接问题而失败的概率。</p></blockquote><p>既然如此新的问题就产生了，Glide是如何把Activity/Fragment的生命周期与自己绑定的呢？我们继续看刚才的代码寻找答案，get函数如果检测到是主线程，最终会调用如下的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            DEFAULT_FACTORY.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull <span class="keyword">final</span> android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">        current.setParentFragmentHint(parentHint);</span><br><span class="line">        <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">            current.getGlideLifecycle().onStart();</span><br><span class="line">        &#125;</span><br><span class="line">        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerFactory DEFAULT_FACTORY = <span class="keyword">new</span> RequestManagerFactory() &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">build</span><span class="params">(@NonNull Glide glide, @NonNull Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestManager(glide, lifecycle, requestManagerTreeNode, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>RequestManagerRetriever#fragmentGet</strong>会先去查找TAG为FRAGMENT_TAG的 fragment，如果没有找到，会自己创建一个SupportRequestManagerFragment，这个SupportRequestManagerFragment是什么东西？翻下代码你就会发现这竟然是个Fragment！不难大胆猜测，Glide与Lifecycle组件一样，塞了一个空白的Fragment来监听生命周期的回调！</p><p>紧接着，就是RequestManager的创建，通过DEFAULT_FACTORY对象的build函数实现，下面看RequestManager的构造函数的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">    <span class="keyword">this</span>.glide = glide;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">    <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're the application level request manager, we may be created on a background thread.</span></span><br><span class="line">    <span class="comment">// In that case we cannot risk synchronously pausing or resuming requests, so we hack around the</span></span><br><span class="line">    <span class="comment">// issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.</span></span><br><span class="line">    <span class="comment">// This should be entirely safe.</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        mainHandler.post(addSelfToLifecycle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    glide.registerRequestManager(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个lifecycle是什么？是通过SupportRequestManagerFragment中getGlideLifecycle取得，具体来说是ActivityFragmentLifecycle对象，ActivityFragmentLifecycle维护了一份注册的生命周期回调Set，当空白fragment生命周期发生改变，会去调用ActivityFragmentLifecycle相应的接口，再去遍历相应我们注册的回调Set，比如说RequestManager！至此，豁然开朗，一切和我们预料的相同。优秀！</p><p>另外我们也可以看到注释中关于为什么使用主线程的判断原因，如果我们直接在Application中调用创建了RequestManager可能会有同步的风险，导致生命周期混乱！👏👏👏</p><h3 id="4-RequestBuilder创建"><a href="#4-RequestBuilder创建" class="headerlink" title="4. RequestBuilder创建"></a>4. RequestBuilder创建</h3><p>RequestManager对象创建完成，既可以研究一下load的实现啦，同样load接口也有大量的重载，那从我们我们常用的  load(Drawable) 入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(drawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load操作先通过as接口把需要加载的对象封装成了RequestBuilder，最终把load的任务交给了RequestBuilder实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(drawable)</span><br><span class="line">        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关于磁盘缓冲的处理也是一个典型的策略模式的实现。load最终实现也只是给成员变量赋值，RequestBuilder的所有提供给应用使用的接口，大部分实现也都是设置成员变量等，无真正逻辑的处理。但是其中的链式调用不仅让我们想起设计模式中的建造者模式，创建者模式是备受开发者创建复杂对象时青睐的一种设计模式。而其中链式调用一般也是我们常用的实现创建者模式的一种手段。</p><blockquote><p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式</strong></p></blockquote><p>这样，我们就创建好了一个RequestBuilder对象.</p><h3 id="5-Request构建"><a href="#5-Request构建" class="headerlink" title="5. Request构建"></a>5. Request构建</h3><p>万事具备，只差如何把资源得到并显示了，这里就不得不说RequestBuilder中的into方法，如下是into的部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        <span class="comment">// 简化了部分代码，对于在创建RequestBuilder传入的Drawable.class，此处会创建DrawableImageViewTarget</span></span><br><span class="line">        <span class="keyword">new</span> DrawableImageViewTarget(view),</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">  @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">  RequestOptions options)</span> </span>&#123;    </span><br><span class="line">    Request request = buildRequest(target, targetListener, options);</span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">...</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终的部分需要创建 buildRequest，那么这个buildRequest究竟做了什么？通过阅读源码我们发现buildRequest只是简单的调用buildRequestRecursive函数，那就具体分析buildRequestRecursive</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span></span><br><span class="line">    ErrorRequestCoordinator errorRequestCoordinator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (errorBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        errorRequestCoordinator = <span class="keyword">new</span> ErrorRequestCoordinator(parentCoordinator);</span><br><span class="line">        parentCoordinator = errorRequestCoordinator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩略图或者原图Request</span></span><br><span class="line">    Request mainRequest =</span><br><span class="line">        buildThumbnailRequestRecursive(</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        parentCoordinator,</span><br><span class="line">        transitionOptions,</span><br><span class="line">        priority,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight,</span><br><span class="line">        requestOptions,</span><br><span class="line">        callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errorRequestCoordinator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mainRequest;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    Request errorRequest =</span><br><span class="line">        errorBuilder.buildRequestRecursive(</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        errorRequestCoordinator,</span><br><span class="line">        errorBuilder.transitionOptions,</span><br><span class="line">        errorBuilder.getPriority(),</span><br><span class="line">        errorOverrideWidth,</span><br><span class="line">        errorOverrideHeight,</span><br><span class="line">        errorBuilder,</span><br><span class="line">        callbackExecutor);</span><br><span class="line">    errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class="line">    <span class="keyword">return</span> errorRequestCoordinator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果检测到如果除了目标图片外，我们还自己配置了显示的错误图片，或缩略图显示，那么这时候会创建一个请求协调器，来协调各类型图片间的请求顺序。</p><ul><li>在构建协调器后，会将目标图片请求和错误图片请求设置给协调器。</li><li>一旦请求开始工作，就会启动目标图片请求。</li><li>当目标图片请求失败时，就会启动错误图片请求。</li></ul><p>buildThumbnailRequestRecursive中除了创建缩略图外，还有可能会去加载原图。此处为了简化分析，我们只看加载原题的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingleRequest.obtain(</span><br><span class="line">        context,</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        requestOptions,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight,</span><br><span class="line">        priority,</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        requestListeners,</span><br><span class="line">        requestCoordinator,</span><br><span class="line">        glideContext.getEngine(),</span><br><span class="line">        transitionOptions.getTransitionFactory(),</span><br><span class="line">        callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原图的加载完全交给了SingleRequest实现。我们回到刚才into方法中，可以看到在做了必要的准备后，我们最终回到<strong>RequestManager#track</strong>方法，将此次请求放到RequestManager的请求队列中，同时检测当前生命周期是否已经暂停，否则直接发起加载请求，对此，是发起了一次SingleRequest请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track</span><span class="params">(Target&lt;?&gt; target, Request request)</span> </span>&#123;</span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RequestTracker#runRequest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-资源加载"><a href="#6-资源加载" class="headerlink" title="6. 资源加载"></a>6. 资源加载</h3><p>由以上分析我们得知，最终加载图片是交代给SingleRequest来实现的，具体源码如下，除了设置当前的状态外，最重要的莫过于onSizeReady接口了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">        onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        requestOptions.getSignature(),</span><br><span class="line">        <span class="keyword">this</span>.width,</span><br><span class="line">        <span class="keyword">this</span>.height,</span><br><span class="line">        requestOptions.getResourceClass(),</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        requestOptions.getDiskCacheStrategy(),</span><br><span class="line">        requestOptions.getTransformations(),</span><br><span class="line">        requestOptions.isTransformationRequired(),</span><br><span class="line">        requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">        requestOptions.getOptions(),</span><br><span class="line">        requestOptions.isMemoryCacheable(),</span><br><span class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">        requestOptions.getUseAnimationPool(),</span><br><span class="line">        requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        callbackExecutor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onSizeReady则通过Glide的引擎，真正的去加载资源。关于Glide的引擎，我们并没有做过多的介绍，其负责任务创建，发起，回调，资源的管理等，此处简单分析load的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1:创建资源索引key</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">                                        resourceClass, transcodeClass, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2:从内存中当前正在显示的资源缓存加载图片</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3:从内存缓存资源中加载图片</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4:获取已经存在的加载任务</span></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current.addCallback(cb);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5:新建加载任务，用于启动解码任务</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">        key,</span><br><span class="line">        isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool,</span><br><span class="line">        useAnimationPool,</span><br><span class="line">        onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6:新建解码任务，真正执行数据加载和解码的类</span></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        key,</span><br><span class="line">        signature,</span><br><span class="line">        width,</span><br><span class="line">        height,</span><br><span class="line">        resourceClass,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        diskCacheStrategy,</span><br><span class="line">        transformations,</span><br><span class="line">        isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform,</span><br><span class="line">        onlyRetrieveFromCache,</span><br><span class="line">        options,</span><br><span class="line">        engineJob);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7:缓存加载任务</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8:开启解码任务</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们真正开启了资源的加载过程，引擎中的load会根据当前内存是否存在此资源进行相应的加载，否则再去请求本地磁盘或者网络等，此请求任务则交给Registry中已经注册的ModelLoader来完成，见第二节Registry。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android图片加载框架的发展，经历了从最初的ImageLoder到Piasso，Glide，Fresco三足鼎立的过程，其中无论是Picasso还是Glide，他们的共同点都是用起来特别方便，通过链式调用，几乎可以一行代码解决大部分的需求。本文基于Glide最新的版本4.8，对Glide源码做一些简要的分析。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://jianglei12138.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Glide" scheme="https://jianglei12138.github.io/tags/Glide/"/>
    
      <category term="图像加载" scheme="https://jianglei12138.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android渲染机制</title>
    <link href="https://jianglei12138.github.io/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <id>https://jianglei12138.github.io/2018/10/01/Android渲染机制/</id>
    <published>2018-10-01T14:33:02.000Z</published>
    <updated>2019-04-26T16:56:21.006Z</updated>
    
    <content type="html"><![CDATA[<p>关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。</p> <a id="more"></a><h1 id="Android渲染机制"><a href="#Android渲染机制" class="headerlink" title="Android渲染机制"></a>Android渲染机制</h1><p>关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。</p><h2 id="从Activity-setContentView说起"><a href="#从Activity-setContentView说起" class="headerlink" title="从Activity#setContentView说起"></a>从Activity#setContentView说起</h2><p>一般创建应用时，Activity是承载我们视图的首要选择。为了能够正常显示视图，我们一般会通过调用 <code>Activity#setContentView</code> 方法来进行加载。但是，这个方法究竟调用了什么方法实现真正展现视图的？又是如何现实的呢？从源码最终我们能看到，<code>setContentView</code> 最终的实现位于  <strong>PhoneWindow</strong> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mContentParent是PhoneWindow内容的根布局，首先检测mContentParent</span></span><br><span class="line">    <span class="comment">// 创建或者不空移除子View，防止重复的调用setContentView</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scene是Kitkat引入的场景API, 可以通过Transition来实现带有动画的场景切换</span></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// inflater对应的view attach到mContentParent中</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所使用的View最终都会被添加到mContentParent中，mContentParent究竟是一个什么样的ViewGroup呢？首先看一下mContentParent的创建与初始化，其初始化代码位于installDecor中，由于代码量比较多，此处只摘取部分重要内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 创建Decor</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处可以简化为 new DecorView()</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由Decor创建mContentParent</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDecorContentParent = decorContentParent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处callback是指后面的Activity传入的callback，详情见后面分析</span></span><br><span class="line">            mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">            <span class="keyword">if</span> (mDecorContentParent.getTitle() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> localFeatures = getLocalFeatures();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((localFeatures &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mTitleView = findViewById(R.id.title);</span><br><span class="line">            <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                    <span class="keyword">if</span> (titleContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        titleContainer.setVisibility(View.GONE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mTitleView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mContentParent.setForeground(<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTitleView.setText(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDecor.getBackground() == <span class="keyword">null</span> &amp;&amp; mBackgroundFallbackResource != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面述代码，我们能够了解以下几个事实</p><ul><li>创建mDecor，mDecor的创建过程比较简单，通过直接实例化DecorView</li><li>通过generateLayout创建mContentParent</li><li>创建mContentParent后会去找到DecorContentParent/TitleView，然后对UI进行修改</li></ul><p>那么generateLayout究竟是怎么实现的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略解析设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inflate the window decor.</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">// System.out.println("Features: 0x" + Integer.toHexString(features));</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        <span class="comment">// System.out.println("Title Icons!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with only a progress bar (and title).</span></span><br><span class="line">        <span class="comment">// XXX Need to have a no-title version of embedded windows.</span></span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">        <span class="comment">// System.out.println("Progress!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with a custom title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogCustomTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no other features and not embedded, only need a title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("Title!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println("Simple!");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处把上述的layout inflater之后添加到mDecorView中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mContentParent即mDecor的子View ID为ID_ANDROID_CONTENT(com.android.internal.R.id.content)</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ProgressBar progress = getCircularProgressBar(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (progress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            progress.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侧滑退出Activity实现</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        registerSwipeCallbacks(contentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generateLayout方法就是根据mLocalFeatures寻找到对应的layout。这些layout位置位于frameworks/base/core/res/res/layout/目录下。这些所有的layout都有一个id为 <strong>com.android.internal.R.id.content</strong> 的FrameLayout，而这个FrameLayout就是放置我们自定义布局ContentView的mContentParent，也就是我们Acitivity所传递过来的View最终都都会被添加到这个FrameLayout中</p><p><img src="/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/content_layout.png" alt="content_layout"></p><p><strong>本节知识点</strong></p><ol><li>Scene结合Transiation实现场景动画切换 <a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">Android Transition Framework</a></li><li>最简单实现侧滑退出Activity requestWindowFeature使用 <strong>PhoneWindow#requestFeature</strong></li></ol><h2 id="DecorView是什么？"><a href="#DecorView是什么？" class="headerlink" title="DecorView是什么？"></a>DecorView是什么？</h2><p>经过上面的分析，我们知道DecorView是PhoneWindow的独有ViewGroup，也是承载我们Acitiviy视图的RootView，DecorView是FrameLayout子类。到目前为止我们能可以看到一个普通Activity大致的布局如下。</p><p><img src="/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/decor_view.png" alt="Activity层级"></p><p>其中：</p><ol><li>DecorView是Activity的RootView，其他所有View都是其直接或者间接子View</li><li>decor_content_parent即上述分析的DecorContentParent，包括常用的ActionBar/Toolbar和我们自己添加的View</li><li>navigationBarBackground与statusBarBackground两个View只是为了占用空间，预留给状态栏和导航栏使用，具体的实现位于 <strong>PhoneStatusBarView</strong></li></ol><p><strong>本节知识点</strong></p><ol><li>Android里阴影实现的一种方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initShadowPaints</span><span class="params">(Paint shadowPaint, <span class="keyword">int</span> shadowSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startColor  = <span class="number">0x2a000000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> endColor    = <span class="number">0x00000000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> middleColor = (startColor + endColor) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    shadowPaint.setShader(</span><br><span class="line">            <span class="keyword">new</span> LinearGradient(</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, shadowSize,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;startColor, middleColor, endColor&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0f</span>, <span class="number">0.3f</span>, <span class="number">1f</span>&#125;, Shader.TileMode.CLAMP</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View是什么时候显示的？"><a href="#View是什么时候显示的？" class="headerlink" title="View是什么时候显示的？"></a>View是什么时候显示的？</h2><p>DecorView是我们Activity的根布局，那么他又是怎么显示出来的呢？如果看过ActivityThread源码的话，就会知道在 <strong>ActivityThread#performLaunchActivity</strong> 中创建Activity之后，便会调用 <strong>Activity#attach</strong> 方法。<br>完成此方法调用后，ActivityThread会调用 <strong>Activity#performCreate</strong> 进而调用 <strong>Activity#onCreate</strong> 之后就是我们上述分析的setContentView流程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, Window window,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处callback的接口定义见下方列举的内容</span></span><br><span class="line">    <span class="comment">// 除了一些关于触摸相关的Activity有对应的实现外</span></span><br><span class="line">    <span class="comment">// 其他Activity中都是空实现</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Thread</span></span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// ActivityThread 此处并不是一个Thread</span></span><br><span class="line">    <span class="comment">// 主线程并不是一个线程</span></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处会调用PhoneWindow父类中的setWindowManager方法</span></span><br><span class="line">    <span class="comment">// 最终获得一个WindowManagerImpl实例</span></span><br><span class="line">    <span class="comment">// 此实例中保存了一个PhoneWindow的属性</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mParent也是Activity，具体使用见知识点</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此mWindowManager如上包含一个PhoneWindow的引用</span></span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window.Callback部分接口列举</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyShortcutEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTrackballEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchGenericMotionEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowAttributesChanged</span><span class="params">(WindowManager.LayoutParams attrs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContentChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，我们建立了 <strong>Activity</strong> <strong>PhoneWindow</strong> <strong>WindowManager</strong> 的三者之间的联系，简单的用下图表示。总结来说</p><ol><li>Activity中持有WindowManager与Window的引用，Window通过直接new PhoneWindow得到，WindowManager通过Window提供的接口取得</li><li>PhoneWindow中有一系列的成员变量，一般是各种回调，是通过Activity直接设置过来的，都是Activity相同实例。然后Activity通过Window的方法实现初始化Window中的成员变量WindowManager</li><li>WindowManager通过上述方法，在创建Window成员变量WindowManager的同时，把Window设置给WindowManager实现双向关联</li></ol><p><img src="/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/activity_window_windowmanager.jpg" alt="Activity-Window-WindowManager"></p><p>在说剩下的之前，我们要先了解一个既定的事实，View只有被add到WindowManager中才能正常的显示到屏幕上，那么View究竟是怎么被添加到WindowManager中的呢？onCreate之后只是把View添加到DecorView的一个子View中，并没有显示的操作。通过阅读Activity源码中的注释我们知道，在onStart之后，View才被真正的显示出来。</p><blockquote><p>Activity#onStart Called when the activity is becoming visible to the user.</p></blockquote><p>大胆猜想，DecorView是在onStart后，onResume前被添加到WindowManager。继续跟ActivityThread中的源码，<strong>ActivityThread#handleResumeActivity -&gt; ActivityThread#performResumeActivity -&gt; Activity#performResume -&gt; Activity#onResume</strong> 看下来你会发现根本没有DecorView的操作，甚至连Window都没有。也就是说在onResume之前，View都是不可见的？其实注释中也是说Activity可见，并没有说明View可见。功夫不负有心人，最终我们在ActivityThread中找到了这部分的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终调用onResume</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 隐藏DecorView</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        <span class="comment">// Activity的TYPE为TYPE_BASE_APPLICATION</span></span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 把DecorView添加到WindowManager中，此时View并不可见，前面有隐藏</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="comment">// 使View可见</span></span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity#makeVisible</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完View的显示时机，我们禁想到一个问题，那就是Activity中的一些明显View的生命周期中的回调，如上述Callback中一些接口的实现，是不是在DecorView中回调的呢。带着这样的疑问，我们先看下Callback到底被设置到了哪里</p><ol><li>Activity在创建PhoneWindow后，通过调用 <strong>Window#setCallback</strong> 方法传递给PhoneWindow， 并且Window提供了 <strong>Window#getCallback</strong> 方法</li><li>setContentView后在PhoneWindow中创建mContentParent后，调用 <strong>DecorContentParent#setWindowCallback</strong></li><li>DecorContentParent是一个接口，具体实现在ActionBarView</li></ol><p>找到所有相关联的类，就能很简单的找到对应的调用，ActionBarView与PhoneWindow，通过callback控制Menu相关的情况。其他的方法，正如我们所料，都是在DecorView被回调，即Activity中所有的有关触摸，按键，onAttachedToWindow与onDetachedFromWindow等都是在DecorView中调用的。</p><p><strong>本节知识点</strong></p><ol><li>Activity中的parent属性，<a href="https://blog.csdn.net/simplebam/article/details/79381754" target="_blank" rel="noopener">android:parentActivityName使用</a></li><li>UML图的使用</li><li>ActivityThread的大致套路</li><li>View真正显示时机</li><li>Activity中CallBack接口的回调时机</li></ol><h2 id="View是如何显示出来的？"><a href="#View是如何显示出来的？" class="headerlink" title="View是如何显示出来的？"></a>View是如何显示出来的？</h2><p>以上分析我们基于这样一个事实，那就是 <strong>“View只要被添加到WindowManager中，才能被正常显示”</strong>，那这个只要add后就能显示的神奇操作是怎么实现的呢？从以上分析我们得知，DecorView通过addView添加到WindowManager中，那么这个WindowManager是如何创建的呢，在attach中通过 <strong>context.getSystemService(Context.WINDOW_SERVICE)</strong> 创建了WindowManager，并设置到PhoneWindow中。一如往常使用getSystemService获得对应的实例。但是不同的是调用getSystemService时使用的context是从ActivityThread直接传递过来的。最终由ActivityThread#createBaseContextForActivity创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContextImpl <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> displayId;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            <span class="keyword">this</span>, r.packageInfo, r.activityInfo, </span><br><span class="line">            r.token, displayId, r.overrideConfig);</span><br><span class="line">    <span class="keyword">return</span> appContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现我们得到此getSystemService实现位于 <strong>ContextImpl#getSystemService</strong>，直接调用    <strong>SystemServiceRegistry.getSystemService</strong> 获取对应的Service。SystemServiceRegistry存放了一个SYSTEM_SERVICE_FETCHERS静态HashMap，存放所有的SystemService，我们能拿到的所有Service都是从此处创建获取。我们使用的WINDOW_SERVICE具体实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接new WindowManagerImpl</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx);</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>WindowManager创建时，会初始化一个成员变量WindowManagerGlobal，此类为单例类，之后的所有addView，updateViewLayout，removeView都是借助WindowManagerGlobal实现。一个进程中每次调用getSystemService都会创建一个WindowManager实例，但是所有的操作都是委托给同一个WindowManagerGlobal实现。具体添加一个View的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// 如果有父Window，再添加子View的时候需要适当的对父Window做适当的调整</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                            mRoots.get(i).loadSystemProperties();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 系统属性发生修改的回调</span></span><br><span class="line">            SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 之前removeView还未完成</span></span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前添加的View TYPE为SUB_WINDOW, 则需要确认父WINDOW</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ViewRootImpl，并把所有的操作委托给ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新View LayoutParam</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是addView，updateViewLayout还是removeView都是在WindowManagerGlobal封装好一层，交给ViewRootImpl去处理。</p><p><img src="/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/widowmanagerglobal.png" alt="WindowManagerGlobal窗口管理"></p><p><strong>本节知识点</strong></p><ol><li>使用WindowManagerGlobal可以拿到当前进程任何地方获取所有的View</li><li>系统属性修改回调 <strong>SystemProperties#addChangeCallback</strong></li></ol><h2 id="ViewRootImpl是什么？"><a href="#ViewRootImpl是什么？" class="headerlink" title="ViewRootImpl是什么？"></a>ViewRootImpl是什么？</h2><p>从上面我们了解到所有的视图操作都是交给ViewRootImpl去处理的，那么这个ViewRootImpl到底是什么呢？我们看下构造函数的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从WindowManagerGlobal中获取一个IWindowSession的实例</span></span><br><span class="line">    <span class="comment">// 它是ViewRootImpl和WindowManagerService进行通信的代理</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WindowLeaked实例，如果Window未正常释放，会抛出此异常</span></span><br><span class="line">    <span class="comment">// 异常在WindowManagerGlobal抛出，此处只负责创建</span></span><br><span class="line">    mLocation = <span class="keyword">new</span> WindowLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// W类是ViewRootImpl的内部类，继承于IWindow.Stub，会接收来自WMS的回调</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 每一个View都需要依赖于具体的窗口才能显示，View与窗口的关系则是放在View.AttachInfo中</span></span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>,</span><br><span class="line">            context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助功能回调</span></span><br><span class="line">    mAccessibilityManager = AccessibilityManager.getInstance(context);</span><br><span class="line">    mAccessibilityManager.addAccessibilityStateChangeListener(</span><br><span class="line">            mAccessibilityInteractionConnectionManager, mHandler);</span><br><span class="line">    mHighContrastTextManager = <span class="keyword">new</span> HighContrastTextManager();</span><br><span class="line">    mAccessibilityManager.addHighTextContrastStateChangeListener(</span><br><span class="line">            mHighContrastTextManager, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewConfiguration这个类主要定义了UI中所使用到的标准常量</span></span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是一个未经任何处理的事件处理场所</span></span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个mChoreographer，接收底层的Vsync信号重绘</span></span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line"></span><br><span class="line">    mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line"></span><br><span class="line">    loadSystemProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewRootImpl构造函数中创建了大量的重要对象外，在成员变量定义时也创建了几个相对比较重要的成员变量</p><ol><li>mHander，从名称上看此处应该是一个Handler，具体定义位于 ViewRootImpl.ViewRootHandler，用于将某些应在主线程的操作放到主线程中执行，一般这些操作来自于WMS</li><li>mSurface，一个空的Surface</li></ol><p><strong>本节知识点</strong></p><ol><li>ViewConfiguration中获取一些View相关</li></ol><p>在看ViewRootImpl的具体实现之前，需要有一些预备知识。</p><h3 id="Surface是什么？"><a href="#Surface是什么？" class="headerlink" title="Surface是什么？"></a>Surface是什么？</h3><p>Android官方文档中是这样描述Surface</p><blockquote><p>Handle onto a raw buffer that is being managed by the screen compositor.<br>A Surface is generally created by or from a consumer of image buffers (such as a SurfaceTexture, MediaRecorder, or Allocation), and is handed to some kind of producer (such as OpenGL, MediaPlayer, or CameraDevice) to draw into.</p></blockquote><p>这个描述可以知道：Surface是用来管理一个raw buffer类，Surface本身是由screen compositor来管理的。但是raw buffer具体是什么，screen compositor又是什么，Surface是如何管理一个raw buffer，而它又是怎样被compositor来管理，后续我们会具体来分析。Surface是我们绘制的基础。</p><p>从上面我们可以看到，ViewRootImpl在初始化的时候创建了一个Surface对象，通过调用其默认构造函数，默认构造函数中无任何的实现代码，目前我们那到的仍然是一个内容为空的对象。Surface主要代码不在java层，主要的实现位于Native。那么究竟是在哪里创建的呢？从后面的代码中，在我们可以在relayoutWindow函数中发现通过调用 <strong>IWindowSession#relayout</strong> 最终把Surface传递给WMS，即应用程序进程的Surface创建过程是由WMS服务来完成，WMS服务通过Binder跨进程方式将创建好Surface返回给应用程序进程，Binder相关内容在此不表。</p><p><strong>IWindowSession#relayout</strong> 的具体实现位于 <strong>Session#relayout</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        MergedConfiguration mergedConfiguration, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mService即WindowManagerService即WMS</span></span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看WMS中关于relayoutWindow中关于Surface的实现主要是调用   <strong>WindowManagerService#createSurfaceControl</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowSurfaceController surfaceController = </span><br><span class="line">        winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见Surface主要通过 <strong>WindowSurfaceController#getSurface</strong> 获得，WindowSurfaceController则通过 <strong>WindowStateAnimator#createSurfaceLocked</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">(<span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.setHasSurface(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>, windowType, ownerUid);</span><br><span class="line"></span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是对直接new做了封装，WindowSurfaceController的构造函数中初始化SurfaceControl，嗯哼，出现我们常见的一个类。常用截图接口 <strong>SurfaceControl#screenshot</strong>，后面就不得不看native代码了，SurfaceControl构造函数中主要调用nativeCreate方法。</p><p>nativeCreate实现位于 <strong>android_view_SurfaceControl.cpp#nativeCreate</strong> 中，具体如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint windowType, jint ownerUid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传递过来的sessionObj取得native层的SurfaceComposerClient</span></span><br><span class="line">    <span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">client</span><span class="params">(android_view_SurfaceSession_getClient(env, sessionObj)</span>)</span>;</span><br><span class="line">    SurfaceControl *parent = reinterpret_cast&lt;SurfaceControl*&gt;(parentObject);</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    status_t err = client-&gt;createSurfaceChecked(</span><br><span class="line">            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);</span><br><span class="line">    <span class="keyword">if</span> (err == NAME_NOT_FOUND) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        jniThrowException(env, OutOfResourcesException, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <strong>SurfaceComposerClient#createSurfaceChecked</strong> 创建了对应的SurafceControl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceComposerClient::createSurfaceChecked(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        sp&lt;SurfaceControl&gt;* outSurface,</span><br><span class="line">        uint32_t flags,</span><br><span class="line">        SurfaceControl* parent,</span><br><span class="line">        int32_t windowType,</span><br><span class="line">        int32_t ownerUid)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    status_t err = mStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != nullptr) &#123;</span><br><span class="line">            parentHandle = parent-&gt;getHandle();</span><br><span class="line">        &#125;</span><br><span class="line">        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,</span><br><span class="line">                windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="keyword">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mClient 即 ISurfaceComposerClient， 此处为跨进程调用，最终实现位于 <strong>SurfaceFlinger#Client.cpp</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">status_t Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    class MessageCreateLayer : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        status_t result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        uint32_t w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">status_t <span class="title">getResult</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function">virtual bool <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用SurfaceFlinger#createLayer</span></span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> static_cast&lt;MessageCreateLayer*&gt;(msg.get())-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终调用的方法是 <strong>SurfaceFlinger#createLayer</strong> 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceFlinger::createLayer(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        int32_t windowType, int32_t ownerUid, sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    String8 uniqueName = getUniqueLayerName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此flags由</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createBufferLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:</span><br><span class="line">            result = createColorLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags,</span><br><span class="line">                    handle, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// window type is WINDOW_TYPE_DONT_SCREENSHOT from SurfaceControl.java</span></span><br><span class="line">    <span class="comment">// TODO b/64227542</span></span><br><span class="line">    <span class="keyword">if</span> (windowType == <span class="number">441731</span>) &#123;</span><br><span class="line">        windowType = <span class="number">2024</span>; <span class="comment">// TYPE_NAVIGATION_BAR_PANEL</span></span><br><span class="line">        layer-&gt;setPrimaryDisplayOnly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    layer-&gt;setInfo(windowType, ownerUid);</span><br><span class="line"></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer, *parent);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;saveSurfaceCreation(layer);</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续不需要再深入，留待以后讲SurfaceFlinger后再深入了解。目前我们知道最终通过SurfaceFlinger创建Layer，并把Layer的代理对象, gdp就是图像缓冲区代理对象 返回给SurfaceComposerClient方便创建SurfaceControl。</p><p>到目前为止，我们得到了native的SurfaceControl，所有对象已经准备完毕，上文说道，最终  <strong>WindowSurfaceController#getSurface</strong> 获取Surface对象内容，大胆的猜测，此方法最终返回的其实是SurfaceFlinger创建的这块layer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WindowSurfaceController#getSurface</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Surface#copyFrom</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"other must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    <span class="keyword">if</span> (surfaceControlPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</span><br><span class="line">                <span class="string">"null SurfaceControl native object. Are you using a released SurfaceControl?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就是通过jni调用把使用SurfaceControl来填充Surface</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceControl#getSurface</span></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateSurfaceLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    <span class="comment">// mGraphicBufferProducer即上文提到的dgp，图像缓冲区代理对象</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/surface.png" alt="Surface的创建"></p><p>总结一下Surface的创建过程：</p><ol><li>每一个Window都有且只有一个ViewRootImpl对象，在该对象中会创建一个java层的内容为空的Surface；</li><li>当应用程序向WMS服务请求relayout Window，WMS服务在WMS进程创建一个SurfaceController</li><li>WMS服务在创建SurfaceController过程中，在自身进程空间创建一个java层的SurfaceControl对象，SurfaceControl创建时会调用jni创建native的SurfaceControl对象。具体实现 <strong>SurfaceComposerClient#createSurfaceChecked</strong> </li><li>SurfaceComposerClient通过Binder调用请求<strong>SurfaceFlinger#createLayer</strong>在它的进程空间为当前创建的Surface创建对应的Layer对象，并向WMS返回IGraphicBufferProducer代理对象。SurfaceComposerClient通过此代理对象创建native的SurfaceControl。</li><li>WMS服务在再通过 <strong>SurfaceController.getSurface</strong> 使用SurfaceControl填充我们需要的Surface</li></ol><p><strong>其他总结</strong></p><ol><li><strong>SurfaceControl#screenshot</strong> 使用</li><li>跨进程调用的实现，使用</li><li>JNI静态注册，动态注册，基本使用</li><li>SurfaceFlinger的基本功能</li></ol><h3 id="Choreographer是什么？"><a href="#Choreographer是什么？" class="headerlink" title="Choreographer是什么？"></a>Choreographer是什么？</h3><p>Android系统加入Choreographer这个类的目的来处理输入(Input)、动画(Animation)、绘制(Draw)三个操作。Choreographer接收显示系统底层传上来的垂直同步信号(VSync信号)，在下一个帧渲染时控制执行这些操作。</p><p> <strong>理想状态下的choreographer</strong><br><img src="/images/placeholder.png" alt="理想状态下的choreographer" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/choreographer.png" class="lazyload"></p><p> <strong>丢帧状态下的choreographer</strong><br><img src="/images/placeholder.png" alt="丢帧状态下的choreographer" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/choreographer_jank.png" class="lazyload"></p><p>Choreographer的基本原理如此，下面看下怎么实现的。Choreographer使用ThreadLocal保存Choreographer实例，保证每个Thread只存在一个Choreographer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Looper looper = Looper.myLooper();</span><br><span class="line">            <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Input callback.  Runs first.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Animation callback.  Runs before traversals.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Traversal callback.  Handles layout and draw.  </span></span><br><span class="line"><span class="comment">// Runs after all other asynchronous messages have been handled.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Commit callback.  Handles post-draw operations for the frame.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_COMMIT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">FrameInfo mFrameInfo = <span class="keyword">new</span> FrameInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个线程对应一个Looper，每个线程对应一个Choreographer</span></span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同type初始化不同CallbackQueue，共4中如上</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上功能有</p><ol><li>初始化FrameHandler，接收处理消息。使用Handler的原因是保证所有的操作都是在同一个线程实现的</li><li>初始化FrameDisplayEventReceiver，FrameDisplayEventReceiver用来接收垂直同步信号。FrameDisplayEventReceiver继承于DisplayEventReceiver。当垂直同步信号过来后会回调 <strong>DisplayEventReceiver#dispatchVsync</strong> 方法，最终调用到onVsync方法</li><li>初始化mLastFrameTimeNanos(上一个frame的渲染时间)以及mFrameIntervalNanos(帧率,fps，一般手机上为1s/60)。</li><li>初始化了大小为4的CallbackQueue</li><li>初始化mFrameInfo用来保存当前帧的信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called when a vertical sync pulse is received.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否丢帧</span></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                + <span class="string">"one at a time."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules a single vertical sync pulse to be delivered when the next</span></span><br><span class="line"><span class="comment">// display frame begins.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Choreographer对外提供了postCallback与postFrameCallback，最终这两个方法调用的都是同一个方法 <strong>Choreographer#postCallbackDelayedInternal</strong> ，postFrameCallback的TYPE为CALLBACK_ANIMATION</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delayMillis为0， 直接调用scheduleFrameLocked等待下一次Vsync到来</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中postCallback的具体流程如下。</p><p><img src="/images/placeholder.png" alt="choreographer机制" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/choreographer_process.png" class="lazyload"></p><p>doFrame中做了些什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从不同的Queue中取出对应的Runnable执行，会取空队列</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本节知识点</strong></p><ol><li>获取设备刷新率，私有方法 <strong>Choreographer##getRefreshRate</strong>，一般不可靠，直接写死</li><li>可以在任何地方使用 <strong>Choreographer#postFrameCallback</strong>，与 <strong>View#post</strong> 或者 <strong>Handler#post</strong> 区别是不会立马执行，要等下一个垂直信号过来才会执行</li></ol><h3 id="ViewRootImpl-setView实现"><a href="#ViewRootImpl-setView实现" class="headerlink" title="ViewRootImpl#setView实现"></a>ViewRootImpl#setView实现</h3><p>了解以上两个基础知识后，剩下的就是看ViewRootImpl是怎么实现View的绘制显示的。 <strong>ViewRootImpl#setView</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">            mFallbackEventHandler.setView(view);</span><br><span class="line"></span><br><span class="line">            mWindowAttributes.copyFrom(attrs);</span><br><span class="line">            <span class="keyword">if</span> (mWindowAttributes.packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowAttributes.packageName = mBasePackageName;</span><br><span class="line">            &#125;</span><br><span class="line">            attrs = mWindowAttributes;</span><br><span class="line">            mClientWindowLayoutFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// RootViewSurfaceTaker即DecorView</span></span><br><span class="line">            <span class="comment">// Activity可以像SurfaceView一样，接管Surface，直接操作Surface</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                mSurfaceHolderCallback =</span><br><span class="line">                        ((RootViewSurfaceTaker)view).willYouTakeTheSurface();</span><br><span class="line">                <span class="keyword">if</span> (mSurfaceHolderCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mSurfaceHolder = <span class="keyword">new</span> TakenSurfaceHolder();</span><br><span class="line">                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);</span><br><span class="line">                    mSurfaceHolder.addCallback(mSurfaceHolderCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compute surface insets required to draw at specified Z value.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Use real shadow insets for a constant max Z.</span></span><br><span class="line">            <span class="keyword">if</span> (!attrs.hasManualSurfaceInsets) &#123;</span><br><span class="line">                attrs.setSurfaceInsets(view, <span class="keyword">false</span> <span class="comment">/*manual*/</span>, <span class="keyword">true</span> <span class="comment">/*preservePrevious*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 硬件加速，此处会创建ThreadedRenderer，见后文硬件加速的详细介绍</span></span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">// 第一次requestLayout</span></span><br><span class="line">            requestLayout();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果Window支持触摸，需要添加InputChannel通过WMS传递事件</span></span><br><span class="line">            <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把当前Window添加到WMS，此时Surface还未准备好不能绘制</span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPendingOverscanInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            mPendingContentInsets.set(mAttachInfo.mContentInsets);</span><br><span class="line">            mPendingStableInsets.set(mAttachInfo.mStableInsets);</span><br><span class="line">            mPendingVisibleInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to add window -- unknown error code "</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Activity接管触摸操作</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                mInputQueueCallback =</span><br><span class="line">                    ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建WindowInputEventReceiver接收触摸事件</span></span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把当前View的parent设置为当前ViewRootImpl</span></span><br><span class="line">            <span class="comment">// Parent需要实现ViewParent</span></span><br><span class="line">            view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ViewRootImpl#setView</strong> 中调用比较重要的接口requestLayout，requestLayout操作主要调用 <strong>ViewRootImpl#scheduleTraversals</strong>，具体实现如下.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler的SyncBarrier，见总结</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在Choreographer中post一个CALLBACK_TRAVERSAL，下一次垂直同步的时候执行 TraversalRunnable#doTraversal，进而performTraversals</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            <span class="comment">// 在Choreographer中post一个CALLBACK_INPUT，下一次垂直同步的时候执行 TraversalRunnable#doConsumeBatchedInput</span></span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知ThreadedRenderer即将有新的frame到来</span></span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleTraversals主要完成了向Choreographer中post CALLBACK_TRAVERSAL与CALLBACK_INPUT两种类型的callback，等待重绘和触摸事件的到来，关于触摸的实现我们暂时不管，主要看绘制的实现。</p><p><strong>本节知识点</strong></p><ol><li>在MessageQueue中添加一个特殊的SyncBarrier作为一个标记，在这个标记被移除之前，当前MessageQueue队列中排在它后面的其它非异步的message不会被handler处理</li></ol><h3 id="ViewRootImpl-performTraversals流程"><a href="#ViewRootImpl-performTraversals流程" class="headerlink" title="ViewRootImpl#performTraversals流程"></a>ViewRootImpl#performTraversals流程</h3><p>由于performTraversals代码量相对较大，只是我目前见过一个函数行数最多的，大概800行左右，看起来可能不是那么直观。一般自定义的View时候，一般 onMeasure onLayout onDraw三个方法，performTraversals大致也是这几个流程。</p><h4 id="测量阶段"><a href="#测量阶段" class="headerlink" title="测量阶段"></a>测量阶段</h4><p>doTraversal的第一阶段，会对整个控件树进行第一次测量，在此阶段会控件树所显示所需要的尺寸，在这个阶段，控件树中的所有View都会被调用到 <strong>View#onMeasure</strong> 方法，一般是从父布局中调用子View的onMeasure方法，父布局通过onMeasure的参数来把传达的参数给到子View， <strong>View#onMeasure</strong> 的具体定义如下，MeasureSpec虽然是一个整形，但却是一个复合型的变量, 其中前两位是测量模式，剩下的30位是width或者height。MeasureSpec只是子View作为设定自身大小参考，只是个参考，要多大，还是View自己说了算，但是View一旦超过父布局大小，界面可能显示不了。测量模式包括三种，UNSPECIFIED、EXACTLY、AT_MOST。</p><ol><li>UNSPECIFIED：父控件对子控件不加任何束缚，子元素可以得到任意想要的大小，这种MeasureSpec一般是由父控件自身的特性决定的。比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示，这个时候，size一般就没什么意义。</li><li>EXACTLY：父控件为子View指定确切大小，希望子View完全按照自己给定尺寸来处理，这时的MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数（MATCH_PARENT）来确定的。</li><li>AT_MOST：父控件为子元素指定最大参考尺寸，希望子View的尺寸不要超过这个尺寸，这种模式也是父控件根据自身的MeasureSpec跟子View的布局参数（WRAP_CONTENT）来确定的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存放根View宽高</span></span><br><span class="line"><span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line"><span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">...    </span><br><span class="line"></span><br><span class="line"><span class="comment">// WMS给定的最新Window Size</span></span><br><span class="line">Rect frame = mWinFrame;</span><br><span class="line"><span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">    mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">        <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></span><br><span class="line">        Point size = <span class="keyword">new</span> Point();</span><br><span class="line">        mDisplay.getRealSize(size);</span><br><span class="line">        desiredWindowWidth = size.x;</span><br><span class="line">        desiredWindowHeight = size.y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">        desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用控件树 onAttachedToWindow</span></span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    desiredWindowWidth = frame.width();</span><br><span class="line">    desiredWindowHeight = frame.height();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WMS 单方面修好了mWidth、mHeight强制重绘</span></span><br><span class="line">    <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当setView过mLayoutRequested才为true</span></span><br><span class="line"><span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类似悬浮窗</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></span><br><span class="line">                Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Configuration config = res.getConfiguration();</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终测量</span></span><br><span class="line">    windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终多有的操作都是交给measureHierarchy进行控件树的测量。多次协商后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 对于MATCH_PARENT或者直接写死不需要</span></span><br><span class="line">    <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// 首先使用最期望的宽度限制进行测量，常量</span></span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</span><br><span class="line">        res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> baseSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">            baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">            childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">            <span class="comment">// 第一次测量</span></span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测测量结果</span></span><br><span class="line">            <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</span><br><span class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">                <span class="comment">// 第二次测量</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!goodMeasure) &#123;</span><br><span class="line">        <span class="comment">// 第三次测量</span></span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> windowSizeMayChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见最终是调用了performMeasure方法来进行测量， 最终调用的地方 <strong>View#measure(childWidthMeasureSpec, childHeightMeasureSpec)</strong> measure也是对onMeasure的封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传递getSuggestedMinimumWidth()的意义在于当mode为UNSPECIFIED时需要获取size</span></span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么使用mininum？</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，应用层的测量几乎完成，剩下的是与WMS做相关的沟通，主要以relayoutWindow为核心，其主要是通过mWindowSession调用relayout方法使用，注意relayout中回把mSurface传给WMS,其中有些硬件加速相关的代码，暂时不表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame,</span><br><span class="line">            mPendingMergedConfiguration, mSurface);</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本节知识点</strong></p><ol><li>三种测量模式</li></ol><h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p>布局阶段主要完成控件树的布局和一些透明度区域的收集，以及与WMS协商。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">        || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line"><span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By this point all views have been sized and positioned</span></span><br><span class="line">    <span class="comment">// We can compute the transparent area</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// start out transparent</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> AVOID THAT CALL BY CACHING THE RESULT?</span></span><br><span class="line">        host.getLocationInWindow(mTmpLocation);</span><br><span class="line">        mTransparentRegion.set(mTmpLocation[<span class="number">0</span>], mTmpLocation[<span class="number">1</span>],</span><br><span class="line">                mTmpLocation[<span class="number">0</span>] + host.mRight - host.mLeft,</span><br><span class="line">                mTmpLocation[<span class="number">1</span>] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">        host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">            mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// reconfigure window manager</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局最重要调用performLayout，其最重要的实现是 <strong>View#layout</strong>，layout中通过setFrame设置View的LTRB，setFrame中检测到size发生改变或者第一次调用会调用onSizeChange方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure><p>布局的另一阶段是计算窗口的透明区域，方便后续底层SurafceFlinger做合成，类似在Surface上挖了一个洞。可以直接透过这个窗口看下后面的内容，常见于视频播放器。这一机制常用于SurfaceView。</p><h4 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h4><p>测量与布局完成后，既可以绘制了。 绘制的判断不多，主要调用performDraw方法。performDraw方法主要是调用draw方法。draw方法中关于动画的处理我们暂时不处理，主要看具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Android提供了两种绘图的方法。软件绘制与硬件绘制。由于内容相对较多，后面拆成两个小节来处理。</p><h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><p>软件绘制，是由CPU主导绘图，所有的操作由CPU来完成。适用于一些二维的绘图，底层调用的是Skia库。下面看下ViewRootImpl是如何进行软件绘制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到绘制Canvas，此处可能会修改dirty的值</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先清空成透明</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最终绘制方法</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放Canvas</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以看到直接通过 <strong>Surface#lockCanvas</strong> 取得Canvas，然后偶就可以通过此Canvas进行绘制，那么这个lockCanvas究竟做了些什么？看代码其实只是调用的 <strong>android_view_Surface#nativeLockCanvas</strong> 方法。此方法实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Surface</span></span><br><span class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算脏区</span></span><br><span class="line">    <span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">    Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ANativeWindow_Buffer结构体保存 w h stride format bits</span></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                         convertPixelFormat(outBuffer.format),</span><br><span class="line">                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888</span><br><span class="line">                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,</span><br><span class="line">                                         GraphicsJNI::defaultColorSpace());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Bitmap</span></span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    <span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    bitmap.setInfo(info, bpr);</span><br><span class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmap.setPixels(outBuffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">        bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Canvas</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip rect</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">                dirtyRect.right, dirtyRect.bottom, SkClipOp::kIntersect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改脏区</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <strong>Surface#lock</strong> 获取ANativeWindow_Buffer，里面存放Surface的具体宽，高，stride以及内存等信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindow_Buffer</span> &#123;</span></span><br><span class="line">    <span class="comment">/// The number of pixels that are shown horizontally.</span></span><br><span class="line">    <span class="keyword">int32_t</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The number of pixels that are shown vertically.</span></span><br><span class="line">    <span class="keyword">int32_t</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The number of *pixels* that a line in the buffer takes in</span></span><br><span class="line">    <span class="comment">/// memory. This may be &gt;= width.</span></span><br><span class="line">    <span class="keyword">int32_t</span> stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The format of the buffer. One of AHARDWAREBUFFER_FORMAT_*</span></span><br><span class="line">    <span class="keyword">int32_t</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The actual bits.</span></span><br><span class="line">    <span class="keyword">void</span>* bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Do not touch.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">6</span>];</span><br><span class="line">&#125; ANativeWindow_Buffer;</span><br></pre></td></tr></table></figure><p>之后通过所有的绘制操作，都是在这块Surface上进行绘制。关于Skia的绘制实现不表。后面即听过 <strong>View.draw(canvas)</strong> 把对应的View显示内容绘制到Surface上。后面我们详细分析这个方法。最后通过 <strong>Surface.unlockCanvasAndPost(canvas)</strong> 释放Canvas</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 硬件操作暂时不管</span></span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 软件实现</span></span><br><span class="line">            unlockSwCanvasAndPost(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        nativeRelease(mLockedObject);</span><br><span class="line">        mLockedObject = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和lockCanvas一样最终调用也是native中的nativeUnlockCanvasAndPost方法，实现位于 android_view_Surface.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detach the canvas from the surface</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlock surface</span></span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就来分析具体的绘制流程 <strong>View#draw</strong> 方法。draw方法的注释其实已经写明了绘制的过程</p><blockquote><p>Draw traversal performs several drawing steps which must be executed in the appropriate order:</p><ol><li>Draw the background</li><li>If necessary, save the canvas’ layers to prepare for fading</li><li>Draw view’s content</li><li>Draw children</li><li>If necessary, draw the fading edges and restore layers</li><li>Draw decorations (scrollbars for instance)</li></ol></blockquote><h4 id="绘制背景"><a href="#绘制背景" class="headerlink" title="绘制背景"></a>绘制背景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断是否是 “实心” 控件，所谓的实心控件是指后续的onDraw绘制内容能够完整的覆盖掉View的所有区域，此时为了提高绘制效率就不需要绘制背景，自定义View时可以通过重写isOpaque()方法实现。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line">    <span class="comment">// 如果不是</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用硬件加速绘制</span></span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RenderNode renderNode = mBackgroundRenderNode;</span><br><span class="line">        <span class="keyword">if</span> (renderNode != <span class="keyword">null</span> &amp;&amp; renderNode.isValid()) &#123;</span><br><span class="line">            setBackgroundRenderNodeProperties(renderNode);</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软件绘制， 这里有一点需要注意的地方就是两次平移操作</span></span><br><span class="line">    <span class="comment">// 在最开始调用draw方法之前其实ViewRootImpl是有对移动操作做单独的处理的</span></span><br><span class="line">    <span class="comment">// 此处把对应的操作给回滚了，是为了保证背景不会随着滚动而滚动</span></span><br><span class="line">    <span class="comment">// 当然绘制结束后需要恢复translate</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在说下面的准备绘制渐变框之前，需要单独的提一下不表示所有的控件都需要绘制这个所谓的渐变框的，因此第2步和第5部步是可以省略的。</p><h4 id="准备绘制渐变框"><a href="#准备绘制渐变框" class="headerlink" title="准备绘制渐变框"></a>准备绘制渐变框</h4><p>所谓的渐变，其实就是我们常见的诸如ListView等控件在拖动到顶部或者底部后弹出来的渐变效果，如下图。渐变框可以通过android:fadingEdge设置渐变的方向，android:fadingEdgeLength来设置渐变框的长度</p><p><img src="/images/placeholder.png" alt="渐变效果" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/fade.jpeg" class="lazyload"></p><p>此步骤只是设置了通过计算当前需要绘制的渐变框位置与区域，然后保存layer</p><h4 id="绘制内容"><a href="#绘制内容" class="headerlink" title="绘制内容"></a>绘制内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接调用onDraw方法绘制其内容，View中此方法为空实现，一般自定义View重写此方法</span></span><br><span class="line"><span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br></pre></td></tr></table></figure><h4 id="绘制子控件"><a href="#绘制子控件" class="headerlink" title="绘制子控件"></a>绘制子控件</h4><p>之后便是绘制子控件的流程，由于不是所有控件都有子空间，因此在View中此方法为空实现，ViewGroup中才有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip操作，有时候子控件大小可能超过当前ViewGroup，一般超出区域会直接忽略掉</span></span><br><span class="line">    <span class="comment">// 可以通过ViewGroup#setClipToPadding修改</span></span><br><span class="line">    <span class="keyword">int</span> clipSaveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> more = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">            ? <span class="keyword">null</span> : buildOrderedChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取View的绘制顺序，View的绘制顺序会影响重叠时候的显示效果。先绘制的View会被后续绘制的View覆盖</span></span><br><span class="line">        <span class="comment">// 可以通过getChildDrawingOrder来设置绘制顺序，默认实现是先加入则先绘制</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        canvas.restoreToCount(clipSaveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mGroupFlags might have been updated by drawChild()</span></span><br><span class="line">    flags = mGroupFlags;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>决定了绘制顺序后，ViewGroup便会通过 drawChild方法绘制子控件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意不是子控件draw(canvas)接口</span></span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处调用了子View的 <strong>View.draw(ViewGroup,Canvas,long)</strong>，大致经历以下操作</p><ol><li>进行动画的计算，将计算结果存储一个Transformation中</li><li>计算控件内容的滚动量</li><li>使用Canvas.save()保存Canvas的当前状态。此时Canvas的坐标系为父控件的坐标系。在随后将Canvas变换到此空间的坐标系并完成绘制后，会通过Canvas.restoreTo()将Canvas重置到此时的状态，以便Canvas可以继续用来绘制父控件的下一个子控件</li><li>第一次变换，对应控件位置与滚动</li><li>将动画产生的变换矩阵应用到Canvas中。主要是各种Animation，如SacleAnimation等</li><li>将控件自身的变换矩阵应用到Canvas中</li><li>设置剪裁。这个和dispatchDraw()中的裁剪工作不同：dispatchDraw()中的裁剪是为了保证所有的子控件绘制的内容不得越过父控件的边界。此处是指子控件的绘制内容不得超出子控件自身的边界，由setClipChildren()方法启用或禁用</li><li>使用变换过的Canvas进行最终绘制，调用dispatchDraw()或者draw(Canvas)两个方法</li><li>恢复Canvas的状态到一切开始之前，使得父控件的dispatchDraw()便可以将这个Canvas交给下一个子控件的draw(ViewGroup, Canvas, long)方法</li></ol><p><img src="/images/placeholder.png" alt="控件树绘制的完整流程" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/draw.png" class="lazyload"></p><h4 id="绘制渐变框"><a href="#绘制渐变框" class="headerlink" title="绘制渐变框"></a>绘制渐变框</h4><p>如第2步所示，不细讲</p><h4 id="绘制装饰"><a href="#绘制装饰" class="headerlink" title="绘制装饰"></a>绘制装饰</h4><p>此操作用来绘制一些滚动条，ViewOverlay等，ViewOverlay它是位于View视图层顶部的一个附加层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">    mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDrawForeground(canvas);</span><br></pre></td></tr></table></figure><p>简单的对软件绘制流程的总结<br><img src="/images/placeholder.png" alt="软件绘制" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/sw_process.png" class="lazyload"></p><p><strong>本节知识点</strong></p><ol><li><strong>View#isOpaque()</strong> 提高绘制效率</li><li>ViewOverlay的使用</li></ol><h3 id="硬件加速绘制"><a href="#硬件加速绘制" class="headerlink" title="硬件加速绘制"></a>硬件加速绘制</h3><p>倘若窗口使用硬件加速，则ViewRootImpl会创建一个ThreadedRenderer并保存在mAttachInfo中，见ViewRootImpl#setView中enableHardwareAcceleration。ThreadedRenderer是用于硬件加速的渲染器，它封装了硬件加速的图形库，并以Android与硬件加速图形库的中间层的身份存在。它负责从Android的Surface生成一个HardwareLayer，供硬件加速图形库作为绘制的输出目标，并提供一系列工厂方法用于创建硬件加速绘制过程中所需的DisplayList、DisplayListCanvas等工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">    mAttachInfo.mHardwareAccelerated = <span class="keyword">false</span>;</span><br><span class="line">    mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hardwareAccelerated =</span><br><span class="line">            (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hardwareAccelerated) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建ThreadedRenderer</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,</span><br><span class="line">                    attrs.getTitle().toString());</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setWideGamut(wideGamut);</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mHardwareAccelerated =</span><br><span class="line">                        mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadedRenderer <span class="title">create</span><span class="params">(Context context, <span class="keyword">boolean</span> translucent, String name)</span> </span>&#123;</span><br><span class="line">    ThreadedRenderer renderer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isAvailable()) &#123;</span><br><span class="line">        renderer = <span class="keyword">new</span> ThreadedRenderer(context, translucent, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ThreadedRenderer(Context context, <span class="keyword">boolean</span> translucent, String name) &#123;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br><span class="line">    mRootNode = RenderNode.adopt(rootNodePtr);</span><br><span class="line">    mRootNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// native 代理。后续详解</span></span><br><span class="line">    mNativeProxy = nCreateProxy(translucent, rootNodePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，在开启硬件加速状态下，<strong>ViewRootImpl#enableHardwareAcceleration</strong> 创建了ThreadedRenderer实例，ThreadedRenderer在构造函数中通过调用native方法nCreateRootRenderNode创建了一个RootRenderNode，native对应会创建一个RootRenderNode对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软件绘制流程我们知道大致经历了 lockCanvas -&gt; draw -&gt; unlockCanvasAndPost三个阶段。对比这三个阶段，我们看下硬件加速的实现方式。入口函数即 <strong>ThreadedRenderer#draw</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记开始绘制，mFrameInfo保存着当前帧的信息</span></span><br><span class="line">    <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">    choreographer.mFrameInfo.markDrawStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新DisplayList</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面会分析这个实现</span></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_LOST_SURFACE_REWARD_IF_FOUND) != <span class="number">0</span>) &#123;</span><br><span class="line">        setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        attachInfo.mViewRootImpl.mSurface.release();</span><br><span class="line">        <span class="comment">// Invalidate since we failed to draw. This should fetch a Surface</span></span><br><span class="line">        <span class="comment">// if it is still needed or do nothing if we are no longer drawing</span></span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Record View#draw()"</span>);</span><br><span class="line">    updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">            canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">            callbacks.onPreDraw(canvas);</span><br><span class="line"></span><br><span class="line">            canvas.insertReorderBarrier();</span><br><span class="line">            canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">            canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">            callbacks.onPostDraw(canvas);</span><br><span class="line">            canvas.restoreToCount(saveCount);</span><br><span class="line">            mRootNodeNeedsUpdate = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mRootNode.end(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DisplayListCanvas <span class="title">start</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DisplayListCanvas.obtain(<span class="keyword">this</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比软件绘制的实现，直接通过lockCanvas获取Canvas，硬件加速会直接调用， <strong>RenderNode#start</strong> 方法直接获取到DisplayListCanvas。而<strong>RenderNode#start</strong>方法则是通过 <strong>DisplayListCanvas#obtain</strong> 获取DisplayListCanvas</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> DisplayListCanvas <span class="title">obtain</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从对象池中取出所需对象，不存在创建，重载需要重置</span></span><br><span class="line">    DisplayListCanvas canvas = sPool.acquire();</span><br><span class="line">    <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas = <span class="keyword">new</span> DisplayListCanvas(node, width, height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,</span><br><span class="line">                width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.mNode = node;</span><br><span class="line">    canvas.mWidth = width;</span><br><span class="line">    canvas.mHeight = height;</span><br><span class="line">    <span class="keyword">return</span> canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayListCanvas 构造函数中会通过nCreateDisplayListCanvas在native层中创建一个对应Canvas对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(jlong renderNodePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* Canvas::create_recording_canvas(<span class="keyword">int</span> width, <span class="keyword">int</span> height, uirenderer::RenderNode* renderNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用OpenGL RecordingCanvas，构造函数中会初始化 DisplayList</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::RecordingCanvas(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Canvas，我们就有了绘图的工具。紧接我们就可以绘制控件及其子控件了，回到updateRootDisplayList方法，绘制子控件的实现 <strong>canvas.drawRenderNode(view.updateDisplayListIfDirty())</strong> 那么这个 <strong>View#updateDisplayListIfDirty</strong> 做了些什么操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RenderNode renderNode = mRenderNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">            || !renderNode.isValid()</span><br><span class="line">            || (mRecreateDisplayList)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> height = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> layerType = getLayerType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和ThreaderRender中使用相同，通过renderNode#start接口获取DisplayListCanvas</span></span><br><span class="line">        <span class="keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                computeScroll();</span><br><span class="line"></span><br><span class="line">                canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">                <span class="comment">// 最终回归到我们软件绘制中draw与dispatchDraw方法</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                    dispatchDraw(canvas);</span><br><span class="line">                    drawAutofilledHighlight(canvas);</span><br><span class="line">                    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                        mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">            setDisplayListProperties(renderNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchDraw方法和软件绘制相同，几乎没有额外的操作，具体也是在ViewGroup中才会有实现，主要目的是确认子控件的绘制顺序，最终调用也是 drawChild接口，进而 <strong>View#draw(Canvas canvas, ViewGroup parent, long drawingTime)</strong> 这个draw方法与软件绘制最大的不同在于， 会去调用(DisplayListCanvas) canvas).drawRenderNode(renderNode)，关于这个方法的解释，参见后面的详细解释。后续和软件绘制基本没有什么区别，不同的是传入的Canvas是DisplayListCanvas。</p><p>从以上操作我们能隐隐约约看出来点什么，这里创建的所有Canvas都是一种Recording Canvas，并且无任何真正的像软件绘制中Canvas.draw这种绘制操作，不难猜测，此处的Canvas应该只是录制了RenderNode的一些操作，具体的绘制不在此。具体是怎么实现录制的呢，回到updateRootDisplayList方法，刚才我们看到通过 Render的start与end接口，录制了根View的绘制操作，而具体的实现则是通过 <strong>DisplayListCanvas#drawRenderNode</strong> 实现，把View的RenderNode录制下来，drawRenderNode的实现特别简单，直接调用了native接口nDrawRenderNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_DisplayListCanvas_drawRenderNode</span><span class="params">(jlong canvasPtr, jlong renderNodePtr)</span> </span>&#123;</span><br><span class="line">    Canvas* canvas = reinterpret_cast&lt;Canvas*&gt;(canvasPtr);</span><br><span class="line">    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    canvas-&gt;drawRenderNode(renderNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RecordingCanvas::drawRenderNode(RenderNode* renderNode) &#123;</span><br><span class="line">    auto&amp;&amp; stagingProps = renderNode-&gt;stagingProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把添加renderNode封装成一个RenderNodeOp，添加到Canvas中</span></span><br><span class="line">    RenderNodeOp* op = alloc().create_trivial&lt;RenderNodeOp&gt;(</span><br><span class="line">            Rect(stagingProps.getWidth(), stagingProps.getHeight()),</span><br><span class="line">            *(mState.currentSnapshot()-&gt;transform), getRecordedClip(), renderNode);</span><br><span class="line">    <span class="keyword">int</span> opIndex = addOp(op);</span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(opIndex &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新mDisplayList</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = mDisplayList-&gt;addChild(op);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the chunk's child indices</span></span><br><span class="line">        DisplayList::Chunk&amp; chunk = mDisplayList-&gt;chunks.back();</span><br><span class="line">        chunk.endChildIndex = childIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (renderNode-&gt;stagingProperties().isProjectionReceiver()) &#123;</span><br><span class="line">            <span class="comment">// use staging property, since recording on UI thread</span></span><br><span class="line">            mDisplayList-&gt;projectionReceiveIndex = opIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文说过DisplayListCanvas其实不参与真正的绘制，只是记录绘制的操作Op。对应我们在onDraw方法中自己的一些操作，drawBitmap，drawColor之类，DisplayListCanvas也会封装成对应的Op</p><p><img src="/images/placeholder.png" alt="Op" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/op.png" class="lazyload"></p><p>这样我们就不难得出这样的结论，每一个View中都包含一个RenderNode，此Node对应Native中的RenderNode，而ViewRootImpl则对应RootRenderNode，每一个RenderNode包含DisplayList，DisplayList又有多个Op组成。</p><p><img src="/images/placeholder.png" alt="硬件加速绘制流程" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/hw_draw.jpg" class="lazyload"></p><p>按照软件绘制的套路，我们先后续的操作 <strong>mRootNode.end(canvas)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(DisplayListCanvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">    nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">    canvas.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_RenderNode_setDisplayList</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject clazz, jlong renderNodePtr, jlong displayListPtr)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    DisplayList* newData = <span class="keyword">reinterpret_cast</span>&lt;DisplayList*&gt;(displayListPtr);</span><br><span class="line">    renderNode-&gt;setStagingDisplayList(newData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderNode::setStagingDisplayList(DisplayList* displayList) &#123;</span><br><span class="line">    mValid = (displayList != <span class="literal">nullptr</span>);</span><br><span class="line">    mNeedsDisplayListSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">delete</span> mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = displayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结一下硬件加速绘制流程</p><ol><li>利用View的RenderNode获取一个DisplayListCanvas</li><li>利用DisplayListCanvas构建并缓存所有的DrawOp</li><li>将DisplayListCanvas缓存的DrawOp填充到RenderNode</li><li>将根View的缓存DrawOp设置到RootRenderNode中，完成构建</li></ol><p>以上我们了解具体的录制流程，但是最终是在何处绘制的呢？这时候我们就要回到ThreaderRenderer的构造函数中。还记得那个native代理嘛，看下其具体实现。具体的实现位于Native中，创建一个RenderProxy对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = reinterpret_cast&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode,</span><br><span class="line">                         IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance()), mContext(nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CanvasContext是一个继承IFrameCallback的类，IFrameCallback</span></span><br><span class="line">    mContext = mRenderThread.queue().runSync([&amp;]() -&gt; CanvasContext* &#123;</span><br><span class="line">        <span class="keyword">return</span> CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在updateRootDisplayList之后会调用 nSyncAndDrawFrame， 这个就是绘制的具体实现的部分了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(frameInfoSize != UI_THREAD_FRAME_INFO_SIZE,</span><br><span class="line">            <span class="string">"Mismatched size expectations, given %d expected %d"</span>,</span><br><span class="line">            frameInfoSize, UI_THREAD_FRAME_INFO_SIZE);</span><br><span class="line">    RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    env-&gt;GetLongArrayRegion(frameInfo, <span class="number">0</span>, frameInfoSize, proxy-&gt;frameInfo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体通过syncAndDrawFrame实现绘制</span></span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame() &#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DrawFrameTask::drawFrame() &#123;</span><br><span class="line">    mSyncResult = SyncResult::OK;</span><br><span class="line">    mSyncQueued = systemTime(CLOCK_MONOTONIC);</span><br><span class="line">    postAndWait();</span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    <span class="function">AutoMutex <span class="title">_lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把run方法放到mRenderThread线程中执行</span></span><br><span class="line">    mRenderThread-&gt;queue().post([<span class="keyword">this</span>]() &#123; run(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处会阻塞主线程</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    bool canUnblockUiThread;</span><br><span class="line">    bool canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可知，在主线程通知 <strong>DrawFrameTask#drawFrame</strong> 后，drawFrame调用postAndWait方法，等待mLock释放，此时主线程会被阻塞。为什么此处需要阻塞主线程？其实可以通过后面的在RenderThread执行的run方法来确认原因，后面会有关于是否需要立马释放主线程，还是等待绘制完在释放是需要通过syncFrameState返回值来判断的，原因是因为RenderThread与主线程同时持有了一些绘制帧信息。在绘制之前需要同步保证相同，具体的实现位于 prepareTree 中，具体实现此处不表。如果想要查看具体的绘制流程可以参考 <a href="https://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> vsync = mFrameInfo[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FrameInfoIndex::Vsync)];</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(vsync);</span><br><span class="line">    <span class="keyword">bool</span> canDraw = mContext-&gt;makeCurrent();</span><br><span class="line">    mContext-&gt;unpinImages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mLayers[i]-&gt;apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    mContext-&gt;setContentDrawBounds(mContentDrawBounds);</span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is after the prepareTree so that any pending operations</span></span><br><span class="line">    <span class="comment">// (RenderNode tree state, prefetched layers, etc...) will be flushed.</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mContext-&gt;hasSurface()) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::LostSurfaceRewardIfFound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a surface but can't draw we must be stopped</span></span><br><span class="line">            mSyncResult |= SyncResult::ContextIsStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!info.out.canDrawThisFrame) &#123;</span><br><span class="line">        mSyncResult |= SyncResult::FrameDropped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderThread被唤醒，开始渲染，大致流程如下：</p><ol><li>先进行DrawOp的合并</li><li>接着绘制特殊的Layer</li><li>绘制其余所有的DrawOpList</li><li>调用swapBuffers将前面已经绘制好的图形缓冲区提交给Surface Flinger合成和显示。</li></ol><p>对比软件绘制递归调用流程</p><p><img src="/images/placeholder.png" alt="对比" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/sw_hw_difference.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="https://jianglei12138.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Activity启动流程" scheme="https://jianglei12138.github.io/tags/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
      <category term="View的现实流程" scheme="https://jianglei12138.github.io/tags/View%E7%9A%84%E7%8E%B0%E5%AE%9E%E6%B5%81%E7%A8%8B/"/>
    
      <category term="硬件加速" scheme="https://jianglei12138.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    
      <category term="软件绘制" scheme="https://jianglei12138.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>从进程起源说起</title>
    <link href="https://jianglei12138.github.io/2018/06/26/%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%B5%B7%E6%BA%90%E8%AF%B4%E8%B5%B7/"/>
    <id>https://jianglei12138.github.io/2018/06/26/从进程起源说起/</id>
    <published>2018-06-26T14:33:02.000Z</published>
    <updated>2019-03-10T15:36:51.156Z</updated>
    
    <content type="html"><![CDATA[<p>一直想研究一下 Android 源码中关于图形渲染相关的内容，但是一直感觉无从入手，所以干脆直接从进程启动开始说起吧。后续会按照我看的内容尽量的写一些相关的博客。充实一下自己，打磨一下时光。废话少说，今天我们来分析一下 Android 应用进程的Zygote说起。</p> <a id="more"></a><h1 id="从进程起源分析—Zygote"><a href="#从进程起源分析—Zygote" class="headerlink" title="从进程起源分析—Zygote"></a>从进程起源分析—Zygote</h1><p>一直想研究一下 <code>Android</code> 源码中关于图形渲染相关的内容，但是一直感觉无从入手，所以干脆直接从进程启动开始说起吧。后续会按照我看的内容尽量的写一些相关的博客。充实一下自己，打磨一下时光。废话少说，今天我们来分析一下 <code>Android</code> 应用进程的<code>Zygote</code>说起。</p><h2 id="Zygote是什么？"><a href="#Zygote是什么？" class="headerlink" title="Zygote是什么？"></a>Zygote是什么？</h2><p>首先我们要知道我们要分析的这个东西到底是用来做什么的。我们知道在android的世界中存在两种不同的可执行程序，其一是native可执行程序，另一类则是我们常接触的java应用程序。其中native程序由标准init程序fork出来，zygote也不例外，也是由init通过解析init.zygote.rc文件，启动而来。</p><p><strong>“所有的Java应用程序进程及系统服务SystemServer进程都由Zygote进程通过fork孵化而来”</strong></p><p>具体的关于 <code>.rc</code> 文件的解析，有缘我们在分析 <code>init</code> 程序的时候我们再分析。其中，我们暂时只需要知道 <code>service</code> 是 <code>.rc</code> 文件中的一个指令，具体的规则</p><p><strong>“service + 进程名 + 可执行程序 + 启动参数”</strong></p><p><code>init</code> 进程通过分析如下 <code>init.zygote.rc</code> 文件, 执行 <code>app_process</code> 可执行文件，创建 <code>zygote</code> 进程。也即 <code>zygote</code> 对应的可执行程序是 <code>/system/bin/app_process</code> ，启动后会改名为 <code>zygote</code> ， 启动的时候会带一些其他的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### init.zygote64_32.rc</span></span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><h2 id="app-process启动分析"><a href="#app-process启动分析" class="headerlink" title="app_process启动分析"></a>app_process启动分析</h2><p>接着我们来分析 <code>Zygote(app_process)</code> 的启动过程，作为一个可执行程序，必须有标准的入口, 即 <code>main</code> 函数。如果我们了解的更多的话，我们会知道 <code>app_process</code> 不仅仅会启动 <code>Zygote</code> 进程，还可以直接有个用法是在 <code>android</code> 中执行 <code>jar</code> 包，比如这是 <code>monkey</code> 命令对应的脚本，可以看到其实只是使用 <code>app_process</code> 执行对应的 <code>jar</code> 包中 <code>main</code> 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### /system/bin/monkey</span></span><br><span class="line">base=/system</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$base</span>/framework/monkey.jar</span><br><span class="line"><span class="built_in">trap</span> <span class="string">""</span> HUP</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  bash arg:"</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exec</span> app_process <span class="variable">$base</span>/bin com.android.commands.monkey.Monkey <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>了解这个之后，我们就可以真正的分析 <code>app_process</code> 的启动流程了。如下是 <code>main</code> 函数的实现，忽略不必要的 <code>log</code> 打印</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算argv的长度，作为创建AppRuntime的参数，见 注①</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="comment">//此处省略部分代码，解析参数-cp与-classpath，添加到runtime中，常见于我们直接在Android中执行jar包</span></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//①如果创建的Zygote进程，此处为true，niceName为zygote</span></span><br><span class="line">    <span class="comment">//②如果通过app_process执行jar包，此处zygote为false，niceName为空，className为对应的传递的类名</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处从argv中解析对应的参数</span></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="comment">//className不空，说明是通过app_process启动jar包，向runtime传递对应的参数，比如说monkey中的“$@”</span></span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//启动zygote进程</span></span><br><span class="line">        <span class="comment">//此处创建DalvikCache文件夹, 设置权限，群组等</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到设备支持的abi架构，可以直接通过adb shell getprop ro.product.cpu.abilist64(或者32，根据不同的CPU架构)</span></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>; <span class="comment">//可能不只一个abi，比如说对于arm64-v8的CPU一般都会支持armeabi-v7a，armeabi</span></span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩余参数</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//niceName不空，比如zygote进程。</span></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//此处把app_process进程名，改为zygote，见 注② 这就是上述说得改名操作</span></span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//zygote模式启动com.android.internal.os.ZygoteInit此java类 注③</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="comment">//非zyote启动com.android.internal.os.RuntimeInit类 注④</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上述注释我们可以看到， <code>main</code> 函数只是解析了对应的参数，所有的操作还是交给了 <code>AppRuntime</code> 去操作。我们接着来分析注释中的注</p><blockquote><p>注①： 此处调用AppRuntime的构造函数，目的只是给变量赋值，无特殊操作。</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppRuntime</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AppRuntime</span> :</span> <span class="keyword">public</span> AndroidRuntime</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     AppRuntime(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> argBlockLength)</span><br><span class="line">         : AndroidRuntime(argBlockStart, argBlockLength)</span><br><span class="line">         , mClass(<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// AndroidRuntime</span></span><br><span class="line"> AndroidRuntime::AndroidRuntime(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> argBlockLength) :</span><br><span class="line">         mExitWithoutCleanup(<span class="literal">false</span>),</span><br><span class="line">         mArgBlockStart(argBlockStart),</span><br><span class="line">         mArgBlockLength(argBlockLength)</span><br><span class="line"> &#123;</span><br><span class="line">     SkGraphics::Init(); <span class="comment">//初始化skia，具体意义未知</span></span><br><span class="line">     mOptions.setCapacity(<span class="number">20</span>);</span><br><span class="line">     gCurRuntime = <span class="keyword">this</span>; <span class="comment">//全局变量，供以后使用，详见下文</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注②： 修改进程名称操作</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::setArgv0(<span class="keyword">const</span> <span class="keyword">char</span>* argv0, <span class="keyword">bool</span> setProcName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setProcName) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(argv0);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">15</span>) &#123;</span><br><span class="line">            pthread_setname_np(pthread_self(), argv0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_setname_np(pthread_self(), argv0 + len - <span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mArgBlockStart, <span class="number">0</span>, mArgBlockLength);</span><br><span class="line">    strlcpy(mArgBlockStart, argv0, mArgBlockLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注③：启动对应的java虚拟机和加载对应的类</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ...此处忽略一些环境变量的检查设置</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    <span class="comment">//此处初始化JniInvocation，加载libart.so, 绑定一些与JavaVm相关的函数</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//startVM 封装参数，调用art中的JNI_CreateJavaVM, 创建jni使用的所有资源, 返回mJavaVM静态全局变量</span></span><br><span class="line">    <span class="comment">//以及当前线程的JniEnv</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于zygote空实现，对应普通的java应用程序而言, 会在此处加载对应的class文件，</span></span><br><span class="line">    <span class="comment">//原因是如果在boot class加载其他类，classloader会认为此类就存在boot class中，不会去找classpath中提供的类</span></span><br><span class="line">    <span class="comment">//最简单解决方案是在加载boot class之前加载对应的类</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册android相关接口,这里会设置一个创建线程的回调给Thread.cpp, 以后创建线程都会掉到此处设置的回调</span></span><br><span class="line">    <span class="comment">//见 注④</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建java中的String数组保存调用时要传入的参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//toSlashClassName目的是把类名中的.替换成/, </span></span><br><span class="line">    <span class="comment">//如com.android.internal.os.ZygoteInit修改成com/android/internal/os/ZygoteInit</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载class后，调用对应的main函数，[Ljava/lang/String;)V为函数签名，返回值void，参数String[]</span></span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,<span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关掉VM</span></span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注④ 如果熟悉JNI的话可能会遇到过这种经历，想要在native代码中创建子线程然后访问JNIEnv会直接崩溃，但是直接在java创建子线程，然后调用的对应jni接口的话却不会，从android的线程代码实现中我们也可以看到最终调用的同样是pthread相关的接口，为什么出现不一致的行为呢？</p></blockquote><p>其一，崩溃问题原因是jni的限制，不允许在其他线程中直接访问JNIEnv，必须通过JavaVM中的AttachCurrentThread把线程绑定到当前的VM上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JNIEnv* is A JNI interface pointer (JNIEnv*) is passed as an argument for each native function</span></span><br><span class="line"><span class="comment">// mapped to a Java method, allowing for interaction with the JNI environment within the native</span></span><br><span class="line"><span class="comment">// method. This JNI interface pointer can be stored, but remains valid only in the current thread.</span></span><br><span class="line"><span class="comment">// Other threads must first call AttachCurrentThread() to attach themselves to the VM and obtain a</span></span><br><span class="line"><span class="comment">// JNI interface pointer. Once attached, a native thread works like a regular Java thread running</span></span><br><span class="line"><span class="comment">// within a native method. The native thread remains attached to the VM until it calls</span></span><br><span class="line"><span class="comment">// DetachCurrentThread() to detach itself. </span></span><br><span class="line"><span class="comment">// To attach to the current thread and get a JNI interface pointer: </span></span><br><span class="line"></span><br><span class="line"> JNIEnv *env; </span><br><span class="line"> (*g_vm)-&gt;AttachCurrentThread (g_vm, (<span class="keyword">void</span> **) &amp;env, <span class="literal">NULL</span>); </span><br><span class="line"> <span class="comment">//To detach from the current thread: </span></span><br><span class="line"> (*g_vm)-&gt;DetachCurrentThread (g_vm);</span><br></pre></td></tr></table></figure><p>其二，为什么java创建的线程可以直接访问？</p><p>如上代码中的 <code>startReg</code> 接口具体实现如下, 关键之处在于设置创建线程的回调这一调用，我们看最终调用的 <code>javaCreateThreadEtc</code> 接口，这个是从 <code>java</code> 层创建线程默认都会调用到的一处回调。抛开具体的参数不谈，我们可以看到继续调用了 <code>androidCreateRawThreadEtc</code> 方法，这个方法 <code>Thread.cpp</code> 中的接口，创建线程时使用，注意它的第一个参数，是一个函数指针 <code>AndroidRuntime::javaThreadShell</code>，这个就是我们关注的重点，正真起作用的地方,  可以看到，其实最终也是把创建的线程绑定到当前的 <code>VM</code> 中，这就是为什么在 <code>java</code> 线程中可以直接通过调用 <code>jni</code> 方法访问 <code>JNIEnv</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里会设置一个创建线程的回调给Thread.cpp, 以后创建线程都会掉到此处设置的回调</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    </span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册android相关接口,</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(NULL);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> AndroidRuntime::javaCreateThreadEtc(</span><br><span class="line">                                android_thread_func_t entryFunction,</span><br><span class="line">                                <span class="keyword">void</span>* userData,</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span>* threadName,</span><br><span class="line">                                int32_t threadPriority,</span><br><span class="line">                                size_t threadStackSize,</span><br><span class="line">                                android_thread_id_t* threadId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>** args = (<span class="keyword">void</span>**) malloc(<span class="number">3</span> * sizeof(<span class="keyword">void</span>*)); </span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    args[<span class="number">0</span>] = (<span class="keyword">void</span>*) entryFunction;</span><br><span class="line">    args[<span class="number">1</span>] = userData;</span><br><span class="line">    args[<span class="number">2</span>] = (<span class="keyword">void</span>*) strdup(threadName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注对象 javaThreadShell</span></span><br><span class="line">    result = androidCreateRawThreadEtc(AndroidRuntime::javaThreadShell, args,</span><br><span class="line">        threadName, threadPriority, threadStackSize, threadId);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> AndroidRuntime::javaThreadShell(<span class="keyword">void</span>* args) &#123;</span><br><span class="line">    <span class="keyword">void</span>* start = ((<span class="keyword">void</span>**)args)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">void</span>* userData = ((<span class="keyword">void</span> **)args)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span>* name = (<span class="keyword">char</span>*) ((<span class="keyword">void</span> **)args)[<span class="number">2</span>];        <span class="comment">// we own this storage</span></span><br><span class="line">    free(args);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vm =&gt; javaAttachThread</span></span><br><span class="line">    <span class="keyword">if</span> (javaAttachThread(name, &amp;env) != JNI_OK)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程android_thread_func_t方法</span></span><br><span class="line">    result = (*(android_thread_func_t)start)(userData);</span><br><span class="line"></span><br><span class="line">    javaDetachThread();</span><br><span class="line">    free(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述分析，我们知道，最终 <code>app_process</code> 会调用的最终的传入的 <code>java</code> 类的 <code>main</code> 函数，此处分为 <code>zygote</code> 和普通我们执行的 <code>jar</code> 包等。我们首先分析一下 <code>zygote</code> 传入的 <code>main</code> 函数所在类<code>com.android.internal.os.ZygoteInit</code></p><h2 id="Zygote进程创建"><a href="#Zygote进程创建" class="headerlink" title="Zygote进程创建"></a>Zygote进程创建</h2><p>ZygoteInit是一个普通的java类。我们从main函数开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ZygoteServer，具体详解见 注⑤</span></span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记zygote启动，最终调用到libcore中的实现</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//解析之前传入的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册ZygoteServer，注⑤</span></span><br><span class="line">        zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">        <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">        <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            preload();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置当前线程优先级</span></span><br><span class="line">            Zygote.resetNicePriority();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line"></span><br><span class="line">        Zygote.nativeSecurityInit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">        Zygote.nativeUnmountStorageOnInit();</span><br><span class="line"></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fork创建system_server 注⑥</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">            <span class="comment">// child (system_server) process.</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        <span class="comment">//注⑤</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">    <span class="comment">// command.</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     beginIcuCachePinning();</span><br><span class="line">     <span class="comment">//通过读/system/etc/preloaded-classes，一个个加载对应的class</span></span><br><span class="line">     preloadClasses();</span><br><span class="line">     <span class="comment">//预加载一些Resource，例如分辨率，locale等</span></span><br><span class="line">     preloadResources();</span><br><span class="line">     <span class="comment">//HAL</span></span><br><span class="line">     nativePreloadAppProcessHALs();</span><br><span class="line">     <span class="comment">//EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</span></span><br><span class="line">     preloadOpenGL();</span><br><span class="line">     <span class="comment">//System.loadLibrary("android");</span></span><br><span class="line">     <span class="comment">//System.loadLibrary("compiler_rt");</span></span><br><span class="line">     <span class="comment">//System.loadLibrary("jnigraphics");</span></span><br><span class="line">     preloadSharedLibraries();</span><br><span class="line">     <span class="comment">//字体</span></span><br><span class="line">     preloadTextResources();</span><br><span class="line">     <span class="comment">//webview</span></span><br><span class="line">     WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">     endIcuCachePinning();</span><br><span class="line">     <span class="comment">//KeyStore,加密解密相关</span></span><br><span class="line">     warmUpJcaProviders();</span><br><span class="line">     sPreloadComplete = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注⑤  ZygoteServer的作用，创建一个socket server，等待客户端发送对应的请求，zygote的客户端对应的是ActivityManageService</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers a server socket for zygote command connections</span></span><br><span class="line"><span class="comment"> * 从之前的init.rc中可以看到，zygote传入的socketName即默认的socketName: -socket-name=zygote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerServerSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fileDesc;</span><br><span class="line">        <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; <span class="comment">//"ANDROID_SOCKET_"</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String env = System.getenv(fullSocketName);</span><br><span class="line">            fileDesc = Integer.parseInt(env);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(fullSocketName + <span class="string">" unset or invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建LocalServerSocket监听</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">            fd.setInt$(fileDesc);</span><br><span class="line">            mServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Error binding to local socket '"</span> + fileDesc + <span class="string">"'"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    </span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待pollFds对应的fd发生改变，意味着有命令来到需要处理</span></span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//未发生改变，不做操作</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                        <span class="comment">// not until we attempt to read from it from processOneCommand. This shows up as</span></span><br><span class="line">                        <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the server so any exception here is one that has taken place</span></span><br><span class="line">                        <span class="comment">// pre-fork while processing commands or reading / writing from the</span></span><br><span class="line">                        <span class="comment">// control socket. Make a loud noise about any such exceptions so that</span></span><br><span class="line">                        <span class="comment">// we know exactly what failed and why.</span></span><br><span class="line"></span><br><span class="line">                        Slog.e(TAG, <span class="string">"Exception executing zygote command: "</span>, e);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Make sure the socket is closed so that the other end knows immediately</span></span><br><span class="line">                        <span class="comment">// that something has gone wrong and doesn't time out waiting for a</span></span><br><span class="line">                        <span class="comment">// response.</span></span><br><span class="line">                        ZygoteConnection conn = peers.remove(i);</span><br><span class="line">                        conn.closeSocket();</span><br><span class="line"></span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the child so any exception caught here has happened post</span></span><br><span class="line">                        <span class="comment">// fork and before we execute ActivityThread.main (or any other main()</span></span><br><span class="line">                        <span class="comment">// method). Log the details of the exception and bring down the process.</span></span><br><span class="line">                        Log.e(TAG, <span class="string">"Caught post-fork exception in child process."</span>, e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想研究一下 Android 源码中关于图形渲染相关的内容，但是一直感觉无从入手，所以干脆直接从进程启动开始说起吧。后续会按照我看的内容尽量的写一些相关的博客。充实一下自己，打磨一下时光。废话少说，今天我们来分析一下 Android 应用进程的Zygote说起。&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="https://jianglei12138.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Zygote进程" scheme="https://jianglei12138.github.io/tags/Zygote%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="app_process" scheme="https://jianglei12138.github.io/tags/app-process/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava2 使用以及源码阅读</title>
    <link href="https://jianglei12138.github.io/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://jianglei12138.github.io/2018/06/15/Rxjava2源码阅读/</id>
    <published>2018-06-15T13:12:45.000Z</published>
    <updated>2019-03-10T15:34:31.976Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个没怎么使用过<code>Rxjava2</code>的人来说，要理解<code>Rxjava2</code>的很多东西确实有一些困难，因此我想从<code>Rxjava2</code>的源码来入手，研究一下<code>Rxjava</code>的实现原理，以及体验一下响应式编程的乐趣。<br> <a id="more"></a></p><h1 id="Rxjava2-使用以及源码阅读"><a href="#Rxjava2-使用以及源码阅读" class="headerlink" title="Rxjava2 使用以及源码阅读"></a>Rxjava2 使用以及源码阅读</h1><p>作为一个没怎么使用过<code>Rxjava2</code>的人来说，要理解<code>Rxjava2</code>的很多东西确实有一些困难，因此我想从<code>Rxjava2</code>的源码来入手，研究一下<code>Rxjava</code>的实现原理，以及体验一下响应式编程的乐趣。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>如果你去看关于<code>Rxjava</code>的博客，一般都会介绍到<code>Rxjava</code>使用了一种叫做<code>观察者</code>的设计模式。这个观察者模式是什么呢？按照我们大学老师的原话来说,  观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。具体可参考 <a href="https://blog.csdn.net/lovelion/article/details/7720382" target="_blank" rel="noopener">观察者模式</a>, 顺便说一句，刘伟老师的博客质量还是很好的。</p><p>具体关于观察者模式的定义，可参考GOF的《设计模式》一书。</p><blockquote><p>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p></blockquote><p>如图是观察者模式的UML类图，其中包括主要的几个角色</p><p><img src="/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/1341501815_4830.jpg" alt="1341501815_4830"></p><ul><li>Subject/ConcrateSubject, 目标又被称为主题，是指被观察的对象（被观察者），目标中定义了一系列的观察者，一个观察者subject可以接受任何数量的观察者，当Subject发生改变，将通过notify方法通知到观察者。</li><li>Observer/ConcreteObserver，观察者, 根据被观察的改变作出具体的反应。</li></ul><p>我们可以想象一种场景，当你在玩节奏大师这个游戏的时候，抱歉我没有玩过，游戏就是Subject，你就是Observer，当游戏中出现音符后，你就需要点击对应的音符。游戏作为Subject，它产生了一些列的音符，当它出现时，会通知到你，进而你可以对Subject的改变做一些其他的事情。</p><h3 id="Rxjava源码分析"><a href="#Rxjava源码分析" class="headerlink" title="Rxjava源码分析"></a>Rxjava源码分析</h3><h4 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h4><p>观察者模式说完，在正式的介绍Rxjava之前，我们需要了解一个概念叫做<code>背压(BackPressure)</code>，想象你还在玩节奏大师，你需要根据游戏来做一些反馈，这有点类似生产者消费者模型，游戏作为生产者，一直在生产各种音符(在Rxjava被称为发射emit)，你作为消费者，你对音符需要点击，长按等操作。但是，如果音符出现的特别快，我们就会有一种处理不过来的感觉。这就是背压。</p><blockquote><p>生产者（被观察者）的生产速度大于消费者（观察者）消费速度，就会产生背压</p></blockquote><p>了解背压，我们就可以分析<code>Rxjava</code>的实现了，源码是参考<code>Rxjava2</code>的最新代码,，我没有用过<code>Rxjava 1.x</code>版本。首先我们知道<code>Rxjava</code>使用了观察者模式。那么我们首先来分析一下<code>Rxjava</code>中的观察者模式中的目标(Subject)，即被观察者， Rxjava中有很多已经实现了的被观察者，包括 <code>Observable</code> ，<code>Flowable</code>，<code>Single</code>，<code>Completable</code>，<code>Maybe。</code>具体的阐述与区别如下表。</p><table><thead><tr><th>观察者</th><th>应用场景</th></tr></thead><tbody><tr><td><code>Observable</code></td><td>不支持背压，适用于数据量不是很大的生产者消费者模型，一般官方推荐低于1k，数据量过大可能会导致资源暂用，表现出来的形式就是系统卡顿或者OOM</td></tr><tr><td><code>Flowable</code></td><td>与<code>Observable</code>的不同之处在于支持背压，通过设置缓存等方式控制生产者的生产数量。</td></tr><tr><td><code>Single</code></td><td>适用于单一事件流，即生产者只会生产一个数据(onNext)，接着就是完成(onComplete)或者出错(onError)</td></tr><tr><td><code>Completable</code></td><td>如果消费者不关心生产者任何的数据，只需要关注完成或者出错</td></tr><tr><td><code>Maybe</code></td><td>类似<code>Single</code>于<code>Completable</code>混合体，可能存在事件也可能不存在</td></tr></tbody></table><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>如下，一个典型的Rxjava的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable</span><br><span class="line">                .create((ObservableOnSubscribe&lt;Integer&gt;) observableEmitter -&gt; &#123;</span><br><span class="line">                    observableEmitter.onNext(<span class="number">10</span>);</span><br><span class="line">                    observableEmitter.onComplete();</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(integer -&gt; <span class="keyword">new</span> RuntimeException().printStackTrace(),</span><br><span class="line">                        Throwable::printStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException</span><br><span class="line">at Main.lambdamain1(Main.java:11)</span><br><span class="line">at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63)</span><br><span class="line">at io.reactivex...ObservableCreate$CreateEmitter.onNext(ObservableCreate.java:67)</span><br><span class="line">at Main.lambdamain0(Main.java:8)</span><br><span class="line">at io.reactivex.internal...ObservableCreate.subscribeActual(ObservableCreate.java:40)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:12051)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:12037)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:11966)</span><br><span class="line">at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>可以看出来大概的调用流程是，通过<code>subscribe</code>绑定观察者之后，通过调用被观察者的<code>subscribeActual</code>接口，进而最终调用到观察者的<code>onNext</code>等方法。了解大致的流程，后面就可以分析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## Observable.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line"></span><br><span class="line">##Observer.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//提供的Disposable接口，方便在随时时解除观察者的订阅，一般在subscribeActual中最开始初始化Disposable之后调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span></span>;</span><br><span class="line">    <span class="comment">//提供新的数据给到观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T t)</span></span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span></span>;</span><br><span class="line"><span class="comment">//数据分发完成</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Disposable.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当Observer不再关注Observable的改变时，可通过调用此接口解除关联。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><p>首先我们分析Rxjava中的通用被观察者<code>Observable</code>。<code>Observable</code>用来是生成被观察的序列，对象等的方式。<code>Observable</code>类中大约15000多行代码，大部分的函数都是静态函数和一些流式方法。在理解Observable之前我们需要能看懂一些常用的图，这些也是在很多介绍Rxjava都会遇到。如下，</p><p><img src="/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/legend.png" alt="legend"></p><p>Observable提供了一系列的操作符，所有的操作参考下面表格</p><table><thead><tr><th align="center">操作符</th><th align="center">简要介绍</th></tr></thead><tbody><tr><td align="center">创建操作</td><td align="center">用于创建Observable的操作符，一般都是静态方法</td></tr><tr><td align="center">变换操作</td><td align="center">这些操作符可用于对Observable发射的数据进行变换</td></tr><tr><td align="center">过滤操作</td><td align="center">这些操作符用于从Observable发射的数据中进行选择</td></tr><tr><td align="center">组合操作</td><td align="center">组合操作符用于将多个Observable组合成一个单一的Observable</td></tr><tr><td align="center">错误处理</td><td align="center">这些操作符用于从错误通知中恢复</td></tr><tr><td align="center">辅助操作</td><td align="center">一组用于处理Observable的操作符</td></tr><tr><td align="center">条件和布尔操作</td><td align="center">这些操作符可用于单个或多个数据项，也可用于Observable</td></tr><tr><td align="center">算术和聚合操作</td><td align="center">这些操作符可用于整个数据序列</td></tr><tr><td align="center">连接操作</td><td align="center">一些有精确可控的订阅行为的特殊Observable</td></tr><tr><td align="center">转换操作</td><td align="center">将Observable转换为其它的对象或数据结构， 阻塞Observable等</td></tr></tbody></table><h5 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h5><p>创建操作常用的操作符有<code>Create</code>, <code>Defer</code>, <code>Empty/Never/Error</code>, <code>From</code>, <code>Interval</code>, <code>Just</code>, <code>Range</code>, <code>Repeat</code>, <code>Start</code>, <code>Timer</code>。我们一个个来看具体的实现。</p><blockquote><p> Rxjava并不是完整的按照观察者模式来实现的。在Rxjava中看起来更像是Observable订阅了Observer，与观察者模式反着来的，原因是为了使用流式编程作出的妥协，这样虽然逻辑上可能有点绕，但是对代码风格的统一却起着巨大作用。刚入门可能会因为这个被绕晕，了解了就知道这个是什么情况了。</p></blockquote><h6 id="Create"><a href="#Create" class="headerlink" title="# Create"></a># Create</h6><p>通过自定义ObservableOnSubscribe接口创建一个ObservableCreate对象，ObservableCreate中包含一个ObservableOnSubscribe的属性。从代码中我们可以看出创建了一个被观察者ObservableCreate，并且提供了subscribe方法来订阅观察者（Observable订阅了Observer），绑定了一个ObservableEmitter用来发送数据</p><p><img src="/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/create.png" alt="create"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableCreate.java</span><br><span class="line"><span class="comment">//具体观察者，继承Observable，实现其抽象方法subscribeActual</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Dispose并调用observer的onSubscribe方法，将Dispose传递到Onbserver中</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用ObservableOnSubscribe的subscribe方法，这个接口是我们创建，作为create参数传入的，里面一般会调用传入的Emitter发射器的onNext，onError或者onComplete方法。此处Rxjava专门实现了一套对应的CreateEmitter类，即parent</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发射器，在Observer之上封装一层</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line">    CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判空，Rxjava2不允许onNext传入参数为null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            onError(<span class="keyword">new</span> NullPointerException(...));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否已解除监听</span></span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            observer.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">            RxJavaPlugins.onError(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                observer.onError(t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dispose();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                observer.onComplete();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableOnSubscribe.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableEmitter.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(Disposable d)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(Cancellable c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Emitter.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Defer"><a href="#Defer" class="headerlink" title="# Defer"></a># Defer</h6><p>介绍完Create我们来看另一个创建操作符Defer，Defer字面意思是推迟，即在运行subscribe才会去创建Observable，每个观察者被订阅的时候都重新创建被观察者，如图所示：<img src="/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/defer.png" alt="defer"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">defer</span><span class="params">(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(supplier, <span class="string">"supplier is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableDefer&lt;T&gt;(supplier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableDefer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableDefer</span><span class="params">(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        ObservableSource&lt;? extends T&gt; pub;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过Callable接口，实现真正执行的时候重新创建Observable</span></span><br><span class="line">            pub = ObjectHelper.requireNonNull(supplier.call(), <span class="string">"null ObservableSource supplied"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(t);</span><br><span class="line">            EmptyDisposable.error(t, s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pub.subscribe(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Empty-Never-Error"><a href="#Empty-Never-Error" class="headerlink" title="# Empty/Never/Error"></a># Empty/Never/Error</h6><p>这几个使用场景比较单一，常用了作为测试用途。</p><p><code>empty</code>操作符不会发送任何数据，而是直接发送<code>onComplete</code>事件。</p><p><img src="/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/empty.c.png" alt="empty.c"></p><p><code>never</code>什么都不会发送的操作符，也不会触发观察者任何的回调，通常用于“测试”用途。</p><p><img src="/images/placeholder.png" alt="never.c" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/never.c.png" class="lazyload"></p><p><code>Error</code>操作符就是调用时候直接发送onError事件给观察者：</p><p><img src="/images/placeholder.png" alt="error" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/error.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly((Observable&lt;T&gt;) ObservableEmpty.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableEmpty.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableEmpty</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">ScalarCallable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Observable&lt;Object&gt; INSTANCE = <span class="keyword">new</span> ObservableEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObservableEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Object&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用了Observer的onComplete方法</span></span><br><span class="line">        <span class="comment">//EmptyDisposable.complete</span></span><br><span class="line">        <span class="comment">//o.onSubscribe(INSTANCE);</span></span><br><span class="line">        <span class="comment">//o.onComplete();</span></span><br><span class="line">        EmptyDisposable.complete(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// null scalar is interpreted as being empty</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">error</span><span class="params">(Callable&lt;? extends Throwable&gt; errorSupplier)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(errorSupplier, <span class="string">"errorSupplier is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableError&lt;T&gt;(errorSupplier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableError.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableError</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends Throwable&gt; errorSupplier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableError</span><span class="params">(Callable&lt;? extends Throwable&gt; errorSupplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorSupplier = errorSupplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        Throwable error;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            error = ObjectHelper.requireNonNull(errorSupplier.call(), ...);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(t);</span><br><span class="line">            error = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用了Observer的onError方法</span></span><br><span class="line">        <span class="comment">//s.onSubscribe(INSTANCE);</span></span><br><span class="line">        <span class="comment">//s.onError(error);</span></span><br><span class="line">        EmptyDisposable.error(error, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">error</span><span class="params">(<span class="keyword">final</span> Throwable exception)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(exception, <span class="string">"e is null"</span>);</span><br><span class="line">    <span class="comment">//把exception封装成Callable</span></span><br><span class="line">    <span class="keyword">return</span> error(Functions.justCallable(exception));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">never</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly((Observable&lt;T&gt;) ObservableNever.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableNever.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableNever</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Observable&lt;Object&gt; INSTANCE = <span class="keyword">new</span> ObservableNever();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObservableNever</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Object&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只是创建了一个NEVER disposable的EmptyDisposable, 无其他操作</span></span><br><span class="line">        o.onSubscribe(EmptyDisposable.NEVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="From"><a href="#From" class="headerlink" title="# From"></a># From</h6><p><code>from</code>是一系列from的集合，包括fromArray，fromCallable，fromFuture，fromIterable，fromPublisher，此处列举fromArray，fromCallable其他的实现大同小异。</p><p><img src="/images/placeholder.png" alt="from" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/from.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">fromArray</span><span class="params">(T... items)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(items, <span class="string">"items is null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (items.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (items.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> just(items[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFromArray&lt;T&gt;(items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableFromArray.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableFromArray</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableFromArray</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        FromArrayDisposable&lt;T&gt; d = <span class="keyword">new</span> FromArrayDisposable&lt;T&gt;(s, array);</span><br><span class="line">        s.onSubscribe(d);</span><br><span class="line">        <span class="keyword">if</span> (d.fusionMode) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FromArrayDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicQueueDisposable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line">    <span class="keyword">final</span> T[] array;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">boolean</span> fusionMode;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> disposed;</span><br><span class="line"></span><br><span class="line">    FromArrayDisposable(Observer&lt;? <span class="keyword">super</span> T&gt; actual, T[] array) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actual = actual;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T[] a = array;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; !isDisposed(); i++) &#123;</span><br><span class="line">            T value = a[i];</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                actual.onError(<span class="keyword">new</span> NullPointerException(<span class="string">"The "</span> + i + <span class="string">"th element is null"</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            actual.onNext(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            actual.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">fromCallable</span><span class="params">(Callable&lt;? extends T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(supplier, <span class="string">"supplier is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFromCallable&lt;T&gt;(supplier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableFromCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends T&gt; callable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableFromCallable</span><span class="params">(Callable&lt;? extends T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        DeferredScalarDisposable&lt;T&gt; d = <span class="keyword">new</span> DeferredScalarDisposable&lt;T&gt;(s);</span><br><span class="line">        s.onSubscribe(d);</span><br><span class="line">        <span class="keyword">if</span> (d.isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = ObjectHelper.requireNonNull(callable.call(), <span class="string">"Callable returned null"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="keyword">if</span> (!d.isDisposed()) &#123;</span><br><span class="line">                s.onError(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RxJavaPlugins.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d.complete(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectHelper.requireNonNull(callable.call(), <span class="string">"The callable returned a null value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Interval"><a href="#Interval" class="headerlink" title="# Interval"></a># Interval</h6><p>每个固定的时间创建一个<code>Observable&lt;Integer&gt;</code></p><p><img src="/images/placeholder.png" alt="interval" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/interval.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line"><span class="comment">//scheduler默认为COMPUTATION，关于scheduler的详细解释，见下文</span></span><br><span class="line">    ObjectHelper.requireNonNull(unit, <span class="string">"unit is null"</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableInterval(Math.max(<span class="number">0L</span>, initialDelay), Math.max(<span class="number">0L</span>, period), unit, scheduler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableInterval.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableInterval</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> initialDelay;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line">    <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableInterval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialDelay = initialDelay;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.unit = unit;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Long&gt; s)</span> </span>&#123;</span><br><span class="line">        IntervalObserver is = <span class="keyword">new</span> IntervalObserver(s);</span><br><span class="line">        s.onSubscribe(is);</span><br><span class="line"></span><br><span class="line">        Scheduler sch = scheduler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Scheduler实现</span></span><br><span class="line">        <span class="keyword">if</span> (sch <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            Worker worker = sch.createWorker();</span><br><span class="line">            is.setResource(worker);</span><br><span class="line">            worker.schedulePeriodically(is, initialDelay, period, unit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit);</span><br><span class="line">            is.setResource(d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalObserver</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Disposable</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Long&gt; actual;</span><br><span class="line">        <span class="keyword">long</span> count;</span><br><span class="line">        IntervalObserver(Observer&lt;? <span class="keyword">super</span> Long&gt; actual) &#123;</span><br><span class="line">            <span class="keyword">this</span>.actual = actual;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (get() != DisposableHelper.DISPOSED) &#123;</span><br><span class="line">                actual.onNext(count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Just"><a href="#Just" class="headerlink" title="# Just"></a># Just</h6><p>对于只是发送几个数据来说，可以使用just操作符来简化, 如下，调用流程<code>onNext(&quot;test&quot;)</code>, <code>onNext(&quot;test1&quot;)</code>, <code>onNext(&quot;test2&quot;)</code>, 然后调用<code>onComplete()</code>, <code>Just</code>最多支持10个参数，除了一个参数的外，其他都是直接调用<code>fromArray</code>，一个参数的<code>Just</code>，具体实现与fromArray基本一致，在此不表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"test"</span>,<span class="string">"test2"</span>,<span class="string">"test3"</span>)</span><br><span class="line">        .subscribe(<span class="comment">//doSomething);</span></span><br></pre></td></tr></table></figure><p><img src="/images/placeholder.png" alt="just" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/just.png" class="lazyload"></p><h6 id="Range"><a href="#Range" class="headerlink" title="# Range"></a># Range</h6><p>如果需要确定一个反射数据的范围可以采用range或者是rangeLong，后者的数据类型是long，可以使用的范围更加广，其他完全是一样的。第一个参数作为起始值，第二个参数作为数量。</p><p><img src="/images/placeholder.png" alt="range.c" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/range.c.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Integer&gt; <span class="title">range</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> start, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &gt;= 0 required but it was "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> just(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过最大整形允许范围直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)start + (count - <span class="number">1</span>) &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Integer overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableRange(start, count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableRange.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableRange</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = (<span class="keyword">long</span>)start + count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Integer&gt; o)</span> </span>&#123;</span><br><span class="line">        RangeDisposable parent = <span class="keyword">new</span> RangeDisposable(o, start, end);</span><br><span class="line">        o.onSubscribe(parent);</span><br><span class="line">        parent.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeDisposable</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Integer&gt; actual;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">long</span> index;</span><br><span class="line">        <span class="keyword">boolean</span> fused;</span><br><span class="line"></span><br><span class="line">        RangeDisposable(Observer&lt;? <span class="keyword">super</span> Integer&gt; actual, <span class="keyword">long</span> start, <span class="keyword">long</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.actual = actual;</span><br><span class="line">            <span class="keyword">this</span>.index = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fused) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Observer&lt;? <span class="keyword">super</span> Integer&gt; actual = <span class="keyword">this</span>.actual;</span><br><span class="line">            <span class="keyword">long</span> e = end;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = index; i != e &amp;&amp; get() == <span class="number">0</span>; i++) &#123;</span><br><span class="line">                actual.onNext((<span class="keyword">int</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (get() == <span class="number">0</span>) &#123;</span><br><span class="line">                lazySet(<span class="number">1</span>);</span><br><span class="line">                actual.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于其他的创建操作符大致实现原理基本相同，不在此重复。</p><h5 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h5><p>对Observable发射的数据进行一系列变换，常用的操作符如<code>map</code>,<code>flatMap</code>,<code>flatMapIterable</code>,<code>concatMap</code>,<code>swicthMap</code>,<code>cast</code>,<code>scan</code>,<code>buffer</code>,<code>toList</code>,<code>groupBy</code>,<code>toMap</code>.</p><h6 id="map"><a href="#map" class="headerlink" title="# map"></a># map</h6><p>作为最长用的变换操作符我们首先来说一下<code>map</code>，可以把每一个元素转换成新的元素发射，接收一个<code>Function&lt;T,R&gt;</code>作为转换逻辑的操作。大致使用</p><p><img src="/images/placeholder.png" alt="map" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/map.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .map(integer -&gt; <span class="number">10</span> * integer)</span><br><span class="line">        .subscribe(ele -&gt; Log.i(<span class="string">"tag"</span>, String.valueOf(ele)));</span><br></pre></td></tr></table></figure><p>注意我们此处是不会改变发射数据的数量，只改变元素的。接下来看代码具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">    <span class="comment">//传入当前的被观察者与mapper</span></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableMap.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//与我们的之前分析的观察者与被观察之间的调用相同，其实如果我们看ObservableMap的具体继承，我们会发现其实ObservableMap也是一个被观察者，即map会产生一个新的被观察者对象，但是只有一个。发射的数据会创建多个。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(actual);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">                actual.onNext(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//map操作mapper.apply(t)</span></span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            actual.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="flatMap"><a href="#flatMap" class="headerlink" title="# flatMap"></a># flatMap</h6><p><code>Map</code>操作符是把每一个元素转换成一个新的元素，但是<code>flatMap</code>操作符是把每一个元素转换成新的被观察者，每个被观察者发射的元素将会合并成新的被观察者。例如下面的：</p><p><img src="/images/placeholder.png" alt="flatMap.c" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/flatMap.c.png" class="lazyload"></p><p><code>flatMap</code>一个很有用的场景是，当Observable发射一系列拥有Observable成员或以其他方式可转换为Observable的数据时，<code>flatMap</code>会合并这些数据，以便它们交错。举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">                .flatMap((Function&lt;Integer, ObservableSource&lt;?&gt;&gt;) integer -&gt; Observable.just(<span class="string">"a"</span>, String.valueOf(integer)))</span><br><span class="line">                        .subscribe(System.out::print);</span><br><span class="line"></span><br><span class="line">输出结果是: a1a2a3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个没怎么使用过&lt;code&gt;Rxjava2&lt;/code&gt;的人来说，要理解&lt;code&gt;Rxjava2&lt;/code&gt;的很多东西确实有一些困难，因此我想从&lt;code&gt;Rxjava2&lt;/code&gt;的源码来入手，研究一下&lt;code&gt;Rxjava&lt;/code&gt;的实现原理，以及体验一下响应式编程的乐趣。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://jianglei12138.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="RxJava2" scheme="https://jianglei12138.github.io/tags/RxJava2/"/>
    
  </entry>
  
  <entry>
    <title>ActivityThread 阅读之旅</title>
    <link href="https://jianglei12138.github.io/2018/06/13/ActivityThread%20%E9%98%85%E8%AF%BB%E4%B9%8B%E6%97%85/"/>
    <id>https://jianglei12138.github.io/2018/06/13/ActivityThread 阅读之旅/</id>
    <published>2018-06-13T15:28:30.000Z</published>
    <updated>2019-03-11T14:07:14.821Z</updated>
    
    <content type="html"><![CDATA[<p>研究一下App是如何启动的记录。我们知道<code>Main</code>函数是所有java程序的入口，Android也不例外，同样，启动一个应用程序，Android也会首先调用<code>Main</code>函数。<code>Main</code>函数位于<code>AcitivityThread</code>类中。<br> <a id="more"></a></p><h1 id="ActivityThread-阅读之旅"><a href="#ActivityThread-阅读之旅" class="headerlink" title="ActivityThread 阅读之旅"></a>ActivityThread 阅读之旅</h1><p>研究一下App是如何启动的记录。</p><p>我们知道<code>Main</code>函数是所有java程序的入口，Android也不例外，同样，启动一个应用程序，Android也会首先调用<code>Main</code>函数。<code>Main</code>函数位于<code>AcitivityThread</code>类中。</p><p>我们首先看<code>Main</code>函数的实现。</p><h6 id="framework-base-core-java-android-app-ActivityThread-java"><a href="#framework-base-core-java-android-app-ActivityThread-java" class="headerlink" title="framework/base/core/java/android/app/ActivityThread.java"></a>framework/base/core/java/android/app/ActivityThread.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Environment环境变量</span></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建MainLooper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下：</p><h6 id="1-Environment的初始化"><a href="#1-Environment的初始化" class="headerlink" title="1. Environment的初始化"></a>1. Environment的初始化</h6><p>其中我们可以看到<code>main</code>函数先初始化了<code>Environment</code>类，<code>Environment</code>中会初始化一系列与环境路径相关的操作，在App中可以直接使用类似Environment.getDataDirectory等接口进行访问.</p><h6 id="2-Looper相关初始化"><a href="#2-Looper相关初始化" class="headerlink" title="2. Looper相关初始化"></a>2. Looper相关初始化</h6><p><code>ActivityThread</code>通过调用<code>Looper.prepareMainLooper()</code>方法创建MainLopper，具体操作如下，先通过prepare方法创建一个不可退出的Looper作为MainLooper, 关于ThreadLocal相关的使用可以参见具体的博客等，此处不再赘述。值得一提的是，由于<code>prepare(boolean quitAllowed)</code>是私有方法，应用无法调用。但此处存在两个疑问：</p><blockquote><ol><li>在主线程调用了<code>prepareMainLooper</code>会出现什么情况?  直接出现异常</li><li>在子线程调用了<code>prepareMainLooper</code>会出现什么情况?  创建另外一个线程的MainLooper</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-ActivityThread的创建"><a href="#3-ActivityThread的创建" class="headerlink" title="3. ActivityThread的创建"></a>3. ActivityThread的创建</h6><p><code>ActivityThread</code>构造函数中创建了一个叫做mResourcesManager的实例，ResourcesManager是一个单例类，一些关于资源的配置，引用与实现都在此处实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread() &#123;</span><br><span class="line">    mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着会去调用<code>attach(false)</code>方法，此方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给成员变量赋值，可以通过ActivityThread.currentActivityThread()或者ActivityThread.isSystem()获取</span></span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//保证VM JIT实时编译打开</span></span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mAppThread是沟通AMS与ActivityThread的桥梁</span></span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//mgr会通过调用mAppThread中的一系列方法实现对Activity的控制</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">"Dalvik max="</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" total="</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" used="</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略system进程判断</span></span><br><span class="line">    <span class="comment">// add dropbox logging to libcore</span></span><br><span class="line">    DropBox.setReporter(<span class="keyword">new</span> DropBoxReporter());</span><br><span class="line">    ViewRootImpl.addConfigCallback(globalConfig -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">          <span class="comment">// We need to apply this change to the resources immediately, because upon returning</span></span><br><span class="line">          <span class="comment">// the view hierarchy will be informed about it.</span></span><br><span class="line">          <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig,</span><br><span class="line">                  <span class="keyword">null</span> <span class="comment">/* compat */</span>)) &#123;</span><br><span class="line">              updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),</span><br><span class="line">                      mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">              <span class="comment">// This actually changed the resources! Tell everyone about it.</span></span><br><span class="line">              <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span></span><br><span class="line">                      || mPendingConfiguration.isOtherSeqNewer(globalConfig)) &#123;</span><br><span class="line">                  mPendingConfiguration = globalConfig;</span><br><span class="line">                  sendMessage(H.CONFIGURATION_CHANGED, globalConfig);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要额外解释的是<code>ApplicationThread</code>中包含了一系列的<code>schedule</code>方法, 例如<code>schedulePauseActivity</code>, <code>scheduleStopActivity</code>等，这些方法都是直接通过<code>sendMessage</code>把对应的实现交给<code>ActivityThread</code>的<code>H extends Handler</code>类负责处理, <code>H</code>收到这些消息后，交给对应的<code>handle</code>方法，<code>handle</code>经过一系列的判断条件，最终调用<code>perform</code>接口实现功能，而<code>perform</code>就直接使用<code>Activity</code>中的方法，完成对<code>Activity</code>整个生命周期的控制。</p><h6 id="4-sMainThreadHandler的初始化"><a href="#4-sMainThreadHandler的初始化" class="headerlink" title="4. sMainThreadHandler的初始化"></a>4. sMainThreadHandler的初始化</h6><p>首先解决一下这个sMainThreadHandler的具体实现问题， 可以看到<code>ActivityThread</code>中关于<code>getHandler</code>只是直接返回了成员变量<code>mH</code>,即我们上文说道的处理<code>ApplicationThread</code>的具体实现的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外这个<code>sMainThreadHandler</code>的具体作用是什么呢，目前整个framework中只有一处使用了这个成员变量, 在<code>SharedPreferencesImpl</code>中的内部类<code>EditorImpl</code>的<code>notifyListeners</code>中，目的是把的对应的回调放到主线程中。私认为这不是一个很好的处理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mcr.listeners == <span class="keyword">null</span> || mcr.keysModified == <span class="keyword">null</span> ||</span><br><span class="line">        mcr.keysModified.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mcr.keysModified.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> String key = mcr.keysModified.get(i);</span><br><span class="line">            <span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Run this function on the main thread.</span></span><br><span class="line">        ActivityThread.sMainThreadHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    notifyListeners(mcr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-Loop循环"><a href="#5-Loop循环" class="headerlink" title="5. Loop循环"></a>5. Loop循环</h6><p>正式的启动主线程循环，主体代码如下。主要就是从当前Looper，即<code>MainLooper</code>中拿到所有的<code>message</code>, 然后调用其中的<code>dispatchMessage</code>方法。<code>dispatchMessage</code>会分发给对应的callback,然后根据判断决定最终的调用，比如说<code>handleMessage</code>方法，这也是我们经常使用的<code>Handler</code>收到<code>msg</code>后处理的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//去除一些打印等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler</code>中关于<code>dispatchMessage</code>的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们可以看到<code>ActivityThread</code>中完整了初始化的操作，绑定<code>ApplicationThread</code>与<code>AMS</code>, 启动主线程循环等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究一下App是如何启动的记录。我们知道&lt;code&gt;Main&lt;/code&gt;函数是所有java程序的入口，Android也不例外，同样，启动一个应用程序，Android也会首先调用&lt;code&gt;Main&lt;/code&gt;函数。&lt;code&gt;Main&lt;/code&gt;函数位于&lt;code&gt;AcitivityThread&lt;/code&gt;类中。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="https://jianglei12138.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="App启动流程" scheme="https://jianglei12138.github.io/tags/App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
      <category term="Main Handler" scheme="https://jianglei12138.github.io/tags/Main-Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android Framebuffer相关学习</title>
    <link href="https://jianglei12138.github.io/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://jianglei12138.github.io/2018/06/01/Android橡皮擦闪烁分析以及解决方案/</id>
    <published>2018-06-01T14:33:02.000Z</published>
    <updated>2019-03-10T15:51:42.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容：</p><ul><li>TFT-LCD显示过程分析</li><li>framebuffer的基本原理</li><li>画面延迟、撕裂分析</li></ul><a id="more"></a><p>本文主要内容：</p><ul><li>TFT-LCD显示过程分析</li><li>framebuffer的基本原理</li><li>画面延迟、撕裂分析</li></ul><h2 id="1、TFT-LCD显示过程简要分析-硬件层面"><a href="#1、TFT-LCD显示过程简要分析-硬件层面" class="headerlink" title="1、TFT-LCD显示过程简要分析(硬件层面)"></a>1、TFT-LCD显示过程简要分析(硬件层面)</h2><p>从硬件层面来说, TFT显示器参数vsync,hsync,hspw,hbpd,hfpd,vspw,vbp,vfp等参数很多都是从CRT带来的。描述方式多数显示器选择从左上角开始, 从左至右, 到了右边界, 再偏转到左边界的下一行, 这是所谓的”Z”型扫描。类似地扫描完最后一帧时, 要偏转回左上角起始处, 准备扫描下一帧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hsync #一行有效数据扫描完成后, 转到下一行起始处</span><br><span class="line">vsync #一帧数据扫描完成后，转到左上角起始处</span><br><span class="line"></span><br><span class="line">vbp #表示在一帧图像开始时，垂直同步信号以后的无效的行数，对应驱动中的upper_margin</span><br><span class="line">vfp #表示在一帧图像结束后，垂直同步信号以前的无效的行数，对应驱动中的lower_margin</span><br><span class="line">vspw #表示垂直同步脉冲的宽度，用行数计算，对应驱动中的vsync_len</span><br><span class="line"></span><br><span class="line">hbp #表示从水平同步信号开始到一行的有效数据开始之间的VCLK的个数，left_margin</span><br><span class="line">hfp #表示一行的有效数据结束到下一个水平同步信号开始之间的VCLK的个数，right_margin</span><br><span class="line">hspw #表示水平同步脉冲的宽度，用VCLK(像素时钟信号)计算，对应驱动中的hsync_len</span><br></pre></td></tr></table></figure><p>扫描一行的时序</p><blockquote><p>hspw -&gt; hbp -&gt; 扫描数据 -&gt; hfp -&gt; hspw</p></blockquote><p>扫描一帧的时序</p><blockquote><p>vspw -&gt; vbp -&gt; 扫描有效行 -&gt; vfp -&gt; vspw</p></blockquote><p><img src="/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/example.png" alt="example"></p><p>所有这些操作都是通过外部总线接口(EBI)实现在内存与其他外部操作实现数据的传输与控制。</p><h2 id="2、framebuffer的基本原理-软件方面"><a href="#2、framebuffer的基本原理-软件方面" class="headerlink" title="2、framebuffer的基本原理(软件方面)"></a>2、framebuffer的基本原理(软件方面)</h2><p>framebuffer，也叫帧缓冲，其内容对应于屏幕上的界面显示，可以将其简单理解为屏幕上显示内容对应的缓存，修改Framebuffer中的内容，即表示修改屏幕上的内容(具体如上硬件分析)，所以，直接操作Framebuffer可以直接从显示器上观察到效果。</p><p>framebuffer是逻辑上的概念，对应物理上是一段存储空间，其可以位于显存，也可以位于内存。</p><h4 id="framebuffer基本使用"><a href="#framebuffer基本使用" class="headerlink" title="framebuffer基本使用"></a>framebuffer基本使用</h4><p>查看显示参数</p><ul><li>分辨率<br> <code>cat /sys/class/graphics/fb0/modes</code></li><li>虚拟大小<br> <code>cat /sys/class/graphics/fb0/virtual_size</code></li></ul><p>更多如图</p><p><img src="/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/sys-class.png" alt="syc"></p><p>基本编程使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fb;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* fb_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the file for reading and writing</span></span><br><span class="line">    fd = open(<span class="string">"/dev/graphics/fb0"</span>, O_RDWR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Get fixed screen information</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get variable screen information</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Map the device to memory</span></span><br><span class="line">    fb_mem = (<span class="keyword">char</span> *)mmap(<span class="number">0</span>, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="framebuffer实现"><a href="#framebuffer实现" class="headerlink" title="framebuffer实现"></a>framebuffer实现</h4><p>Linux是工作在保护模式下，所以用户态进程是无法直接使用显卡提供的中断调用来实现直接写屏，Linux抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。</p><p>framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过framebuffer的读写直接对显存进行操作。framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过framebuffer的读写直接对显存进行操作。</p><p>这种操看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由framebuffer设备驱动来完成的。</p><p>framebuffer属性分为可变(variable)与不可变(fixed), 可直接通过ioctl获取与修改。</p><p>获取fixed属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo)</span><br></pre></td></tr></table></figure><p>获取variable属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, FBIOGET_VSCREENINFO, &amp;vinfo)</span><br></pre></td></tr></table></figure><p>设置variable属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, FBIOPUT_VSCREENINFO, &amp;vinfo)</span><br></pre></td></tr></table></figure><p>可修改属性 fb_var_screeninfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//可见分辨率</span></span><br><span class="line">    __u32 xres;</span><br><span class="line">    __u32 yres;</span><br><span class="line">    <span class="comment">//虚拟分辨率</span></span><br><span class="line">    __u32 xres_virtual;</span><br><span class="line">    __u32 yres_virtual;</span><br><span class="line">    <span class="comment">//虚拟分辨率的偏移</span></span><br><span class="line">    __u32 xoffset;</span><br><span class="line">    __u32 yoffset;</span><br><span class="line">    <span class="comment">//bpp 像素深度-&gt;每个像素所占的bit数</span></span><br><span class="line">    __u32 bits_per_pixel;</span><br><span class="line">    <span class="comment">//灰度值</span></span><br><span class="line">    __u32 grayscale;</span><br><span class="line">    <span class="comment">//RGB位域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span></span><br><span class="line">    <span class="comment">//是否标准像素格式</span></span><br><span class="line">    __u32 nonstd;</span><br><span class="line">    <span class="comment">//设置生效时机</span></span><br><span class="line">    __u32 activate;</span><br><span class="line">    <span class="comment">//图像实际(毫米)</span></span><br><span class="line">    __u32 height;</span><br><span class="line">    __u32 width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬件相关</span></span><br><span class="line">    __u32 pixclock;</span><br><span class="line">    __u32 left_margin;</span><br><span class="line">    __u32 right_margin;</span><br><span class="line">    <span class="comment">//vbp</span></span><br><span class="line">    __u32 upper_margin;</span><br><span class="line">    __u32 lower_margin;</span><br><span class="line">    __u32 hsync_len;</span><br><span class="line">    __u32 vsync_len;</span><br><span class="line"></span><br><span class="line">    __u32 sync;</span><br><span class="line">    __u32 vmode;</span><br><span class="line">    <span class="comment">//保留</span></span><br><span class="line">    __u32 reserved[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/var-info.png" alt="varInfo"></p><p>以上的参数对应在EBI与显示器的参数如图：</p><p><img src="/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/sync.png" alt="sync"></p><p>不可变属性 fb_fix_screeninfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line">    <span class="comment">//name</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//framebuffer物理起始地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> smem_start;</span><br><span class="line">    <span class="comment">//长度,字节为单位</span></span><br><span class="line">    __u32 smem_len;</span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 type_aux;</span><br><span class="line">    __u32 visual;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pan切换图像的不同可见区域</span></span><br><span class="line">    __u16 xpanstep;</span><br><span class="line">    __u16 ypanstep;</span><br><span class="line">    __u16 ywrapstep;</span><br><span class="line">    <span class="comment">//一行字节数</span></span><br><span class="line">    __u32 line_length;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//保留</span></span><br><span class="line">    __u16 reserved[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显示、虚拟区域的切换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vinfo.yoffset = <span class="number">0</span>;  <span class="comment">// vinfo.yoffset = vinfo.yres</span></span><br><span class="line">ioctl(fd, FBIOPAN_DISPLAY, &amp;vinfo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">varInfo.yoffset = varInfo.yres * n;</span><br><span class="line">varInfo.activate = FB_ACTIVATE_VBL;</span><br><span class="line">ioctl(frameBufferFd, FBIOPUT_VSCREENINFO, &amp;varInfo);</span><br></pre></td></tr></table></figure><h2 id="3、画面延迟、撕裂分析"><a href="#3、画面延迟、撕裂分析" class="headerlink" title="3、画面延迟、撕裂分析"></a>3、画面延迟、撕裂分析</h2><p>画面撕裂 Screen Tearing 是指显示器把两个或更多的帧（frame）显示在同一画面上。是显示器的刷新率(屏幕刷新率)与设备的显示输入(帧率)不同步发生的一种现象，首先介绍两个几个相关概念。<br><img src="/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/tearing.png" alt="tearing"></p><h4 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h4><p>即 Refresh Rate 或 Scanning Frequency，单位赫兹Hz，是指设备刷新屏幕的频率，该值对于特定的设备来说是个常量，其数值是显示器每秒钟更新画面的次数。不同的显示器支持再不同分辨率下的不同刷新率。它的范围可以从低到60高到100。如果你设置了一个特定的刷新率，显示器将一直按照这个速率刷新画面。甚至画面没有任何的改变。</p><h4 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h4><p>即 Frame Per Rate，单位 fps，是指 gpu 生成帧的速率，越高越好。它显示显卡在每秒钟可以描画多少画面。但是对于快速变化的游戏而言，你的FPS很难一直保持同样的数值，他会随着你所看到的显示卡所要描画的画面的复杂程度而变化。</p><p>维基百科中关于帧率数值的描述<a href="https://zh.wikipedia.org/wiki/帧率" target="_blank" rel="noopener">^1</a>：</p><ul><li>12 fps：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约10-12帧的时候，就会认为是连贯的</li><li>24 fps：有声电影的拍摄及播放帧率均为每秒24帧，对一般人而言已算可接受</li><li>30 fps：早期的高动态电子游戏，帧率少于每秒30帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低</li><li>60 fps：在实际体验中，60帧相对于30帧有着更好的体验</li><li>85 fps：一般而言，大脑处理视频的极限</li></ul><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>Screen Tearing出现的原因无非两个:</p><ol><li>在display的时候draw(也就是所谓的On Display Draw),  这种情况有可能会出现tearing(也不是必然).</li><li>是在display的时候swap buffer(Flip).</li></ol><h6 id="1-单缓冲方案-无等待"><a href="#1-单缓冲方案-无等待" class="headerlink" title="1. 单缓冲方案 - 无等待"></a>1. 单缓冲方案 - 无等待</h6><p>Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示。</p><p><img src="/images/placeholder.png" alt="no-vsync" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/no-vsync.png" class="lazyload"></p><blockquote><p>Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成</p><p>Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧</p><p>Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理</p><p>Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。“Jank”。</p><p>Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。</p></blockquote><p>单缓冲方案存在的问题:</p><ol><li>画面延迟</li><li>画面撕裂</li></ol><h6 id="2-单缓冲方案-等待"><a href="#2-单缓冲方案-等待" class="headerlink" title="2. 单缓冲方案 - 等待"></a>2. 单缓冲方案 - 等待</h6><p><img src="/images/placeholder.png" alt="with-vsync" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/with-vsync.png" class="lazyload"></p><p>VSync信号出现后，CPU不再犹豫，紧接着就开始执行buffer的准备工作。</p><p>由于大部分的Android显示设备刷新率是60Hz, 这也就意味着每一帧最多只能有1/60=16ms左右的准备时间。</p><ol><li>假如CPU/GPU的FPS高于这个值，那么这个方案是完美的，显示效果将很好。</li><li>CPU/GPU的性能无法满足上图的条件，会产生严重的画面延迟</li></ol><h6 id="3-双-多-缓冲方案-不等待"><a href="#3-双-多-缓冲方案-不等待" class="headerlink" title="3. 双(多)缓冲方案 - 不等待"></a>3. 双(多)缓冲方案 - 不等待</h6><p>完全把多缓冲当做单缓冲用</p><h6 id="3-双缓冲方案-等待"><a href="#3-双缓冲方案-等待" class="headerlink" title="3. 双缓冲方案 - 等待"></a>3. 双缓冲方案 - 等待</h6><p><img src="/images/placeholder.png" alt="double-buffer" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/double-buffer.png" class="lazyload"></p><p>如图采用了A/B双缓冲，以及前面介绍的VSync</p><ol><li>CPU/GPU处理所用的时间时短，但总的来说都在16ms以内，因而不影响显示效果。A和B分别代表两个缓冲区，它们不断地交换来正确显示画面。</li><li>当CPU/GPU的处理时间超过16ms时，第一个VSync到来时，缓冲区B中的数据还没有准备好，于是只能继续显示之前A缓冲区中的内容。而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。当下一个VSync出现时，CPU/GPU马上执行操作，此时它可操作的buffer是A，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li></ol><p><img src="/images/placeholder.png" alt="double-buffer-2" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/double-buffer-2.png" class="lazyload"></p><h6 id="4-三缓冲方案-等待"><a href="#4-三缓冲方案-等待" class="headerlink" title="4. 三缓冲方案 - 等待"></a>4. 三缓冲方案 - 等待</h6><p>第一次的Jank看起来是没有办法的，除非升级硬件配置来加快FPS。我们关注的重点是被CPU/GPU浪费的时间段，怎么才能充分利用起来呢？分析上述的过程，造成CPU/GPU无事可做的假象是因为当前已经没有可用的buffer了.  Triple Buffering是MultipleBuffering的一种，指的是系统使用3个缓冲区用于显示工作。</p><p><img src="/images/placeholder.png" alt="triple-buffer" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/triple-buffer.png" class="lazyload"></p><p>我们来逐步分析下这个新机制是否有效。首先和预料中的一致，第一次“Jank”无可厚非。不过让人欣慰的是，当第一次VSync发生后，CPU不用再等待了，它会使用第三个buffer C来进行下一帧数据的准备工作。虽然对缓冲区C的处理所需时间同样超过了16ms，但这并不影响显示屏——第2次VSync到来后，它选择buffer B进行显示;而第3次VSync时，它会接着采用C，而不是像double buffering中所看到的情况一样只能再显示一遍了。这样子就有效地降低了系统显示错误的机率。</p><h6 id="5-更多缓冲？"><a href="#5-更多缓冲？" class="headerlink" title="5. 更多缓冲？"></a>5. 更多缓冲？</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TFT-LCD显示过程分析&lt;/li&gt;
&lt;li&gt;framebuffer的基本原理&lt;/li&gt;
&lt;li&gt;画面延迟、撕裂分析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android学习" scheme="https://jianglei12138.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="framebuffer原理" scheme="https://jianglei12138.github.io/tags/framebuffer%E5%8E%9F%E7%90%86/"/>
    
      <category term="Screen Tearing" scheme="https://jianglei12138.github.io/tags/Screen-Tearing/"/>
    
      <category term="多缓冲区" scheme="https://jianglei12138.github.io/tags/%E5%A4%9A%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android图形框架的研究之路</title>
    <link href="https://jianglei12138.github.io/2018/04/01/Android%E5%9B%BE%E5%BD%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>https://jianglei12138.github.io/2018/04/01/Android图形框架的研究之路/</id>
    <published>2018-04-01T03:34:42.000Z</published>
    <updated>2019-03-10T15:23:36.196Z</updated>
    
    <content type="html"><![CDATA[<p>Android 目前通用的两种绘图方式是通过 Android 提供的 2D 绘图 API Canvas 与 OpenGL 两种方式实现。</p><p>Canvas 是一个 2D 图形 API，常用来绘制 Android 所有原生和自定义 View 。在 Android 中，Canvas API 通过一个名为 OpenGLRenderer 的绘制库实现硬件加速，该绘制库将 Canvas 运算转换为 OpenGL 运算，以便它们可以在 GPU 上执行。从 Android 4.0 之后开始，强制启用硬件加速。</p> <a id="more"></a><h1 id="Android图形框架的研究之路"><a href="#Android图形框架的研究之路" class="headerlink" title="Android图形框架的研究之路"></a>Android图形框架的研究之路</h1><p>Android 目前通用的两种绘图方式是通过 Android 提供的 2D 绘图 API Canvas 与 OpenGL 两种方式实现。</p><p>Canvas 是一个 2D 图形 API，常用来绘制 Android 所有原生和自定义 View 。在 Android 中，Canvas API 通过一个名为 OpenGLRenderer 的绘制库实现硬件加速，该绘制库将 Canvas 运算转换为 OpenGL 运算，以便它们可以在 GPU 上执行。从 Android 4.0 之后开始，强制启用硬件加速。</p><p>OpenGL ES可以直接把要显示的数据渲染到Surface。</p><h3 id="Android图形组件"><a href="#Android图形组件" class="headerlink" title="Android图形组件"></a>Android图形组件</h3><p>无论使用什么方式绘制，最终都会把绘制内容渲染到Surface中。在 Android 平台上创建的每个窗口都由 Surface 提供支持。显示缓冲队列有一个个 Surface 组成，而缓冲队列通常会被 SurfaceFlinger 消耗。所有被渲染的可见 Surface 都被 SurfaceFlinger 合成到显示部分。</p><p><img src="/2018/04/01/Android%E5%9B%BE%E5%BD%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B9%8B%E8%B7%AF/graphics.png" alt="raphic"></p><h5 id="Image-Stream-Producers"><a href="#Image-Stream-Producers" class="headerlink" title="Image Stream Producers"></a>Image Stream Producers</h5><p>图像流生产者， 是生成图形缓冲区以供消耗的任何内容。例如 OpenGL ES、Canvas 2D 和 mediaserver 视频解码器等。</p><h5 id="Image-Stream-Consumers"><a href="#Image-Stream-Consumers" class="headerlink" title="Image Stream Consumers"></a>Image Stream Consumers</h5><p>图像流消费者，最常见的是SurfaceFlinger，该系统服务会消耗当前可见的 Surface，并使用窗口管理器中提供的信息将它们合成到显示部分。SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface。</p><p>其他 OpenGL ES 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流。非 GL 应用也可以是消耗方，例如 ImageReader 类。</p><h5 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h5><p>控制窗口的 Android 系统服务，它是视图容器。窗口总是由 Surface 提供支持。该服务会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、Z-Order 以及窗口的其他许多方面。窗口管理器会将所有窗口元数据发送到 SurfaceFlinger，以便 SurfaceFlinger 可以使用该数据在显示部分合成 Surface。</p><h5 id="Hardware-Composer"><a href="#Hardware-Composer" class="headerlink" title="Hardware Composer"></a>Hardware Composer</h5><p>硬件混合渲染器， SurfaceFlinger 可以将某些Surface的合成工作交给 Hardware Composer， 以分担 OpenGL 和 GPU 上的工作量， 是所有 Android 图形渲染的核心</p><h5 id="Gralloc"><a href="#Gralloc" class="headerlink" title="Gralloc"></a>Gralloc</h5><p>图形内存分配器 (Gralloc) 来分配图像生产方请求的内存。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="/2018/04/01/Android%E5%9B%BE%E5%BD%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B9%8B%E8%B7%AF/graphics_pipeline.png" alt="raphics_pipelin"></p><p>左侧的对象是生成图形缓冲区的渲染器，如主屏幕、状态栏和系统界面。SurfaceFlinger 是合成器，而硬件混合渲染器是制作器。</p><h5 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h5><p>BufferQueues 是 Android 图形组件之间的粘合剂。它们是一对队列，可以调解缓冲区从生产方到消耗方的固定周期。一旦生产方移交其缓冲区，SurfaceFlinger 便会负责将所有内容合成到显示部分。</p><p>BufferQueue 是将缓冲区池与队列相结合的数据结构，它使用 Binder IPC 在进程之间传递缓冲区。BufferQueue 通常用于渲染到 Surface，并且与 GL 消耗方及其他任务一起消耗内容。BufferQueue 可以在三种不同的模式下运行：</p><p>类同步模式 - 默认情况下，BufferQueue 在类同步模式下运行，在该模式下，从生产方进入的每个缓冲区都在消耗方那退出。在此模式下不会舍弃任何缓冲区。如果生产方速度太快，创建缓冲区的速度比消耗缓冲区的速度更快，它将阻塞并等待可用的缓冲区。</p><p>非阻塞模式 - BufferQueue 还可以在非阻塞模式下运行，在此类情况下，它会生成错误，而不是等待缓冲区。在此模式下也不会舍弃缓冲区。这有助于避免可能不了解图形框架的复杂依赖项的应用软件出现潜在死锁现象。</p><p>舍弃模式 - 最后，BufferQueue 可以配置为丢弃旧缓冲区，而不是生成错误或进行等待。例如，如果对纹理视图执行 GL 渲染并尽快绘制，则必须丢弃缓冲区。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 目前通用的两种绘图方式是通过 Android 提供的 2D 绘图 API Canvas 与 OpenGL 两种方式实现。&lt;/p&gt;
&lt;p&gt;Canvas 是一个 2D 图形 API，常用来绘制 Android 所有原生和自定义 View 。在 Android 中，Canvas API 通过一个名为 OpenGLRenderer 的绘制库实现硬件加速，该绘制库将 Canvas 运算转换为 OpenGL 运算，以便它们可以在 GPU 上执行。从 Android 4.0 之后开始，强制启用硬件加速。&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="https://jianglei12138.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android图形架构" scheme="https://jianglei12138.github.io/tags/Android%E5%9B%BE%E5%BD%A2%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Android图形组件" scheme="https://jianglei12138.github.io/tags/Android%E5%9B%BE%E5%BD%A2%E7%BB%84%E4%BB%B6/"/>
    
      <category term="数据流" scheme="https://jianglei12138.github.io/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
  </entry>
  
</feed>
