<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Glide 源码分析</title>
      <link href="/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/02/20/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Android图片加载框架的发展，经历了从最初的ImageLoder到Piasso，Glide，Fresco三足鼎立的过程，其中无论是Picasso还是Glide，他们的共同点都是用起来特别方便，通过链式调用，几乎可以一行代码解决大部分的需求。本文基于Glide最新的版本4.8，对Glide源码做一些简要的分析。<br> <a id="more"></a></p><p>Android图片加载框架的发展，经历了从最初的ImageLoder到Piasso，Glide，Fresco三足鼎立的过程。以下是关于这三个常用框架的一些数据上的对比。</p><table><thead><tr><th align="center"></th><th align="left">Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td align="center">开发者</td><td align="left">square</td><td>bumptech</td><td>facebook</td></tr><tr><td align="center">Star/Issue</td><td align="left">16K+/1400+</td><td>24K+/3100+</td><td>15K+/1900+</td></tr><tr><td align="center">最新版本</td><td align="left">2.71828</td><td>4.8.0</td><td>1.11.0</td></tr></tbody></table><p>从上述表中我们可以看到，Glide相对其他两个有更多的star与issue，本文就简单分析一下Glide的源码。Glide是由<a href="https://github.com/bumptech" target="_blank" rel="noopener">bumptech</a>开发的图片加载框架，也是Google推荐使用的图片加载框架。</p><h2 id="Glide的使用"><a href="#Glide的使用" class="headerlink" title="Glide的使用"></a>Glide的使用</h2><p>除去常用的png，jpg外，Glide还支持 Gif、WebP，甚至是 Video等，当然这些都是建立在一些第三方库的基础上实现的，比如说gifencoder等。</p><p>无论是上文说到的Picasso还是Glide，他们的共同点都是用起来特别方便，通过Glide的链式调用，几乎可以一行代码解决大部分的需求。本文基于Glide最新的版本4.8，相较于Glide 3，Glide 4在一些代码易读性，易写性，可扩展性等方面都有了不错的提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = <span class="keyword">new</span> RequestOptions()</span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE);</span><br><span class="line">        .placeholder(R.drawable.loading);</span><br><span class="line">Glide.with(<span class="keyword">this</span>).load(url).apply(options).into(imageView);</span><br></pre></td></tr></table></figure><h2 id="Glide架构"><a href="#Glide架构" class="headerlink" title="Glide架构"></a>Glide架构</h2><p><img src="/.io//framework.png" alt="framework"><br>如图是我在网上找到的一张关于glide架构图。可以看到Glide相对还是比较复杂的，此次我们只分析其中的部分实现，即Registry与RequestManager，了解一下Glide加载一张图片的大致流程。</p><h2 id="Glide源码分析"><a href="#Glide源码分析" class="headerlink" title="Glide源码分析"></a>Glide源码分析</h2><p>了解过Glide使用后，我们便可以着手分析Glide源码了，后面我们一边结合设计模式，一遍分析Glide的实现。</p><h3 id="1-Glide的初始化"><a href="#1-Glide的初始化" class="headerlink" title="1. Glide的初始化"></a>1. Glide的初始化</h3><p>从Glide源码入手，我们逐层分析Glide是如何创建的，首先从with接口入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever().get(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于with的调用可以简化如上，可以看到通过 <strong>Glide#get</strong>方法获取到Glide实例，那么这个get方法究竟做了些什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Glide glide;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isInitializing;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInitializing) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isInitializing = <span class="keyword">true</span>;</span><br><span class="line">   initializeGlide(context);</span><br><span class="line">    isInitializing = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见创建采用了单例模式，单例模式是我们最长见、最常用的设计模式之一，是一种对象创建型模式。</p><blockquote><p><strong>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</strong></p></blockquote><p>关于单例的实现有很多种优秀的解决方案，所谓青菜萝卜各有所爱，Glide使用了双重检查锁的方案，并且为了防止可能出现的重复创建，使用了布尔变量标识是否初始化完成。此处需要注意的一点是，我们开发过程中常用的单利可能不会传递一个参数Context，如果需要，需要特殊注意对Context的使用，避免不必要的内存泄漏。</p><p>按照惯例，创建Glide实例最终应该由 <strong>initializeGlide</strong> 完成，具体实现如下, 其中关于GlideModule的实现，目前我们只需要知道是用来修改Glide的加载策略以及设置缓存等即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GlideBuilder顾名思义，创建Glide</span></span><br><span class="line">    initializeGlide(context, <span class="keyword">new</span> GlideBuilder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">    Context applicationContext = context.getApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Glide 4支持通过注解AppGlideModule, 由于GlideModule即将废弃，不做介绍</span></span><br><span class="line">    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">        annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">        ? annotationGeneratedModule.getRequestManagerFactory() : <span class="keyword">null</span>;</span><br><span class="line">    builder.setRequestManagerFactory(factory);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">        annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处真正创建glide对象</span></span><br><span class="line">    Glide glide = builder.build(applicationContext);</span><br><span class="line">    <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">        <span class="keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">        annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">    &#125;</span><br><span class="line">    Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来可以看到 <strong>initializeGlide</strong> 只做了两件事情，初始化GeneratedAppGlideModule，并通过GlideBuilder 创建glide。终于我们看到Glide实例的创建，继续跟下去可以看到，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">build</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">      memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.Builder(context).build();</span><br><span class="line">      connectivityMonitorFactory = <span class="keyword">new</span> DefaultConnectivityMonitorFactory();</span><br><span class="line"></span><br><span class="line">      bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">      arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">      memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">      diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line"></span><br><span class="line">      engine =</span><br><span class="line">          <span class="keyword">new</span> Engine(</span><br><span class="line">              memoryCache,</span><br><span class="line">              diskCacheFactory,</span><br><span class="line">              GlideExecutor.newDiskCacheExecutor(),</span><br><span class="line">              GlideExecutor.newSourceExecutor(),</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">              GlideExecutor.newAnimationExecutor(),</span><br><span class="line">              isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultRequestListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaultRequestListeners = Collections.emptyList();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestManagerRetriever requestManagerRetriever =</span><br><span class="line">        <span class="keyword">new</span> RequestManagerRetriever(requestManagerFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptions.lock(),</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        isLoggingRequestOriginsEnabled);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Glide#build</strong>创建了Glide的引擎，bitmp池，内存缓存，磁盘缓冲，加载资源和读取资源的线程池，缓存方式等，关于RequestManagerRetriever的介绍，参见第二节。最终调用Glide的构造函数创建Glide对象。</p><h3 id="2-Registry机制"><a href="#2-Registry机制" class="headerlink" title="2. Registry机制"></a>2. Registry机制</h3><p>Glide构造函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Glide(</span><br><span class="line">    <span class="meta">@NonNull</span> Context context,</span><br><span class="line">    <span class="meta">@NonNull</span> Engine engine,</span><br><span class="line">    <span class="meta">@NonNull</span> MemoryCache memoryCache,</span><br><span class="line">    <span class="meta">@NonNull</span> BitmapPool bitmapPool,</span><br><span class="line">    <span class="meta">@NonNull</span> ArrayPool arrayPool,</span><br><span class="line">    <span class="meta">@NonNull</span> RequestManagerRetriever requestManagerRetriever ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    registry = <span class="keyword">new</span> Registry();</span><br><span class="line">    registry</span><br><span class="line">        .append(ByteBuffer.class, <span class="keyword">new</span> ByteBufferEncoder())</span><br><span class="line">        .append(InputStream.class, <span class="keyword">new</span> StreamEncoder(arrayPool))</span><br><span class="line">        <span class="comment">/* Bitmaps */</span></span><br><span class="line">        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)</span><br><span class="line">        <span class="comment">/* BitmapDrawables */</span></span><br><span class="line">        .append(</span><br><span class="line">        Registry.BUCKET_BITMAP_DRAWABLE,</span><br><span class="line">        ByteBuffer.class,</span><br><span class="line">        BitmapDrawable.class,</span><br><span class="line">        <span class="keyword">new</span> BitmapDrawableDecoder&lt;&gt;(resources, byteBufferBitmapDecoder))</span><br><span class="line">        <span class="comment">/* GIFs */</span></span><br><span class="line">        .append(</span><br><span class="line">        Registry.BUCKET_GIF,</span><br><span class="line">        InputStream.class,</span><br><span class="line">        GifDrawable.class,</span><br><span class="line">        <span class="keyword">new</span> StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool))</span><br><span class="line">        <span class="comment">/* GIF Frames */</span></span><br><span class="line">        .append(</span><br><span class="line">        GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance())</span><br><span class="line">        .append(</span><br><span class="line">        Registry.BUCKET_BITMAP,</span><br><span class="line">        GifDecoder.class,</span><br><span class="line">        Bitmap.class,</span><br><span class="line">        <span class="keyword">new</span> GifFrameResourceDecoder(bitmapPool))</span><br><span class="line">        <span class="comment">/* Drawables */</span></span><br><span class="line">        .append(Uri.class, Drawable.class, resourceDrawableDecoder)</span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(</span><br><span class="line">        Bitmap.class,</span><br><span class="line">        BitmapDrawable.class,</span><br><span class="line">        <span class="keyword">new</span> BitmapDrawableTranscoder(resources));</span><br><span class="line">    ...</span><br><span class="line">    glideContext =</span><br><span class="line">        <span class="keyword">new</span> GlideContext(</span><br><span class="line">        context,</span><br><span class="line">        arrayPool,</span><br><span class="line">        registry,</span><br><span class="line">        <span class="keyword">new</span> ImageViewTargetFactory(),</span><br><span class="line">        defaultRequestOptions,</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        engine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Glide构造函数中注册了大量的Transcoder, Encoder与Decoder（负责一些资源如jpg, svg, video, gif等加载，持久化等），所有的这些操作由一个个独立的模块实现，这些模块由Registry负责管理。Registry是Glide内部实现的模块挂接中心，它建立了功能需求和实现模块之间的映射关系，使这些模块能够根据需求进行灵活的挂载，模块和模块之间又相互独立互不影响，很好地实现了系统功能的解耦。  在Registry内部提供了对如下几种类型模块的挂载支持</p><ul><li>数据加载模块 ModelLoaderRegistry</li><li>存储模块，提供通用的数据持久化功能 EncoderRegistry</li><li>资源解码模块，把各种类型的数据decode成bitmap或者drawable资源 ResourceDecoderRegistry</li><li>资源存储模块，相比EncoderRegistry此只是资源bitmap，drawable等持久化模块 ResourceEncoderRegistry</li><li>数据流重定向模块  DataRewinderRegistry</li><li>数据转换模块，将不同类似的资源转换，如bitmap -&gt; drawable</li><li>图片header解析模块 ImageHeaderParserRegistry</li></ul><p>关于模块间的关系和Glide支持的部分模块可以参考如下UML图，关于ModelLoaderRegistry模块，可以看到支持Okhttp作为网络请求或者你可以自定义任意的网络请求工具，只要实现ModelLoaderFactory接口即可，甚至，对于所有的模块，如果不能够满足你的需求，完全可以自定义属于自己的模块。</p><p><img src="/.io//registry.jpg" alt="registry"></p><p>这里，其实就有那么一点点策略模式的味道了。结合UML类图可以看到，对于任意的模块，其具体实现类就是具体的策略，将接口的定义与具体模块实现策略分开，符合“依赖倒转原则”。在有新的比如说endcoder时，只需要增加一个新的实现了Encoder具体策略类即可。</p><blockquote><p><strong>策略模式：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。策略模式是一种对象行为型模式。</strong></p></blockquote><p>至此，Glide初始化完毕。</p><h3 id="3-RequestManager的创建"><a href="#3-RequestManager的创建" class="headerlink" title="3. RequestManager的创建"></a>3. RequestManager的创建</h3><p>Glide的所有一切以with开始，into结束，with支持context, activity, view, fragment参数等，Glide正是使用此，来完成基本的初始化与调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever().get(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getRequestManagerRetriever得到的对象其实就是在初始化Glide的时候构造函数传入的，由GlideBuilder创建的RequestManagerRetriever，RequestManagerRetriever提供了一系列静态方法用来创建RequestManager或者直接从Actiivty或者fragment取得已经创建的RequestManager，关于如何获取，见get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你有去翻<strong>RequestManagerRetriever#get</strong>实现，你会发现get方法有很多重载函数，但无一例外，所有的get函数最开始都有关于当前线程的检测，为什么要去检测是否则主线程？后面会有简单的注释。另外我们需要了解一个事实是：</p><blockquote><p>Glide实现中图片的加载任务会与activity或者Fragment的生命周期绑定，当界面执行onStop的使用自动暂停，而当执行onStart的时候又会自动重新开启，同样的，动态Gif图的加载也是如此，以用来节省电量，同时Glide会对网络状态做监听，当网络状态发生改变时，会重启失败的任务，以减少任务因网络连接问题而失败的概率。</p></blockquote><p>既然如此新的问题就产生了，Glide是如何把Activity/Fragment的生命周期与自己绑定的呢？我们继续看刚才的代码寻找答案，get函数如果检测到是主线程，最终会调用如下的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            DEFAULT_FACTORY.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull <span class="keyword">final</span> android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">        current.setParentFragmentHint(parentHint);</span><br><span class="line">        <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">            current.getGlideLifecycle().onStart();</span><br><span class="line">        &#125;</span><br><span class="line">        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerFactory DEFAULT_FACTORY = <span class="keyword">new</span> RequestManagerFactory() &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">build</span><span class="params">(@NonNull Glide glide, @NonNull Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestManager(glide, lifecycle, requestManagerTreeNode, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>RequestManagerRetriever#fragmentGet</strong>会先去查找TAG为FRAGMENT_TAG的 fragment，如果没有找到，会自己创建一个SupportRequestManagerFragment，这个SupportRequestManagerFragment是什么东西？翻下代码你就会发现这竟然是个Fragment！不难大胆猜测，Glide与Lifecycle组件一样，塞了一个空白的Fragment来监听生命周期的回调！</p><p>紧接着，就是RequestManager的创建，通过DEFAULT_FACTORY对象的build函数实现，下面看RequestManager的构造函数的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">    <span class="keyword">this</span>.glide = glide;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">    <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're the application level request manager, we may be created on a background thread.</span></span><br><span class="line">    <span class="comment">// In that case we cannot risk synchronously pausing or resuming requests, so we hack around the</span></span><br><span class="line">    <span class="comment">// issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.</span></span><br><span class="line">    <span class="comment">// This should be entirely safe.</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        mainHandler.post(addSelfToLifecycle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    glide.registerRequestManager(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个lifecycle是什么？是通过SupportRequestManagerFragment中getGlideLifecycle取得，具体来说是ActivityFragmentLifecycle对象，ActivityFragmentLifecycle维护了一份注册的生命周期回调Set，当空白fragment生命周期发生改变，会去调用ActivityFragmentLifecycle相应的接口，再去遍历相应我们注册的回调Set，比如说RequestManager！至此，豁然开朗，一切和我们预料的相同。优秀！</p><p>另外我们也可以看到注释中关于为什么使用主线程的判断原因，如果我们直接在Application中调用创建了RequestManager可能会有同步的风险，导致生命周期混乱！👏👏👏</p><h3 id="4-RequestBuilder创建"><a href="#4-RequestBuilder创建" class="headerlink" title="4. RequestBuilder创建"></a>4. RequestBuilder创建</h3><p>RequestManager对象创建完成，既可以研究一下load的实现啦，同样load接口也有大量的重载，那从我们我们常用的  load(Drawable) 入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(drawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load操作先通过as接口把需要加载的对象封装成了RequestBuilder，最终把load的任务交给了RequestBuilder实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(drawable)</span><br><span class="line">        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关于磁盘缓冲的处理也是一个典型的策略模式的实现。load最终实现也只是给成员变量赋值，RequestBuilder的所有提供给应用使用的接口，大部分实现也都是设置成员变量等，无真正逻辑的处理。但是其中的链式调用不仅让我们想起设计模式中的建造者模式，创建者模式是备受开发者创建复杂对象时青睐的一种设计模式。而其中链式调用一般也是我们常用的实现创建者模式的一种手段。</p><blockquote><p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式</strong></p></blockquote><p>这样，我们就创建好了一个RequestBuilder对象.</p><h3 id="5-Request构建"><a href="#5-Request构建" class="headerlink" title="5. Request构建"></a>5. Request构建</h3><p>万事具备，只差如何把资源得到并显示了，这里就不得不说RequestBuilder中的into方法，如下是into的部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        <span class="comment">// 简化了部分代码，对于在创建RequestBuilder传入的Drawable.class，此处会创建DrawableImageViewTarget</span></span><br><span class="line">        <span class="keyword">new</span> DrawableImageViewTarget(view),</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">  @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">  RequestOptions options)</span> </span>&#123;    </span><br><span class="line">    Request request = buildRequest(target, targetListener, options);</span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">...</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终的部分需要创建 buildRequest，那么这个buildRequest究竟做了什么？通过阅读源码我们发现buildRequest只是简单的调用buildRequestRecursive函数，那就具体分析buildRequestRecursive</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span></span><br><span class="line">    ErrorRequestCoordinator errorRequestCoordinator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (errorBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        errorRequestCoordinator = <span class="keyword">new</span> ErrorRequestCoordinator(parentCoordinator);</span><br><span class="line">        parentCoordinator = errorRequestCoordinator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩略图或者原图Request</span></span><br><span class="line">    Request mainRequest =</span><br><span class="line">        buildThumbnailRequestRecursive(</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        parentCoordinator,</span><br><span class="line">        transitionOptions,</span><br><span class="line">        priority,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight,</span><br><span class="line">        requestOptions,</span><br><span class="line">        callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errorRequestCoordinator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mainRequest;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    Request errorRequest =</span><br><span class="line">        errorBuilder.buildRequestRecursive(</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        errorRequestCoordinator,</span><br><span class="line">        errorBuilder.transitionOptions,</span><br><span class="line">        errorBuilder.getPriority(),</span><br><span class="line">        errorOverrideWidth,</span><br><span class="line">        errorOverrideHeight,</span><br><span class="line">        errorBuilder,</span><br><span class="line">        callbackExecutor);</span><br><span class="line">    errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class="line">    <span class="keyword">return</span> errorRequestCoordinator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果检测到如果除了目标图片外，我们还自己配置了显示的错误图片，或缩略图显示，那么这时候会创建一个请求协调器，来协调各类型图片间的请求顺序。</p><ul><li>在构建协调器后，会将目标图片请求和错误图片请求设置给协调器。</li><li>一旦请求开始工作，就会启动目标图片请求。</li><li>当目标图片请求失败时，就会启动错误图片请求。</li></ul><p>buildThumbnailRequestRecursive中除了创建缩略图外，还有可能会去加载原图。此处为了简化分析，我们只看加载原题的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingleRequest.obtain(</span><br><span class="line">        context,</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        requestOptions,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight,</span><br><span class="line">        priority,</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        requestListeners,</span><br><span class="line">        requestCoordinator,</span><br><span class="line">        glideContext.getEngine(),</span><br><span class="line">        transitionOptions.getTransitionFactory(),</span><br><span class="line">        callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原图的加载完全交给了SingleRequest实现。我们回到刚才into方法中，可以看到在做了必要的准备后，我们最终回到<strong>RequestManager#track</strong>方法，将此次请求放到RequestManager的请求队列中，同时检测当前生命周期是否已经暂停，否则直接发起加载请求，对此，是发起了一次SingleRequest请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track</span><span class="params">(Target&lt;?&gt; target, Request request)</span> </span>&#123;</span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RequestTracker#runRequest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-资源加载"><a href="#6-资源加载" class="headerlink" title="6. 资源加载"></a>6. 资源加载</h3><p>由以上分析我们得知，最终加载图片是交代给SingleRequest来实现的，具体源码如下，除了设置当前的状态外，最重要的莫过于onSizeReady接口了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">        onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        requestOptions.getSignature(),</span><br><span class="line">        <span class="keyword">this</span>.width,</span><br><span class="line">        <span class="keyword">this</span>.height,</span><br><span class="line">        requestOptions.getResourceClass(),</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        requestOptions.getDiskCacheStrategy(),</span><br><span class="line">        requestOptions.getTransformations(),</span><br><span class="line">        requestOptions.isTransformationRequired(),</span><br><span class="line">        requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">        requestOptions.getOptions(),</span><br><span class="line">        requestOptions.isMemoryCacheable(),</span><br><span class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">        requestOptions.getUseAnimationPool(),</span><br><span class="line">        requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        callbackExecutor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onSizeReady则通过Glide的引擎，真正的去加载资源。关于Glide的引擎，我们并没有做过多的介绍，其负责任务创建，发起，回调，资源的管理等，此处简单分析load的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1:创建资源索引key</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">                                        resourceClass, transcodeClass, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2:从内存中当前正在显示的资源缓存加载图片</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3:从内存缓存资源中加载图片</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4:获取已经存在的加载任务</span></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current.addCallback(cb);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5:新建加载任务，用于启动解码任务</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">        key,</span><br><span class="line">        isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool,</span><br><span class="line">        useAnimationPool,</span><br><span class="line">        onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6:新建解码任务，真正执行数据加载和解码的类</span></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        key,</span><br><span class="line">        signature,</span><br><span class="line">        width,</span><br><span class="line">        height,</span><br><span class="line">        resourceClass,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        diskCacheStrategy,</span><br><span class="line">        transformations,</span><br><span class="line">        isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform,</span><br><span class="line">        onlyRetrieveFromCache,</span><br><span class="line">        options,</span><br><span class="line">        engineJob);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7:缓存加载任务</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8:开启解码任务</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们真正开启了资源的加载过程，引擎中的load会根据当前内存是否存在此资源进行相应的加载，否则再去请求本地磁盘或者网络等，此请求任务则交给Registry中已经注册的ModelLoader来完成，见第二节Registry。</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Glide </tag>
            
            <tag> 图像加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android渲染机制</title>
      <link href="/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/10/01/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。</p> <a id="more"></a><h1 id="Android渲染机制"><a href="#Android渲染机制" class="headerlink" title="Android渲染机制"></a>Android渲染机制</h1><p>关于Android中的视图，我一直有些疑问，Android中Activity是怎么加载视图的？View是怎么绘制的? 普通View与SurfaceView的到底有什么异同，如何去优化View的显示等，现在就让我们从Activity创建说起，一探Android渲染机制。</p><h2 id="从Activity-setContentView说起"><a href="#从Activity-setContentView说起" class="headerlink" title="从Activity#setContentView说起"></a>从Activity#setContentView说起</h2><p>一般创建应用时，Activity是承载我们视图的首要选择。为了能够正常显示视图，我们一般会通过调用 <code>Activity#setContentView</code> 方法来进行加载。但是，这个方法究竟调用了什么方法实现真正展现视图的？又是如何现实的呢？从源码最终我们能看到，<code>setContentView</code> 最终的实现位于  <strong>PhoneWindow</strong> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mContentParent是PhoneWindow内容的根布局，首先检测mContentParent</span></span><br><span class="line">    <span class="comment">// 创建或者不空移除子View，防止重复的调用setContentView</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scene是Kitkat引入的场景API, 可以通过Transition来实现带有动画的场景切换</span></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// inflater对应的view attach到mContentParent中</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所使用的View最终都会被添加到mContentParent中，mContentParent究竟是一个什么样的ViewGroup呢？首先看一下mContentParent的创建与初始化，其初始化代码位于installDecor中，由于代码量比较多，此处只摘取部分重要内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 创建Decor</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处可以简化为 new DecorView()</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由Decor创建mContentParent</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDecorContentParent = decorContentParent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处callback是指后面的Activity传入的callback，详情见后面分析</span></span><br><span class="line">            mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">            <span class="keyword">if</span> (mDecorContentParent.getTitle() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> localFeatures = getLocalFeatures();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((localFeatures &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mTitleView = findViewById(R.id.title);</span><br><span class="line">            <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                    <span class="keyword">if</span> (titleContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        titleContainer.setVisibility(View.GONE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mTitleView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mContentParent.setForeground(<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTitleView.setText(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDecor.getBackground() == <span class="keyword">null</span> &amp;&amp; mBackgroundFallbackResource != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面述代码，我们能够了解以下几个事实</p><ul><li>创建mDecor，mDecor的创建过程比较简单，通过直接实例化DecorView</li><li>通过generateLayout创建mContentParent</li><li>创建mContentParent后会去找到DecorContentParent/TitleView，然后对UI进行修改</li></ul><p>那么generateLayout究竟是怎么实现的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略解析设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inflate the window decor.</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">// System.out.println("Features: 0x" + Integer.toHexString(features));</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        <span class="comment">// System.out.println("Title Icons!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with only a progress bar (and title).</span></span><br><span class="line">        <span class="comment">// XXX Need to have a no-title version of embedded windows.</span></span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">        <span class="comment">// System.out.println("Progress!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with a custom title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogCustomTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no other features and not embedded, only need a title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("Title!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println("Simple!");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处把上述的layout inflater之后添加到mDecorView中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mContentParent即mDecor的子View ID为ID_ANDROID_CONTENT(com.android.internal.R.id.content)</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ProgressBar progress = getCircularProgressBar(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (progress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            progress.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侧滑退出Activity实现</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        registerSwipeCallbacks(contentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generateLayout方法就是根据mLocalFeatures寻找到对应的layout。这些layout位置位于frameworks/base/core/res/res/layout/目录下。这些所有的layout都有一个id为 <strong>com.android.internal.R.id.content</strong> 的FrameLayout，而这个FrameLayout就是放置我们自定义布局ContentView的mContentParent，也就是我们Acitivity所传递过来的View最终都都会被添加到这个FrameLayout中</p><p><img src="/.io//content_layout.png" alt="content_layout"></p><p><strong>本节知识点</strong></p><ol><li>Scene结合Transiation实现场景动画切换 <a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">Android Transition Framework</a></li><li>最简单实现侧滑退出Activity requestWindowFeature使用 <strong>PhoneWindow#requestFeature</strong></li></ol><h2 id="DecorView是什么？"><a href="#DecorView是什么？" class="headerlink" title="DecorView是什么？"></a>DecorView是什么？</h2><p>经过上面的分析，我们知道DecorView是PhoneWindow的独有ViewGroup，也是承载我们Acitiviy视图的RootView，DecorView是FrameLayout子类。到目前为止我们能可以看到一个普通Activity大致的布局如下。</p><p><img src="/.io//decor_view.png" alt="Activity层级"></p><p>其中：</p><ol><li>DecorView是Activity的RootView，其他所有View都是其直接或者间接子View</li><li>decor_content_parent即上述分析的DecorContentParent，包括常用的ActionBar/Toolbar和我们自己添加的View</li><li>navigationBarBackground与statusBarBackground两个View只是为了占用空间，预留给状态栏和导航栏使用，具体的实现位于 <strong>PhoneStatusBarView</strong></li></ol><p><strong>本节知识点</strong></p><ol><li>Android里阴影实现的一种方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initShadowPaints</span><span class="params">(Paint shadowPaint, <span class="keyword">int</span> shadowSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startColor  = <span class="number">0x2a000000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> endColor    = <span class="number">0x00000000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> middleColor = (startColor + endColor) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    shadowPaint.setShader(</span><br><span class="line">            <span class="keyword">new</span> LinearGradient(</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, shadowSize,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;startColor, middleColor, endColor&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0f</span>, <span class="number">0.3f</span>, <span class="number">1f</span>&#125;, Shader.TileMode.CLAMP</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View是什么时候显示的？"><a href="#View是什么时候显示的？" class="headerlink" title="View是什么时候显示的？"></a>View是什么时候显示的？</h2><p>DecorView是我们Activity的根布局，那么他又是怎么显示出来的呢？如果看过ActivityThread源码的话，就会知道在 <strong>ActivityThread#performLaunchActivity</strong> 中创建Activity之后，便会调用 <strong>Activity#attach</strong> 方法。<br>完成此方法调用后，ActivityThread会调用 <strong>Activity#performCreate</strong> 进而调用 <strong>Activity#onCreate</strong> 之后就是我们上述分析的setContentView流程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, Window window,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处callback的接口定义见下方列举的内容</span></span><br><span class="line">    <span class="comment">// 除了一些关于触摸相关的Activity有对应的实现外</span></span><br><span class="line">    <span class="comment">// 其他Activity中都是空实现</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Thread</span></span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// ActivityThread 此处并不是一个Thread</span></span><br><span class="line">    <span class="comment">// 主线程并不是一个线程</span></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处会调用PhoneWindow父类中的setWindowManager方法</span></span><br><span class="line">    <span class="comment">// 最终获得一个WindowManagerImpl实例</span></span><br><span class="line">    <span class="comment">// 此实例中保存了一个PhoneWindow的属性</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mParent也是Activity，具体使用见知识点</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此mWindowManager如上包含一个PhoneWindow的引用</span></span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window.Callback部分接口列举</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyShortcutEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTrackballEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchGenericMotionEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowAttributesChanged</span><span class="params">(WindowManager.LayoutParams attrs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContentChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，我们建立了 <strong>Activity</strong> <strong>PhoneWindow</strong> <strong>WindowManager</strong> 的三者之间的联系，简单的用下图表示。总结来说</p><ol><li>Activity中持有WindowManager与Window的引用，Window通过直接new PhoneWindow得到，WindowManager通过Window提供的接口取得</li><li>PhoneWindow中有一系列的成员变量，一般是各种回调，是通过Activity直接设置过来的，都是Activity相同实例。然后Activity通过Window的方法实现初始化Window中的成员变量WindowManager</li><li>WindowManager通过上述方法，在创建Window成员变量WindowManager的同时，把Window设置给WindowManager实现双向关联</li></ol><p><img src="/.io//activity_window_windowmanager.jpg" alt="Activity-Window-WindowManager"></p><p>在说剩下的之前，我们要先了解一个既定的事实，View只有被add到WindowManager中才能正常的显示到屏幕上，那么View究竟是怎么被添加到WindowManager中的呢？onCreate之后只是把View添加到DecorView的一个子View中，并没有显示的操作。通过阅读Activity源码中的注释我们知道，在onStart之后，View才被真正的显示出来。</p><blockquote><p>Activity#onStart Called when the activity is becoming visible to the user.</p></blockquote><p>大胆猜想，DecorView是在onStart后，onResume前被添加到WindowManager。继续跟ActivityThread中的源码，<strong>ActivityThread#handleResumeActivity -&gt; ActivityThread#performResumeActivity -&gt; Activity#performResume -&gt; Activity#onResume</strong> 看下来你会发现根本没有DecorView的操作，甚至连Window都没有。也就是说在onResume之前，View都是不可见的？其实注释中也是说Activity可见，并没有说明View可见。功夫不负有心人，最终我们在ActivityThread中找到了这部分的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终调用onResume</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 隐藏DecorView</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        <span class="comment">// Activity的TYPE为TYPE_BASE_APPLICATION</span></span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 把DecorView添加到WindowManager中，此时View并不可见，前面有隐藏</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="comment">// 使View可见</span></span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity#makeVisible</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完View的显示时机，我们禁想到一个问题，那就是Activity中的一些明显View的生命周期中的回调，如上述Callback中一些接口的实现，是不是在DecorView中回调的呢。带着这样的疑问，我们先看下Callback到底被设置到了哪里</p><ol><li>Activity在创建PhoneWindow后，通过调用 <strong>Window#setCallback</strong> 方法传递给PhoneWindow， 并且Window提供了 <strong>Window#getCallback</strong> 方法</li><li>setContentView后在PhoneWindow中创建mContentParent后，调用 <strong>DecorContentParent#setWindowCallback</strong></li><li>DecorContentParent是一个接口，具体实现在ActionBarView</li></ol><p>找到所有相关联的类，就能很简单的找到对应的调用，ActionBarView与PhoneWindow，通过callback控制Menu相关的情况。其他的方法，正如我们所料，都是在DecorView被回调，即Activity中所有的有关触摸，按键，onAttachedToWindow与onDetachedFromWindow等都是在DecorView中调用的。</p><p><strong>本节知识点</strong></p><ol><li>Activity中的parent属性，<a href="https://blog.csdn.net/simplebam/article/details/79381754" target="_blank" rel="noopener">android:parentActivityName使用</a></li><li>UML图的使用</li><li>ActivityThread的大致套路</li><li>View真正显示时机</li><li>Activity中CallBack接口的回调时机</li></ol><h2 id="View是如何显示出来的？"><a href="#View是如何显示出来的？" class="headerlink" title="View是如何显示出来的？"></a>View是如何显示出来的？</h2><p>以上分析我们基于这样一个事实，那就是 <strong>“View只要被添加到WindowManager中，才能被正常显示”</strong>，那这个只要add后就能显示的神奇操作是怎么实现的呢？从以上分析我们得知，DecorView通过addView添加到WindowManager中，那么这个WindowManager是如何创建的呢，在attach中通过 <strong>context.getSystemService(Context.WINDOW_SERVICE)</strong> 创建了WindowManager，并设置到PhoneWindow中。一如往常使用getSystemService获得对应的实例。但是不同的是调用getSystemService时使用的context是从ActivityThread直接传递过来的。最终由ActivityThread#createBaseContextForActivity创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContextImpl <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> displayId;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            <span class="keyword">this</span>, r.packageInfo, r.activityInfo, </span><br><span class="line">            r.token, displayId, r.overrideConfig);</span><br><span class="line">    <span class="keyword">return</span> appContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现我们得到此getSystemService实现位于 <strong>ContextImpl#getSystemService</strong>，直接调用    <strong>SystemServiceRegistry.getSystemService</strong> 获取对应的Service。SystemServiceRegistry存放了一个SYSTEM_SERVICE_FETCHERS静态HashMap，存放所有的SystemService，我们能拿到的所有Service都是从此处创建获取。我们使用的WINDOW_SERVICE具体实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接new WindowManagerImpl</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx);</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>WindowManager创建时，会初始化一个成员变量WindowManagerGlobal，此类为单例类，之后的所有addView，updateViewLayout，removeView都是借助WindowManagerGlobal实现。一个进程中每次调用getSystemService都会创建一个WindowManager实例，但是所有的操作都是委托给同一个WindowManagerGlobal实现。具体添加一个View的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// 如果有父Window，再添加子View的时候需要适当的对父Window做适当的调整</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                            mRoots.get(i).loadSystemProperties();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 系统属性发生修改的回调</span></span><br><span class="line">            SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 之前removeView还未完成</span></span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前添加的View TYPE为SUB_WINDOW, 则需要确认父WINDOW</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ViewRootImpl，并把所有的操作委托给ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新View LayoutParam</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是addView，updateViewLayout还是removeView都是在WindowManagerGlobal封装好一层，交给ViewRootImpl去处理。</p><p><img src="/.io//widowmanagerglobal.png" alt="WindowManagerGlobal窗口管理"></p><p><strong>本节知识点</strong></p><ol><li>使用WindowManagerGlobal可以拿到当前进程任何地方获取所有的View</li><li>系统属性修改回调 <strong>SystemProperties#addChangeCallback</strong></li></ol><h2 id="ViewRootImpl是什么？"><a href="#ViewRootImpl是什么？" class="headerlink" title="ViewRootImpl是什么？"></a>ViewRootImpl是什么？</h2><p>从上面我们了解到所有的视图操作都是交给ViewRootImpl去处理的，那么这个ViewRootImpl到底是什么呢？我们看下构造函数的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从WindowManagerGlobal中获取一个IWindowSession的实例</span></span><br><span class="line">    <span class="comment">// 它是ViewRootImpl和WindowManagerService进行通信的代理</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WindowLeaked实例，如果Window未正常释放，会抛出此异常</span></span><br><span class="line">    <span class="comment">// 异常在WindowManagerGlobal抛出，此处只负责创建</span></span><br><span class="line">    mLocation = <span class="keyword">new</span> WindowLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// W类是ViewRootImpl的内部类，继承于IWindow.Stub，会接收来自WMS的回调</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 每一个View都需要依赖于具体的窗口才能显示，View与窗口的关系则是放在View.AttachInfo中</span></span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>,</span><br><span class="line">            context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助功能回调</span></span><br><span class="line">    mAccessibilityManager = AccessibilityManager.getInstance(context);</span><br><span class="line">    mAccessibilityManager.addAccessibilityStateChangeListener(</span><br><span class="line">            mAccessibilityInteractionConnectionManager, mHandler);</span><br><span class="line">    mHighContrastTextManager = <span class="keyword">new</span> HighContrastTextManager();</span><br><span class="line">    mAccessibilityManager.addHighTextContrastStateChangeListener(</span><br><span class="line">            mHighContrastTextManager, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewConfiguration这个类主要定义了UI中所使用到的标准常量</span></span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是一个未经任何处理的事件处理场所</span></span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个mChoreographer，接收底层的Vsync信号重绘</span></span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line"></span><br><span class="line">    mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line"></span><br><span class="line">    loadSystemProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewRootImpl构造函数中创建了大量的重要对象外，在成员变量定义时也创建了几个相对比较重要的成员变量</p><ol><li>mHander，从名称上看此处应该是一个Handler，具体定义位于 ViewRootImpl.ViewRootHandler，用于将某些应在主线程的操作放到主线程中执行，一般这些操作来自于WMS</li><li>mSurface，一个空的Surface</li></ol><p><strong>本节知识点</strong></p><ol><li>ViewConfiguration中获取一些View相关</li></ol><p>在看ViewRootImpl的具体实现之前，需要有一些预备知识。</p><h3 id="Surface是什么？"><a href="#Surface是什么？" class="headerlink" title="Surface是什么？"></a>Surface是什么？</h3><p>Android官方文档中是这样描述Surface</p><blockquote><p>Handle onto a raw buffer that is being managed by the screen compositor.<br>A Surface is generally created by or from a consumer of image buffers (such as a SurfaceTexture, MediaRecorder, or Allocation), and is handed to some kind of producer (such as OpenGL, MediaPlayer, or CameraDevice) to draw into.</p></blockquote><p>这个描述可以知道：Surface是用来管理一个raw buffer类，Surface本身是由screen compositor来管理的。但是raw buffer具体是什么，screen compositor又是什么，Surface是如何管理一个raw buffer，而它又是怎样被compositor来管理，后续我们会具体来分析。Surface是我们绘制的基础。</p><p>从上面我们可以看到，ViewRootImpl在初始化的时候创建了一个Surface对象，通过调用其默认构造函数，默认构造函数中无任何的实现代码，目前我们那到的仍然是一个内容为空的对象。Surface主要代码不在java层，主要的实现位于Native。那么究竟是在哪里创建的呢？从后面的代码中，在我们可以在relayoutWindow函数中发现通过调用 <strong>IWindowSession#relayout</strong> 最终把Surface传递给WMS，即应用程序进程的Surface创建过程是由WMS服务来完成，WMS服务通过Binder跨进程方式将创建好Surface返回给应用程序进程，Binder相关内容在此不表。</p><p><strong>IWindowSession#relayout</strong> 的具体实现位于 <strong>Session#relayout</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        MergedConfiguration mergedConfiguration, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mService即WindowManagerService即WMS</span></span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看WMS中关于relayoutWindow中关于Surface的实现主要是调用   <strong>WindowManagerService#createSurfaceControl</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowSurfaceController surfaceController = </span><br><span class="line">        winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见Surface主要通过 <strong>WindowSurfaceController#getSurface</strong> 获得，WindowSurfaceController则通过 <strong>WindowStateAnimator#createSurfaceLocked</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">(<span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.setHasSurface(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>, windowType, ownerUid);</span><br><span class="line"></span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是对直接new做了封装，WindowSurfaceController的构造函数中初始化SurfaceControl，嗯哼，出现我们常见的一个类。常用截图接口 <strong>SurfaceControl#screenshot</strong>，后面就不得不看native代码了，SurfaceControl构造函数中主要调用nativeCreate方法。</p><p>nativeCreate实现位于 <strong>android_view_SurfaceControl.cpp#nativeCreate</strong> 中，具体如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint windowType, jint ownerUid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传递过来的sessionObj取得native层的SurfaceComposerClient</span></span><br><span class="line">    <span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">client</span><span class="params">(android_view_SurfaceSession_getClient(env, sessionObj)</span>)</span>;</span><br><span class="line">    SurfaceControl *parent = reinterpret_cast&lt;SurfaceControl*&gt;(parentObject);</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    status_t err = client-&gt;createSurfaceChecked(</span><br><span class="line">            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);</span><br><span class="line">    <span class="keyword">if</span> (err == NAME_NOT_FOUND) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        jniThrowException(env, OutOfResourcesException, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <strong>SurfaceComposerClient#createSurfaceChecked</strong> 创建了对应的SurafceControl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceComposerClient::createSurfaceChecked(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        sp&lt;SurfaceControl&gt;* outSurface,</span><br><span class="line">        uint32_t flags,</span><br><span class="line">        SurfaceControl* parent,</span><br><span class="line">        int32_t windowType,</span><br><span class="line">        int32_t ownerUid)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    status_t err = mStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != nullptr) &#123;</span><br><span class="line">            parentHandle = parent-&gt;getHandle();</span><br><span class="line">        &#125;</span><br><span class="line">        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,</span><br><span class="line">                windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="keyword">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mClient 即 ISurfaceComposerClient， 此处为跨进程调用，最终实现位于 <strong>SurfaceFlinger#Client.cpp</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">status_t Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    class MessageCreateLayer : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        status_t result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        uint32_t w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">status_t <span class="title">getResult</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function">virtual bool <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用SurfaceFlinger#createLayer</span></span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> static_cast&lt;MessageCreateLayer*&gt;(msg.get())-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终调用的方法是 <strong>SurfaceFlinger#createLayer</strong> 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceFlinger::createLayer(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        int32_t windowType, int32_t ownerUid, sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    String8 uniqueName = getUniqueLayerName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此flags由</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createBufferLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:</span><br><span class="line">            result = createColorLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags,</span><br><span class="line">                    handle, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// window type is WINDOW_TYPE_DONT_SCREENSHOT from SurfaceControl.java</span></span><br><span class="line">    <span class="comment">// TODO b/64227542</span></span><br><span class="line">    <span class="keyword">if</span> (windowType == <span class="number">441731</span>) &#123;</span><br><span class="line">        windowType = <span class="number">2024</span>; <span class="comment">// TYPE_NAVIGATION_BAR_PANEL</span></span><br><span class="line">        layer-&gt;setPrimaryDisplayOnly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    layer-&gt;setInfo(windowType, ownerUid);</span><br><span class="line"></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer, *parent);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;saveSurfaceCreation(layer);</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续不需要再深入，留待以后讲SurfaceFlinger后再深入了解。目前我们知道最终通过SurfaceFlinger创建Layer，并把Layer的代理对象, gdp就是图像缓冲区代理对象 返回给SurfaceComposerClient方便创建SurfaceControl。</p><p>到目前为止，我们得到了native的SurfaceControl，所有对象已经准备完毕，上文说道，最终  <strong>WindowSurfaceController#getSurface</strong> 获取Surface对象内容，大胆的猜测，此方法最终返回的其实是SurfaceFlinger创建的这块layer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WindowSurfaceController#getSurface</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Surface#copyFrom</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"other must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    <span class="keyword">if</span> (surfaceControlPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</span><br><span class="line">                <span class="string">"null SurfaceControl native object. Are you using a released SurfaceControl?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就是通过jni调用把使用SurfaceControl来填充Surface</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceControl#getSurface</span></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateSurfaceLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    <span class="comment">// mGraphicBufferProducer即上文提到的dgp，图像缓冲区代理对象</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//surface.png" alt="Surface的创建"></p><p>总结一下Surface的创建过程：</p><ol><li>每一个Window都有且只有一个ViewRootImpl对象，在该对象中会创建一个java层的内容为空的Surface；</li><li>当应用程序向WMS服务请求relayout Window，WMS服务在WMS进程创建一个SurfaceController</li><li>WMS服务在创建SurfaceController过程中，在自身进程空间创建一个java层的SurfaceControl对象，SurfaceControl创建时会调用jni创建native的SurfaceControl对象。具体实现 <strong>SurfaceComposerClient#createSurfaceChecked</strong> </li><li>SurfaceComposerClient通过Binder调用请求<strong>SurfaceFlinger#createLayer</strong>在它的进程空间为当前创建的Surface创建对应的Layer对象，并向WMS返回IGraphicBufferProducer代理对象。SurfaceComposerClient通过此代理对象创建native的SurfaceControl。</li><li>WMS服务在再通过 <strong>SurfaceController.getSurface</strong> 使用SurfaceControl填充我们需要的Surface</li></ol><p><strong>其他总结</strong></p><ol><li><strong>SurfaceControl#screenshot</strong> 使用</li><li>跨进程调用的实现，使用</li><li>JNI静态注册，动态注册，基本使用</li><li>SurfaceFlinger的基本功能</li></ol><h3 id="Choreographer是什么？"><a href="#Choreographer是什么？" class="headerlink" title="Choreographer是什么？"></a>Choreographer是什么？</h3><p>Android系统加入Choreographer这个类的目的来处理输入(Input)、动画(Animation)、绘制(Draw)三个操作。Choreographer接收显示系统底层传上来的垂直同步信号(VSync信号)，在下一个帧渲染时控制执行这些操作。</p><p> <strong>理想状态下的choreographer</strong><br><img src="/images/placeholder.png" alt="理想状态下的choreographer" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/choreographer.png" class="lazyload"></p><p> <strong>丢帧状态下的choreographer</strong><br><img src="/images/placeholder.png" alt="丢帧状态下的choreographer" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/choreographer_jank.png" class="lazyload"></p><p>Choreographer的基本原理如此，下面看下怎么实现的。Choreographer使用ThreadLocal保存Choreographer实例，保证每个Thread只存在一个Choreographer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Looper looper = Looper.myLooper();</span><br><span class="line">            <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Input callback.  Runs first.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Animation callback.  Runs before traversals.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Traversal callback.  Handles layout and draw.  </span></span><br><span class="line"><span class="comment">// Runs after all other asynchronous messages have been handled.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback type: Commit callback.  Handles post-draw operations for the frame.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_COMMIT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">FrameInfo mFrameInfo = <span class="keyword">new</span> FrameInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个线程对应一个Looper，每个线程对应一个Choreographer</span></span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同type初始化不同CallbackQueue，共4中如上</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上功能有</p><ol><li>初始化FrameHandler，接收处理消息。使用Handler的原因是保证所有的操作都是在同一个线程实现的</li><li>初始化FrameDisplayEventReceiver，FrameDisplayEventReceiver用来接收垂直同步信号。FrameDisplayEventReceiver继承于DisplayEventReceiver。当垂直同步信号过来后会回调 <strong>DisplayEventReceiver#dispatchVsync</strong> 方法，最终调用到onVsync方法</li><li>初始化mLastFrameTimeNanos(上一个frame的渲染时间)以及mFrameIntervalNanos(帧率,fps，一般手机上为1s/60)。</li><li>初始化了大小为4的CallbackQueue</li><li>初始化mFrameInfo用来保存当前帧的信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called when a vertical sync pulse is received.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否丢帧</span></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                + <span class="string">"one at a time."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules a single vertical sync pulse to be delivered when the next</span></span><br><span class="line"><span class="comment">// display frame begins.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Choreographer对外提供了postCallback与postFrameCallback，最终这两个方法调用的都是同一个方法 <strong>Choreographer#postCallbackDelayedInternal</strong> ，postFrameCallback的TYPE为CALLBACK_ANIMATION</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delayMillis为0， 直接调用scheduleFrameLocked等待下一次Vsync到来</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中postCallback的具体流程如下。</p><p><img src="/images/placeholder.png" alt="choreographer机制" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/choreographer_process.png" class="lazyload"></p><p>doFrame中做了些什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从不同的Queue中取出对应的Runnable执行，会取空队列</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本节知识点</strong></p><ol><li>获取设备刷新率，私有方法 <strong>Choreographer##getRefreshRate</strong>，一般不可靠，直接写死</li><li>可以在任何地方使用 <strong>Choreographer#postFrameCallback</strong>，与 <strong>View#post</strong> 或者 <strong>Handler#post</strong> 区别是不会立马执行，要等下一个垂直信号过来才会执行</li></ol><h3 id="ViewRootImpl-setView实现"><a href="#ViewRootImpl-setView实现" class="headerlink" title="ViewRootImpl#setView实现"></a>ViewRootImpl#setView实现</h3><p>了解以上两个基础知识后，剩下的就是看ViewRootImpl是怎么实现View的绘制显示的。 <strong>ViewRootImpl#setView</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">            mFallbackEventHandler.setView(view);</span><br><span class="line"></span><br><span class="line">            mWindowAttributes.copyFrom(attrs);</span><br><span class="line">            <span class="keyword">if</span> (mWindowAttributes.packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowAttributes.packageName = mBasePackageName;</span><br><span class="line">            &#125;</span><br><span class="line">            attrs = mWindowAttributes;</span><br><span class="line">            mClientWindowLayoutFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// RootViewSurfaceTaker即DecorView</span></span><br><span class="line">            <span class="comment">// Activity可以像SurfaceView一样，接管Surface，直接操作Surface</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                mSurfaceHolderCallback =</span><br><span class="line">                        ((RootViewSurfaceTaker)view).willYouTakeTheSurface();</span><br><span class="line">                <span class="keyword">if</span> (mSurfaceHolderCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mSurfaceHolder = <span class="keyword">new</span> TakenSurfaceHolder();</span><br><span class="line">                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);</span><br><span class="line">                    mSurfaceHolder.addCallback(mSurfaceHolderCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compute surface insets required to draw at specified Z value.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Use real shadow insets for a constant max Z.</span></span><br><span class="line">            <span class="keyword">if</span> (!attrs.hasManualSurfaceInsets) &#123;</span><br><span class="line">                attrs.setSurfaceInsets(view, <span class="keyword">false</span> <span class="comment">/*manual*/</span>, <span class="keyword">true</span> <span class="comment">/*preservePrevious*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 硬件加速，此处会创建ThreadedRenderer，见后文硬件加速的详细介绍</span></span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">// 第一次requestLayout</span></span><br><span class="line">            requestLayout();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果Window支持触摸，需要添加InputChannel通过WMS传递事件</span></span><br><span class="line">            <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把当前Window添加到WMS，此时Surface还未准备好不能绘制</span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPendingOverscanInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            mPendingContentInsets.set(mAttachInfo.mContentInsets);</span><br><span class="line">            mPendingStableInsets.set(mAttachInfo.mStableInsets);</span><br><span class="line">            mPendingVisibleInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to add window -- unknown error code "</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Activity接管触摸操作</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                mInputQueueCallback =</span><br><span class="line">                    ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建WindowInputEventReceiver接收触摸事件</span></span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把当前View的parent设置为当前ViewRootImpl</span></span><br><span class="line">            <span class="comment">// Parent需要实现ViewParent</span></span><br><span class="line">            view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ViewRootImpl#setView</strong> 中调用比较重要的接口requestLayout，requestLayout操作主要调用 <strong>ViewRootImpl#scheduleTraversals</strong>，具体实现如下.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler的SyncBarrier，见总结</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在Choreographer中post一个CALLBACK_TRAVERSAL，下一次垂直同步的时候执行 TraversalRunnable#doTraversal，进而performTraversals</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            <span class="comment">// 在Choreographer中post一个CALLBACK_INPUT，下一次垂直同步的时候执行 TraversalRunnable#doConsumeBatchedInput</span></span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知ThreadedRenderer即将有新的frame到来</span></span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleTraversals主要完成了向Choreographer中post CALLBACK_TRAVERSAL与CALLBACK_INPUT两种类型的callback，等待重绘和触摸事件的到来，关于触摸的实现我们暂时不管，主要看绘制的实现。</p><p><strong>本节知识点</strong></p><ol><li>在MessageQueue中添加一个特殊的SyncBarrier作为一个标记，在这个标记被移除之前，当前MessageQueue队列中排在它后面的其它非异步的message不会被handler处理</li></ol><h3 id="ViewRootImpl-performTraversals流程"><a href="#ViewRootImpl-performTraversals流程" class="headerlink" title="ViewRootImpl#performTraversals流程"></a>ViewRootImpl#performTraversals流程</h3><p>由于performTraversals代码量相对较大，只是我目前见过一个函数行数最多的，大概800行左右，看起来可能不是那么直观。一般自定义的View时候，一般 onMeasure onLayout onDraw三个方法，performTraversals大致也是这几个流程。</p><h4 id="测量阶段"><a href="#测量阶段" class="headerlink" title="测量阶段"></a>测量阶段</h4><p>doTraversal的第一阶段，会对整个控件树进行第一次测量，在此阶段会控件树所显示所需要的尺寸，在这个阶段，控件树中的所有View都会被调用到 <strong>View#onMeasure</strong> 方法，一般是从父布局中调用子View的onMeasure方法，父布局通过onMeasure的参数来把传达的参数给到子View， <strong>View#onMeasure</strong> 的具体定义如下，MeasureSpec虽然是一个整形，但却是一个复合型的变量, 其中前两位是测量模式，剩下的30位是width或者height。MeasureSpec只是子View作为设定自身大小参考，只是个参考，要多大，还是View自己说了算，但是View一旦超过父布局大小，界面可能显示不了。测量模式包括三种，UNSPECIFIED、EXACTLY、AT_MOST。</p><ol><li>UNSPECIFIED：父控件对子控件不加任何束缚，子元素可以得到任意想要的大小，这种MeasureSpec一般是由父控件自身的特性决定的。比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示，这个时候，size一般就没什么意义。</li><li>EXACTLY：父控件为子View指定确切大小，希望子View完全按照自己给定尺寸来处理，这时的MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数（MATCH_PARENT）来确定的。</li><li>AT_MOST：父控件为子元素指定最大参考尺寸，希望子View的尺寸不要超过这个尺寸，这种模式也是父控件根据自身的MeasureSpec跟子View的布局参数（WRAP_CONTENT）来确定的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存放根View宽高</span></span><br><span class="line"><span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line"><span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">...    </span><br><span class="line"></span><br><span class="line"><span class="comment">// WMS给定的最新Window Size</span></span><br><span class="line">Rect frame = mWinFrame;</span><br><span class="line"><span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">    mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">        <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></span><br><span class="line">        Point size = <span class="keyword">new</span> Point();</span><br><span class="line">        mDisplay.getRealSize(size);</span><br><span class="line">        desiredWindowWidth = size.x;</span><br><span class="line">        desiredWindowHeight = size.y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">        desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用控件树 onAttachedToWindow</span></span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    desiredWindowWidth = frame.width();</span><br><span class="line">    desiredWindowHeight = frame.height();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WMS 单方面修好了mWidth、mHeight强制重绘</span></span><br><span class="line">    <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当setView过mLayoutRequested才为true</span></span><br><span class="line"><span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类似悬浮窗</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></span><br><span class="line">                Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Configuration config = res.getConfiguration();</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终测量</span></span><br><span class="line">    windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终多有的操作都是交给measureHierarchy进行控件树的测量。多次协商后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 对于MATCH_PARENT或者直接写死不需要</span></span><br><span class="line">    <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// 首先使用最期望的宽度限制进行测量，常量</span></span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</span><br><span class="line">        res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> baseSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">            baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">            childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">            <span class="comment">// 第一次测量</span></span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测测量结果</span></span><br><span class="line">            <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</span><br><span class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">                <span class="comment">// 第二次测量</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!goodMeasure) &#123;</span><br><span class="line">        <span class="comment">// 第三次测量</span></span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> windowSizeMayChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见最终是调用了performMeasure方法来进行测量， 最终调用的地方 <strong>View#measure(childWidthMeasureSpec, childHeightMeasureSpec)</strong> measure也是对onMeasure的封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传递getSuggestedMinimumWidth()的意义在于当mode为UNSPECIFIED时需要获取size</span></span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么使用mininum？</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，应用层的测量几乎完成，剩下的是与WMS做相关的沟通，主要以relayoutWindow为核心，其主要是通过mWindowSession调用relayout方法使用，注意relayout中回把mSurface传给WMS,其中有些硬件加速相关的代码，暂时不表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame,</span><br><span class="line">            mPendingMergedConfiguration, mSurface);</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本节知识点</strong></p><ol><li>三种测量模式</li></ol><h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p>布局阶段主要完成控件树的布局和一些透明度区域的收集，以及与WMS协商。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">        || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line"><span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By this point all views have been sized and positioned</span></span><br><span class="line">    <span class="comment">// We can compute the transparent area</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// start out transparent</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> AVOID THAT CALL BY CACHING THE RESULT?</span></span><br><span class="line">        host.getLocationInWindow(mTmpLocation);</span><br><span class="line">        mTransparentRegion.set(mTmpLocation[<span class="number">0</span>], mTmpLocation[<span class="number">1</span>],</span><br><span class="line">                mTmpLocation[<span class="number">0</span>] + host.mRight - host.mLeft,</span><br><span class="line">                mTmpLocation[<span class="number">1</span>] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">        host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">            mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// reconfigure window manager</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局最重要调用performLayout，其最重要的实现是 <strong>View#layout</strong>，layout中通过setFrame设置View的LTRB，setFrame中检测到size发生改变或者第一次调用会调用onSizeChange方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure><p>布局的另一阶段是计算窗口的透明区域，方便后续底层SurafceFlinger做合成，类似在Surface上挖了一个洞。可以直接透过这个窗口看下后面的内容，常见于视频播放器。这一机制常用于SurfaceView。</p><h4 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h4><p>测量与布局完成后，既可以绘制了。 绘制的判断不多，主要调用performDraw方法。performDraw方法主要是调用draw方法。draw方法中关于动画的处理我们暂时不处理，主要看具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Android提供了两种绘图的方法。软件绘制与硬件绘制。由于内容相对较多，后面拆成两个小节来处理。</p><h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><p>软件绘制，是由CPU主导绘图，所有的操作由CPU来完成。适用于一些二维的绘图，底层调用的是Skia库。下面看下ViewRootImpl是如何进行软件绘制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到绘制Canvas，此处可能会修改dirty的值</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先清空成透明</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最终绘制方法</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放Canvas</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以看到直接通过 <strong>Surface#lockCanvas</strong> 取得Canvas，然后偶就可以通过此Canvas进行绘制，那么这个lockCanvas究竟做了些什么？看代码其实只是调用的 <strong>android_view_Surface#nativeLockCanvas</strong> 方法。此方法实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Surface</span></span><br><span class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算脏区</span></span><br><span class="line">    <span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">    Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ANativeWindow_Buffer结构体保存 w h stride format bits</span></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                         convertPixelFormat(outBuffer.format),</span><br><span class="line">                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888</span><br><span class="line">                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,</span><br><span class="line">                                         GraphicsJNI::defaultColorSpace());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Bitmap</span></span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    <span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    bitmap.setInfo(info, bpr);</span><br><span class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmap.setPixels(outBuffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">        bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Canvas</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip rect</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">                dirtyRect.right, dirtyRect.bottom, SkClipOp::kIntersect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改脏区</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <strong>Surface#lock</strong> 获取ANativeWindow_Buffer，里面存放Surface的具体宽，高，stride以及内存等信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindow_Buffer</span> &#123;</span></span><br><span class="line">    <span class="comment">/// The number of pixels that are shown horizontally.</span></span><br><span class="line">    <span class="keyword">int32_t</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The number of pixels that are shown vertically.</span></span><br><span class="line">    <span class="keyword">int32_t</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The number of *pixels* that a line in the buffer takes in</span></span><br><span class="line">    <span class="comment">/// memory. This may be &gt;= width.</span></span><br><span class="line">    <span class="keyword">int32_t</span> stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The format of the buffer. One of AHARDWAREBUFFER_FORMAT_*</span></span><br><span class="line">    <span class="keyword">int32_t</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The actual bits.</span></span><br><span class="line">    <span class="keyword">void</span>* bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Do not touch.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">6</span>];</span><br><span class="line">&#125; ANativeWindow_Buffer;</span><br></pre></td></tr></table></figure><p>之后通过所有的绘制操作，都是在这块Surface上进行绘制。关于Skia的绘制实现不表。后面即听过 <strong>View.draw(canvas)</strong> 把对应的View显示内容绘制到Surface上。后面我们详细分析这个方法。最后通过 <strong>Surface.unlockCanvasAndPost(canvas)</strong> 释放Canvas</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 硬件操作暂时不管</span></span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 软件实现</span></span><br><span class="line">            unlockSwCanvasAndPost(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        nativeRelease(mLockedObject);</span><br><span class="line">        mLockedObject = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和lockCanvas一样最终调用也是native中的nativeUnlockCanvasAndPost方法，实现位于 android_view_Surface.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detach the canvas from the surface</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlock surface</span></span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就来分析具体的绘制流程 <strong>View#draw</strong> 方法。draw方法的注释其实已经写明了绘制的过程</p><blockquote><p>Draw traversal performs several drawing steps which must be executed in the appropriate order:</p><ol><li>Draw the background</li><li>If necessary, save the canvas’ layers to prepare for fading</li><li>Draw view’s content</li><li>Draw children</li><li>If necessary, draw the fading edges and restore layers</li><li>Draw decorations (scrollbars for instance)</li></ol></blockquote><h4 id="绘制背景"><a href="#绘制背景" class="headerlink" title="绘制背景"></a>绘制背景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断是否是 “实心” 控件，所谓的实心控件是指后续的onDraw绘制内容能够完整的覆盖掉View的所有区域，此时为了提高绘制效率就不需要绘制背景，自定义View时可以通过重写isOpaque()方法实现。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line">    <span class="comment">// 如果不是</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用硬件加速绘制</span></span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RenderNode renderNode = mBackgroundRenderNode;</span><br><span class="line">        <span class="keyword">if</span> (renderNode != <span class="keyword">null</span> &amp;&amp; renderNode.isValid()) &#123;</span><br><span class="line">            setBackgroundRenderNodeProperties(renderNode);</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软件绘制， 这里有一点需要注意的地方就是两次平移操作</span></span><br><span class="line">    <span class="comment">// 在最开始调用draw方法之前其实ViewRootImpl是有对移动操作做单独的处理的</span></span><br><span class="line">    <span class="comment">// 此处把对应的操作给回滚了，是为了保证背景不会随着滚动而滚动</span></span><br><span class="line">    <span class="comment">// 当然绘制结束后需要恢复translate</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在说下面的准备绘制渐变框之前，需要单独的提一下不表示所有的控件都需要绘制这个所谓的渐变框的，因此第2步和第5部步是可以省略的。</p><h4 id="准备绘制渐变框"><a href="#准备绘制渐变框" class="headerlink" title="准备绘制渐变框"></a>准备绘制渐变框</h4><p>所谓的渐变，其实就是我们常见的诸如ListView等控件在拖动到顶部或者底部后弹出来的渐变效果，如下图。渐变框可以通过android:fadingEdge设置渐变的方向，android:fadingEdgeLength来设置渐变框的长度</p><p><img src="/images/placeholder.png" alt="渐变效果" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/fade.jpeg" class="lazyload"></p><p>此步骤只是设置了通过计算当前需要绘制的渐变框位置与区域，然后保存layer</p><h4 id="绘制内容"><a href="#绘制内容" class="headerlink" title="绘制内容"></a>绘制内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接调用onDraw方法绘制其内容，View中此方法为空实现，一般自定义View重写此方法</span></span><br><span class="line"><span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br></pre></td></tr></table></figure><h4 id="绘制子控件"><a href="#绘制子控件" class="headerlink" title="绘制子控件"></a>绘制子控件</h4><p>之后便是绘制子控件的流程，由于不是所有控件都有子空间，因此在View中此方法为空实现，ViewGroup中才有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip操作，有时候子控件大小可能超过当前ViewGroup，一般超出区域会直接忽略掉</span></span><br><span class="line">    <span class="comment">// 可以通过ViewGroup#setClipToPadding修改</span></span><br><span class="line">    <span class="keyword">int</span> clipSaveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> more = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">            ? <span class="keyword">null</span> : buildOrderedChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取View的绘制顺序，View的绘制顺序会影响重叠时候的显示效果。先绘制的View会被后续绘制的View覆盖</span></span><br><span class="line">        <span class="comment">// 可以通过getChildDrawingOrder来设置绘制顺序，默认实现是先加入则先绘制</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        canvas.restoreToCount(clipSaveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mGroupFlags might have been updated by drawChild()</span></span><br><span class="line">    flags = mGroupFlags;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>决定了绘制顺序后，ViewGroup便会通过 drawChild方法绘制子控件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意不是子控件draw(canvas)接口</span></span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处调用了子View的 <strong>View.draw(ViewGroup,Canvas,long)</strong>，大致经历以下操作</p><ol><li>进行动画的计算，将计算结果存储一个Transformation中</li><li>计算控件内容的滚动量</li><li>使用Canvas.save()保存Canvas的当前状态。此时Canvas的坐标系为父控件的坐标系。在随后将Canvas变换到此空间的坐标系并完成绘制后，会通过Canvas.restoreTo()将Canvas重置到此时的状态，以便Canvas可以继续用来绘制父控件的下一个子控件</li><li>第一次变换，对应控件位置与滚动</li><li>将动画产生的变换矩阵应用到Canvas中。主要是各种Animation，如SacleAnimation等</li><li>将控件自身的变换矩阵应用到Canvas中</li><li>设置剪裁。这个和dispatchDraw()中的裁剪工作不同：dispatchDraw()中的裁剪是为了保证所有的子控件绘制的内容不得越过父控件的边界。此处是指子控件的绘制内容不得超出子控件自身的边界，由setClipChildren()方法启用或禁用</li><li>使用变换过的Canvas进行最终绘制，调用dispatchDraw()或者draw(Canvas)两个方法</li><li>恢复Canvas的状态到一切开始之前，使得父控件的dispatchDraw()便可以将这个Canvas交给下一个子控件的draw(ViewGroup, Canvas, long)方法</li></ol><p><img src="/images/placeholder.png" alt="控件树绘制的完整流程" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/draw.png" class="lazyload"></p><h4 id="绘制渐变框"><a href="#绘制渐变框" class="headerlink" title="绘制渐变框"></a>绘制渐变框</h4><p>如第2步所示，不细讲</p><h4 id="绘制装饰"><a href="#绘制装饰" class="headerlink" title="绘制装饰"></a>绘制装饰</h4><p>此操作用来绘制一些滚动条，ViewOverlay等，ViewOverlay它是位于View视图层顶部的一个附加层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">    mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDrawForeground(canvas);</span><br></pre></td></tr></table></figure><p>简单的对软件绘制流程的总结<br><img src="/images/placeholder.png" alt="软件绘制" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/sw_process.png" class="lazyload"></p><p><strong>本节知识点</strong></p><ol><li><strong>View#isOpaque()</strong> 提高绘制效率</li><li>ViewOverlay的使用</li></ol><h3 id="硬件加速绘制"><a href="#硬件加速绘制" class="headerlink" title="硬件加速绘制"></a>硬件加速绘制</h3><p>倘若窗口使用硬件加速，则ViewRootImpl会创建一个ThreadedRenderer并保存在mAttachInfo中，见ViewRootImpl#setView中enableHardwareAcceleration。ThreadedRenderer是用于硬件加速的渲染器，它封装了硬件加速的图形库，并以Android与硬件加速图形库的中间层的身份存在。它负责从Android的Surface生成一个HardwareLayer，供硬件加速图形库作为绘制的输出目标，并提供一系列工厂方法用于创建硬件加速绘制过程中所需的DisplayList、DisplayListCanvas等工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">    mAttachInfo.mHardwareAccelerated = <span class="keyword">false</span>;</span><br><span class="line">    mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hardwareAccelerated =</span><br><span class="line">            (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hardwareAccelerated) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建ThreadedRenderer</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,</span><br><span class="line">                    attrs.getTitle().toString());</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setWideGamut(wideGamut);</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mHardwareAccelerated =</span><br><span class="line">                        mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadedRenderer <span class="title">create</span><span class="params">(Context context, <span class="keyword">boolean</span> translucent, String name)</span> </span>&#123;</span><br><span class="line">    ThreadedRenderer renderer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isAvailable()) &#123;</span><br><span class="line">        renderer = <span class="keyword">new</span> ThreadedRenderer(context, translucent, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ThreadedRenderer(Context context, <span class="keyword">boolean</span> translucent, String name) &#123;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br><span class="line">    mRootNode = RenderNode.adopt(rootNodePtr);</span><br><span class="line">    mRootNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// native 代理。后续详解</span></span><br><span class="line">    mNativeProxy = nCreateProxy(translucent, rootNodePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，在开启硬件加速状态下，<strong>ViewRootImpl#enableHardwareAcceleration</strong> 创建了ThreadedRenderer实例，ThreadedRenderer在构造函数中通过调用native方法nCreateRootRenderNode创建了一个RootRenderNode，native对应会创建一个RootRenderNode对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软件绘制流程我们知道大致经历了 lockCanvas -&gt; draw -&gt; unlockCanvasAndPost三个阶段。对比这三个阶段，我们看下硬件加速的实现方式。入口函数即 <strong>ThreadedRenderer#draw</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记开始绘制，mFrameInfo保存着当前帧的信息</span></span><br><span class="line">    <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">    choreographer.mFrameInfo.markDrawStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新DisplayList</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面会分析这个实现</span></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_LOST_SURFACE_REWARD_IF_FOUND) != <span class="number">0</span>) &#123;</span><br><span class="line">        setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        attachInfo.mViewRootImpl.mSurface.release();</span><br><span class="line">        <span class="comment">// Invalidate since we failed to draw. This should fetch a Surface</span></span><br><span class="line">        <span class="comment">// if it is still needed or do nothing if we are no longer drawing</span></span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Record View#draw()"</span>);</span><br><span class="line">    updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">            canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">            callbacks.onPreDraw(canvas);</span><br><span class="line"></span><br><span class="line">            canvas.insertReorderBarrier();</span><br><span class="line">            canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">            canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">            callbacks.onPostDraw(canvas);</span><br><span class="line">            canvas.restoreToCount(saveCount);</span><br><span class="line">            mRootNodeNeedsUpdate = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mRootNode.end(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DisplayListCanvas <span class="title">start</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DisplayListCanvas.obtain(<span class="keyword">this</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比软件绘制的实现，直接通过lockCanvas获取Canvas，硬件加速会直接调用， <strong>RenderNode#start</strong> 方法直接获取到DisplayListCanvas。而<strong>RenderNode#start</strong>方法则是通过 <strong>DisplayListCanvas#obtain</strong> 获取DisplayListCanvas</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> DisplayListCanvas <span class="title">obtain</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从对象池中取出所需对象，不存在创建，重载需要重置</span></span><br><span class="line">    DisplayListCanvas canvas = sPool.acquire();</span><br><span class="line">    <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas = <span class="keyword">new</span> DisplayListCanvas(node, width, height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,</span><br><span class="line">                width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.mNode = node;</span><br><span class="line">    canvas.mWidth = width;</span><br><span class="line">    canvas.mHeight = height;</span><br><span class="line">    <span class="keyword">return</span> canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayListCanvas 构造函数中会通过nCreateDisplayListCanvas在native层中创建一个对应Canvas对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(jlong renderNodePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* Canvas::create_recording_canvas(<span class="keyword">int</span> width, <span class="keyword">int</span> height, uirenderer::RenderNode* renderNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用OpenGL RecordingCanvas，构造函数中会初始化 DisplayList</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::RecordingCanvas(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Canvas，我们就有了绘图的工具。紧接我们就可以绘制控件及其子控件了，回到updateRootDisplayList方法，绘制子控件的实现 <strong>canvas.drawRenderNode(view.updateDisplayListIfDirty())</strong> 那么这个 <strong>View#updateDisplayListIfDirty</strong> 做了些什么操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RenderNode renderNode = mRenderNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">            || !renderNode.isValid()</span><br><span class="line">            || (mRecreateDisplayList)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> height = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> layerType = getLayerType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和ThreaderRender中使用相同，通过renderNode#start接口获取DisplayListCanvas</span></span><br><span class="line">        <span class="keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                computeScroll();</span><br><span class="line"></span><br><span class="line">                canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">                <span class="comment">// 最终回归到我们软件绘制中draw与dispatchDraw方法</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                    dispatchDraw(canvas);</span><br><span class="line">                    drawAutofilledHighlight(canvas);</span><br><span class="line">                    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                        mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">            setDisplayListProperties(renderNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchDraw方法和软件绘制相同，几乎没有额外的操作，具体也是在ViewGroup中才会有实现，主要目的是确认子控件的绘制顺序，最终调用也是 drawChild接口，进而 <strong>View#draw(Canvas canvas, ViewGroup parent, long drawingTime)</strong> 这个draw方法与软件绘制最大的不同在于， 会去调用(DisplayListCanvas) canvas).drawRenderNode(renderNode)，关于这个方法的解释，参见后面的详细解释。后续和软件绘制基本没有什么区别，不同的是传入的Canvas是DisplayListCanvas。</p><p>从以上操作我们能隐隐约约看出来点什么，这里创建的所有Canvas都是一种Recording Canvas，并且无任何真正的像软件绘制中Canvas.draw这种绘制操作，不难猜测，此处的Canvas应该只是录制了RenderNode的一些操作，具体的绘制不在此。具体是怎么实现录制的呢，回到updateRootDisplayList方法，刚才我们看到通过 Render的start与end接口，录制了根View的绘制操作，而具体的实现则是通过 <strong>DisplayListCanvas#drawRenderNode</strong> 实现，把View的RenderNode录制下来，drawRenderNode的实现特别简单，直接调用了native接口nDrawRenderNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_DisplayListCanvas_drawRenderNode</span><span class="params">(jlong canvasPtr, jlong renderNodePtr)</span> </span>&#123;</span><br><span class="line">    Canvas* canvas = reinterpret_cast&lt;Canvas*&gt;(canvasPtr);</span><br><span class="line">    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    canvas-&gt;drawRenderNode(renderNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RecordingCanvas::drawRenderNode(RenderNode* renderNode) &#123;</span><br><span class="line">    auto&amp;&amp; stagingProps = renderNode-&gt;stagingProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把添加renderNode封装成一个RenderNodeOp，添加到Canvas中</span></span><br><span class="line">    RenderNodeOp* op = alloc().create_trivial&lt;RenderNodeOp&gt;(</span><br><span class="line">            Rect(stagingProps.getWidth(), stagingProps.getHeight()),</span><br><span class="line">            *(mState.currentSnapshot()-&gt;transform), getRecordedClip(), renderNode);</span><br><span class="line">    <span class="keyword">int</span> opIndex = addOp(op);</span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(opIndex &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新mDisplayList</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = mDisplayList-&gt;addChild(op);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the chunk's child indices</span></span><br><span class="line">        DisplayList::Chunk&amp; chunk = mDisplayList-&gt;chunks.back();</span><br><span class="line">        chunk.endChildIndex = childIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (renderNode-&gt;stagingProperties().isProjectionReceiver()) &#123;</span><br><span class="line">            <span class="comment">// use staging property, since recording on UI thread</span></span><br><span class="line">            mDisplayList-&gt;projectionReceiveIndex = opIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文说过DisplayListCanvas其实不参与真正的绘制，只是记录绘制的操作Op。对应我们在onDraw方法中自己的一些操作，drawBitmap，drawColor之类，DisplayListCanvas也会封装成对应的Op</p><p><img src="/images/placeholder.png" alt="Op" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/op.png" class="lazyload"></p><p>这样我们就不难得出这样的结论，每一个View中都包含一个RenderNode，此Node对应Native中的RenderNode，而ViewRootImpl则对应RootRenderNode，每一个RenderNode包含DisplayList，DisplayList又有多个Op组成。</p><p><img src="/images/placeholder.png" alt="硬件加速绘制流程" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/hw_draw.jpg" class="lazyload"></p><p>按照软件绘制的套路，我们先后续的操作 <strong>mRootNode.end(canvas)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(DisplayListCanvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">    nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">    canvas.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_RenderNode_setDisplayList</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject clazz, jlong renderNodePtr, jlong displayListPtr)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    DisplayList* newData = <span class="keyword">reinterpret_cast</span>&lt;DisplayList*&gt;(displayListPtr);</span><br><span class="line">    renderNode-&gt;setStagingDisplayList(newData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderNode::setStagingDisplayList(DisplayList* displayList) &#123;</span><br><span class="line">    mValid = (displayList != <span class="literal">nullptr</span>);</span><br><span class="line">    mNeedsDisplayListSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">delete</span> mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = displayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结一下硬件加速绘制流程</p><ol><li>利用View的RenderNode获取一个DisplayListCanvas</li><li>利用DisplayListCanvas构建并缓存所有的DrawOp</li><li>将DisplayListCanvas缓存的DrawOp填充到RenderNode</li><li>将根View的缓存DrawOp设置到RootRenderNode中，完成构建</li></ol><p>以上我们了解具体的录制流程，但是最终是在何处绘制的呢？这时候我们就要回到ThreaderRenderer的构造函数中。还记得那个native代理嘛，看下其具体实现。具体的实现位于Native中，创建一个RenderProxy对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = reinterpret_cast&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode,</span><br><span class="line">                         IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance()), mContext(nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CanvasContext是一个继承IFrameCallback的类，IFrameCallback</span></span><br><span class="line">    mContext = mRenderThread.queue().runSync([&amp;]() -&gt; CanvasContext* &#123;</span><br><span class="line">        <span class="keyword">return</span> CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在updateRootDisplayList之后会调用 nSyncAndDrawFrame， 这个就是绘制的具体实现的部分了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(frameInfoSize != UI_THREAD_FRAME_INFO_SIZE,</span><br><span class="line">            <span class="string">"Mismatched size expectations, given %d expected %d"</span>,</span><br><span class="line">            frameInfoSize, UI_THREAD_FRAME_INFO_SIZE);</span><br><span class="line">    RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    env-&gt;GetLongArrayRegion(frameInfo, <span class="number">0</span>, frameInfoSize, proxy-&gt;frameInfo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体通过syncAndDrawFrame实现绘制</span></span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame() &#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DrawFrameTask::drawFrame() &#123;</span><br><span class="line">    mSyncResult = SyncResult::OK;</span><br><span class="line">    mSyncQueued = systemTime(CLOCK_MONOTONIC);</span><br><span class="line">    postAndWait();</span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    <span class="function">AutoMutex <span class="title">_lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把run方法放到mRenderThread线程中执行</span></span><br><span class="line">    mRenderThread-&gt;queue().post([<span class="keyword">this</span>]() &#123; run(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处会阻塞主线程</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    bool canUnblockUiThread;</span><br><span class="line">    bool canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可知，在主线程通知 <strong>DrawFrameTask#drawFrame</strong> 后，drawFrame调用postAndWait方法，等待mLock释放，此时主线程会被阻塞。为什么此处需要阻塞主线程？其实可以通过后面的在RenderThread执行的run方法来确认原因，后面会有关于是否需要立马释放主线程，还是等待绘制完在释放是需要通过syncFrameState返回值来判断的，原因是因为RenderThread与主线程同时持有了一些绘制帧信息。在绘制之前需要同步保证相同，具体的实现位于 prepareTree 中，具体实现此处不表。如果想要查看具体的绘制流程可以参考 <a href="https://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> vsync = mFrameInfo[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FrameInfoIndex::Vsync)];</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(vsync);</span><br><span class="line">    <span class="keyword">bool</span> canDraw = mContext-&gt;makeCurrent();</span><br><span class="line">    mContext-&gt;unpinImages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mLayers[i]-&gt;apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    mContext-&gt;setContentDrawBounds(mContentDrawBounds);</span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is after the prepareTree so that any pending operations</span></span><br><span class="line">    <span class="comment">// (RenderNode tree state, prefetched layers, etc...) will be flushed.</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mContext-&gt;hasSurface()) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::LostSurfaceRewardIfFound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a surface but can't draw we must be stopped</span></span><br><span class="line">            mSyncResult |= SyncResult::ContextIsStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!info.out.canDrawThisFrame) &#123;</span><br><span class="line">        mSyncResult |= SyncResult::FrameDropped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderThread被唤醒，开始渲染，大致流程如下：</p><ol><li>先进行DrawOp的合并</li><li>接着绘制特殊的Layer</li><li>绘制其余所有的DrawOpList</li><li>调用swapBuffers将前面已经绘制好的图形缓冲区提交给Surface Flinger合成和显示。</li></ol><p>对比软件绘制递归调用流程</p><p><img src="/images/placeholder.png" alt="对比" data-src="Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/sw_hw_difference.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity启动流程 </tag>
            
            <tag> View的现实流程 </tag>
            
            <tag> 硬件加速 </tag>
            
            <tag> 软件绘制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从进程起源说起</title>
      <link href="/2018/06/26/%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%B5%B7%E6%BA%90%E8%AF%B4%E8%B5%B7/"/>
      <url>/2018/06/26/%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%B5%B7%E6%BA%90%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>一直想研究一下 Android 源码中关于图形渲染相关的内容，但是一直感觉无从入手，所以干脆直接从进程启动开始说起吧。后续会按照我看的内容尽量的写一些相关的博客。充实一下自己，打磨一下时光。废话少说，今天我们来分析一下 Android 应用进程的Zygote说起。</p> <a id="more"></a><h1 id="从进程起源分析—Zygote"><a href="#从进程起源分析—Zygote" class="headerlink" title="从进程起源分析—Zygote"></a>从进程起源分析—Zygote</h1><p>一直想研究一下 <code>Android</code> 源码中关于图形渲染相关的内容，但是一直感觉无从入手，所以干脆直接从进程启动开始说起吧。后续会按照我看的内容尽量的写一些相关的博客。充实一下自己，打磨一下时光。废话少说，今天我们来分析一下 <code>Android</code> 应用进程的<code>Zygote</code>说起。</p><h2 id="Zygote是什么？"><a href="#Zygote是什么？" class="headerlink" title="Zygote是什么？"></a>Zygote是什么？</h2><p>首先我们要知道我们要分析的这个东西到底是用来做什么的。我们知道在android的世界中存在两种不同的可执行程序，其一是native可执行程序，另一类则是我们常接触的java应用程序。其中native程序由标准init程序fork出来，zygote也不例外，也是由init通过解析init.zygote.rc文件，启动而来。</p><p><strong>“所有的Java应用程序进程及系统服务SystemServer进程都由Zygote进程通过fork孵化而来”</strong></p><p>具体的关于 <code>.rc</code> 文件的解析，有缘我们在分析 <code>init</code> 程序的时候我们再分析。其中，我们暂时只需要知道 <code>service</code> 是 <code>.rc</code> 文件中的一个指令，具体的规则</p><p><strong>“service + 进程名 + 可执行程序 + 启动参数”</strong></p><p><code>init</code> 进程通过分析如下 <code>init.zygote.rc</code> 文件, 执行 <code>app_process</code> 可执行文件，创建 <code>zygote</code> 进程。也即 <code>zygote</code> 对应的可执行程序是 <code>/system/bin/app_process</code> ，启动后会改名为 <code>zygote</code> ， 启动的时候会带一些其他的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### init.zygote64_32.rc</span></span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><h2 id="app-process启动分析"><a href="#app-process启动分析" class="headerlink" title="app_process启动分析"></a>app_process启动分析</h2><p>接着我们来分析 <code>Zygote(app_process)</code> 的启动过程，作为一个可执行程序，必须有标准的入口, 即 <code>main</code> 函数。如果我们了解的更多的话，我们会知道 <code>app_process</code> 不仅仅会启动 <code>Zygote</code> 进程，还可以直接有个用法是在 <code>android</code> 中执行 <code>jar</code> 包，比如这是 <code>monkey</code> 命令对应的脚本，可以看到其实只是使用 <code>app_process</code> 执行对应的 <code>jar</code> 包中 <code>main</code> 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### /system/bin/monkey</span></span><br><span class="line">base=/system</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$base</span>/framework/monkey.jar</span><br><span class="line"><span class="built_in">trap</span> <span class="string">""</span> HUP</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  bash arg:"</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exec</span> app_process <span class="variable">$base</span>/bin com.android.commands.monkey.Monkey <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>了解这个之后，我们就可以真正的分析 <code>app_process</code> 的启动流程了。如下是 <code>main</code> 函数的实现，忽略不必要的 <code>log</code> 打印</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算argv的长度，作为创建AppRuntime的参数，见 注①</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="comment">//此处省略部分代码，解析参数-cp与-classpath，添加到runtime中，常见于我们直接在Android中执行jar包</span></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//①如果创建的Zygote进程，此处为true，niceName为zygote</span></span><br><span class="line">    <span class="comment">//②如果通过app_process执行jar包，此处zygote为false，niceName为空，className为对应的传递的类名</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处从argv中解析对应的参数</span></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="comment">//className不空，说明是通过app_process启动jar包，向runtime传递对应的参数，比如说monkey中的“$@”</span></span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//启动zygote进程</span></span><br><span class="line">        <span class="comment">//此处创建DalvikCache文件夹, 设置权限，群组等</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到设备支持的abi架构，可以直接通过adb shell getprop ro.product.cpu.abilist64(或者32，根据不同的CPU架构)</span></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>; <span class="comment">//可能不只一个abi，比如说对于arm64-v8的CPU一般都会支持armeabi-v7a，armeabi</span></span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩余参数</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//niceName不空，比如zygote进程。</span></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//此处把app_process进程名，改为zygote，见 注② 这就是上述说得改名操作</span></span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//zygote模式启动com.android.internal.os.ZygoteInit此java类 注③</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="comment">//非zyote启动com.android.internal.os.RuntimeInit类 注④</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上述注释我们可以看到， <code>main</code> 函数只是解析了对应的参数，所有的操作还是交给了 <code>AppRuntime</code> 去操作。我们接着来分析注释中的注</p><blockquote><p>注①： 此处调用AppRuntime的构造函数，目的只是给变量赋值，无特殊操作。</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppRuntime</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AppRuntime</span> :</span> <span class="keyword">public</span> AndroidRuntime</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     AppRuntime(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> argBlockLength)</span><br><span class="line">         : AndroidRuntime(argBlockStart, argBlockLength)</span><br><span class="line">         , mClass(<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// AndroidRuntime</span></span><br><span class="line"> AndroidRuntime::AndroidRuntime(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> argBlockLength) :</span><br><span class="line">         mExitWithoutCleanup(<span class="literal">false</span>),</span><br><span class="line">         mArgBlockStart(argBlockStart),</span><br><span class="line">         mArgBlockLength(argBlockLength)</span><br><span class="line"> &#123;</span><br><span class="line">     SkGraphics::Init(); <span class="comment">//初始化skia，具体意义未知</span></span><br><span class="line">     mOptions.setCapacity(<span class="number">20</span>);</span><br><span class="line">     gCurRuntime = <span class="keyword">this</span>; <span class="comment">//全局变量，供以后使用，详见下文</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注②： 修改进程名称操作</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::setArgv0(<span class="keyword">const</span> <span class="keyword">char</span>* argv0, <span class="keyword">bool</span> setProcName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setProcName) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(argv0);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">15</span>) &#123;</span><br><span class="line">            pthread_setname_np(pthread_self(), argv0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_setname_np(pthread_self(), argv0 + len - <span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mArgBlockStart, <span class="number">0</span>, mArgBlockLength);</span><br><span class="line">    strlcpy(mArgBlockStart, argv0, mArgBlockLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注③：启动对应的java虚拟机和加载对应的类</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ...此处忽略一些环境变量的检查设置</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    <span class="comment">//此处初始化JniInvocation，加载libart.so, 绑定一些与JavaVm相关的函数</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//startVM 封装参数，调用art中的JNI_CreateJavaVM, 创建jni使用的所有资源, 返回mJavaVM静态全局变量</span></span><br><span class="line">    <span class="comment">//以及当前线程的JniEnv</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于zygote空实现，对应普通的java应用程序而言, 会在此处加载对应的class文件，</span></span><br><span class="line">    <span class="comment">//原因是如果在boot class加载其他类，classloader会认为此类就存在boot class中，不会去找classpath中提供的类</span></span><br><span class="line">    <span class="comment">//最简单解决方案是在加载boot class之前加载对应的类</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册android相关接口,这里会设置一个创建线程的回调给Thread.cpp, 以后创建线程都会掉到此处设置的回调</span></span><br><span class="line">    <span class="comment">//见 注④</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建java中的String数组保存调用时要传入的参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//toSlashClassName目的是把类名中的.替换成/, </span></span><br><span class="line">    <span class="comment">//如com.android.internal.os.ZygoteInit修改成com/android/internal/os/ZygoteInit</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载class后，调用对应的main函数，[Ljava/lang/String;)V为函数签名，返回值void，参数String[]</span></span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,<span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关掉VM</span></span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注④ 如果熟悉JNI的话可能会遇到过这种经历，想要在native代码中创建子线程然后访问JNIEnv会直接崩溃，但是直接在java创建子线程，然后调用的对应jni接口的话却不会，从android的线程代码实现中我们也可以看到最终调用的同样是pthread相关的接口，为什么出现不一致的行为呢？</p></blockquote><p>其一，崩溃问题原因是jni的限制，不允许在其他线程中直接访问JNIEnv，必须通过JavaVM中的AttachCurrentThread把线程绑定到当前的VM上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JNIEnv* is A JNI interface pointer (JNIEnv*) is passed as an argument for each native function</span></span><br><span class="line"><span class="comment">// mapped to a Java method, allowing for interaction with the JNI environment within the native</span></span><br><span class="line"><span class="comment">// method. This JNI interface pointer can be stored, but remains valid only in the current thread.</span></span><br><span class="line"><span class="comment">// Other threads must first call AttachCurrentThread() to attach themselves to the VM and obtain a</span></span><br><span class="line"><span class="comment">// JNI interface pointer. Once attached, a native thread works like a regular Java thread running</span></span><br><span class="line"><span class="comment">// within a native method. The native thread remains attached to the VM until it calls</span></span><br><span class="line"><span class="comment">// DetachCurrentThread() to detach itself. </span></span><br><span class="line"><span class="comment">// To attach to the current thread and get a JNI interface pointer: </span></span><br><span class="line"></span><br><span class="line"> JNIEnv *env; </span><br><span class="line"> (*g_vm)-&gt;AttachCurrentThread (g_vm, (<span class="keyword">void</span> **) &amp;env, <span class="literal">NULL</span>); </span><br><span class="line"> <span class="comment">//To detach from the current thread: </span></span><br><span class="line"> (*g_vm)-&gt;DetachCurrentThread (g_vm);</span><br></pre></td></tr></table></figure><p>其二，为什么java创建的线程可以直接访问？</p><p>如上代码中的 <code>startReg</code> 接口具体实现如下, 关键之处在于设置创建线程的回调这一调用，我们看最终调用的 <code>javaCreateThreadEtc</code> 接口，这个是从 <code>java</code> 层创建线程默认都会调用到的一处回调。抛开具体的参数不谈，我们可以看到继续调用了 <code>androidCreateRawThreadEtc</code> 方法，这个方法 <code>Thread.cpp</code> 中的接口，创建线程时使用，注意它的第一个参数，是一个函数指针 <code>AndroidRuntime::javaThreadShell</code>，这个就是我们关注的重点，正真起作用的地方,  可以看到，其实最终也是把创建的线程绑定到当前的 <code>VM</code> 中，这就是为什么在 <code>java</code> 线程中可以直接通过调用 <code>jni</code> 方法访问 <code>JNIEnv</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里会设置一个创建线程的回调给Thread.cpp, 以后创建线程都会掉到此处设置的回调</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    </span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册android相关接口,</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(NULL);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> AndroidRuntime::javaCreateThreadEtc(</span><br><span class="line">                                android_thread_func_t entryFunction,</span><br><span class="line">                                <span class="keyword">void</span>* userData,</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span>* threadName,</span><br><span class="line">                                int32_t threadPriority,</span><br><span class="line">                                size_t threadStackSize,</span><br><span class="line">                                android_thread_id_t* threadId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>** args = (<span class="keyword">void</span>**) malloc(<span class="number">3</span> * sizeof(<span class="keyword">void</span>*)); </span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    args[<span class="number">0</span>] = (<span class="keyword">void</span>*) entryFunction;</span><br><span class="line">    args[<span class="number">1</span>] = userData;</span><br><span class="line">    args[<span class="number">2</span>] = (<span class="keyword">void</span>*) strdup(threadName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注对象 javaThreadShell</span></span><br><span class="line">    result = androidCreateRawThreadEtc(AndroidRuntime::javaThreadShell, args,</span><br><span class="line">        threadName, threadPriority, threadStackSize, threadId);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> AndroidRuntime::javaThreadShell(<span class="keyword">void</span>* args) &#123;</span><br><span class="line">    <span class="keyword">void</span>* start = ((<span class="keyword">void</span>**)args)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">void</span>* userData = ((<span class="keyword">void</span> **)args)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span>* name = (<span class="keyword">char</span>*) ((<span class="keyword">void</span> **)args)[<span class="number">2</span>];        <span class="comment">// we own this storage</span></span><br><span class="line">    free(args);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vm =&gt; javaAttachThread</span></span><br><span class="line">    <span class="keyword">if</span> (javaAttachThread(name, &amp;env) != JNI_OK)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程android_thread_func_t方法</span></span><br><span class="line">    result = (*(android_thread_func_t)start)(userData);</span><br><span class="line"></span><br><span class="line">    javaDetachThread();</span><br><span class="line">    free(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述分析，我们知道，最终 <code>app_process</code> 会调用的最终的传入的 <code>java</code> 类的 <code>main</code> 函数，此处分为 <code>zygote</code> 和普通我们执行的 <code>jar</code> 包等。我们首先分析一下 <code>zygote</code> 传入的 <code>main</code> 函数所在类<code>com.android.internal.os.ZygoteInit</code></p><h2 id="Zygote进程创建"><a href="#Zygote进程创建" class="headerlink" title="Zygote进程创建"></a>Zygote进程创建</h2><p>ZygoteInit是一个普通的java类。我们从main函数开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ZygoteServer，具体详解见 注⑤</span></span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记zygote启动，最终调用到libcore中的实现</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//解析之前传入的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册ZygoteServer，注⑤</span></span><br><span class="line">        zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">        <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">        <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            preload();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置当前线程优先级</span></span><br><span class="line">            Zygote.resetNicePriority();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line"></span><br><span class="line">        Zygote.nativeSecurityInit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">        Zygote.nativeUnmountStorageOnInit();</span><br><span class="line"></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fork创建system_server 注⑥</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">            <span class="comment">// child (system_server) process.</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        <span class="comment">//注⑤</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">    <span class="comment">// command.</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     beginIcuCachePinning();</span><br><span class="line">     <span class="comment">//通过读/system/etc/preloaded-classes，一个个加载对应的class</span></span><br><span class="line">     preloadClasses();</span><br><span class="line">     <span class="comment">//预加载一些Resource，例如分辨率，locale等</span></span><br><span class="line">     preloadResources();</span><br><span class="line">     <span class="comment">//HAL</span></span><br><span class="line">     nativePreloadAppProcessHALs();</span><br><span class="line">     <span class="comment">//EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</span></span><br><span class="line">     preloadOpenGL();</span><br><span class="line">     <span class="comment">//System.loadLibrary("android");</span></span><br><span class="line">     <span class="comment">//System.loadLibrary("compiler_rt");</span></span><br><span class="line">     <span class="comment">//System.loadLibrary("jnigraphics");</span></span><br><span class="line">     preloadSharedLibraries();</span><br><span class="line">     <span class="comment">//字体</span></span><br><span class="line">     preloadTextResources();</span><br><span class="line">     <span class="comment">//webview</span></span><br><span class="line">     WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">     endIcuCachePinning();</span><br><span class="line">     <span class="comment">//KeyStore,加密解密相关</span></span><br><span class="line">     warmUpJcaProviders();</span><br><span class="line">     sPreloadComplete = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注⑤  ZygoteServer的作用，创建一个socket server，等待客户端发送对应的请求，zygote的客户端对应的是ActivityManageService</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers a server socket for zygote command connections</span></span><br><span class="line"><span class="comment"> * 从之前的init.rc中可以看到，zygote传入的socketName即默认的socketName: -socket-name=zygote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerServerSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fileDesc;</span><br><span class="line">        <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; <span class="comment">//"ANDROID_SOCKET_"</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String env = System.getenv(fullSocketName);</span><br><span class="line">            fileDesc = Integer.parseInt(env);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(fullSocketName + <span class="string">" unset or invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建LocalServerSocket监听</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">            fd.setInt$(fileDesc);</span><br><span class="line">            mServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Error binding to local socket '"</span> + fileDesc + <span class="string">"'"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    </span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待pollFds对应的fd发生改变，意味着有命令来到需要处理</span></span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//未发生改变，不做操作</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                        <span class="comment">// not until we attempt to read from it from processOneCommand. This shows up as</span></span><br><span class="line">                        <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the server so any exception here is one that has taken place</span></span><br><span class="line">                        <span class="comment">// pre-fork while processing commands or reading / writing from the</span></span><br><span class="line">                        <span class="comment">// control socket. Make a loud noise about any such exceptions so that</span></span><br><span class="line">                        <span class="comment">// we know exactly what failed and why.</span></span><br><span class="line"></span><br><span class="line">                        Slog.e(TAG, <span class="string">"Exception executing zygote command: "</span>, e);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Make sure the socket is closed so that the other end knows immediately</span></span><br><span class="line">                        <span class="comment">// that something has gone wrong and doesn't time out waiting for a</span></span><br><span class="line">                        <span class="comment">// response.</span></span><br><span class="line">                        ZygoteConnection conn = peers.remove(i);</span><br><span class="line">                        conn.closeSocket();</span><br><span class="line"></span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the child so any exception caught here has happened post</span></span><br><span class="line">                        <span class="comment">// fork and before we execute ActivityThread.main (or any other main()</span></span><br><span class="line">                        <span class="comment">// method). Log the details of the exception and bring down the process.</span></span><br><span class="line">                        Log.e(TAG, <span class="string">"Caught post-fork exception in child process."</span>, e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zygote进程 </tag>
            
            <tag> app_process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rxjava2 使用以及源码阅读</title>
      <link href="/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2018/06/15/Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>作为一个没怎么使用过<code>Rxjava2</code>的人来说，要理解<code>Rxjava2</code>的很多东西确实有一些困难，因此我想从<code>Rxjava2</code>的源码来入手，研究一下<code>Rxjava</code>的实现原理，以及体验一下响应式编程的乐趣。<br> <a id="more"></a></p><h1 id="Rxjava2-使用以及源码阅读"><a href="#Rxjava2-使用以及源码阅读" class="headerlink" title="Rxjava2 使用以及源码阅读"></a>Rxjava2 使用以及源码阅读</h1><p>作为一个没怎么使用过<code>Rxjava2</code>的人来说，要理解<code>Rxjava2</code>的很多东西确实有一些困难，因此我想从<code>Rxjava2</code>的源码来入手，研究一下<code>Rxjava</code>的实现原理，以及体验一下响应式编程的乐趣。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>如果你去看关于<code>Rxjava</code>的博客，一般都会介绍到<code>Rxjava</code>使用了一种叫做<code>观察者</code>的设计模式。这个观察者模式是什么呢？按照我们大学老师的原话来说,  观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。具体可参考 <a href="https://blog.csdn.net/lovelion/article/details/7720382" target="_blank" rel="noopener">观察者模式</a>, 顺便说一句，刘伟老师的博客质量还是很好的。</p><p>具体关于观察者模式的定义，可参考GOF的《设计模式》一书。</p><blockquote><p>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p></blockquote><p>如图是观察者模式的UML类图，其中包括主要的几个角色</p><p><img src="/.io//1341501815_4830.jpg" alt="1341501815_4830"></p><ul><li>Subject/ConcrateSubject, 目标又被称为主题，是指被观察的对象（被观察者），目标中定义了一系列的观察者，一个观察者subject可以接受任何数量的观察者，当Subject发生改变，将通过notify方法通知到观察者。</li><li>Observer/ConcreteObserver，观察者, 根据被观察的改变作出具体的反应。</li></ul><p>我们可以想象一种场景，当你在玩节奏大师这个游戏的时候，抱歉我没有玩过，游戏就是Subject，你就是Observer，当游戏中出现音符后，你就需要点击对应的音符。游戏作为Subject，它产生了一些列的音符，当它出现时，会通知到你，进而你可以对Subject的改变做一些其他的事情。</p><h3 id="Rxjava源码分析"><a href="#Rxjava源码分析" class="headerlink" title="Rxjava源码分析"></a>Rxjava源码分析</h3><h4 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h4><p>观察者模式说完，在正式的介绍Rxjava之前，我们需要了解一个概念叫做<code>背压(BackPressure)</code>，想象你还在玩节奏大师，你需要根据游戏来做一些反馈，这有点类似生产者消费者模型，游戏作为生产者，一直在生产各种音符(在Rxjava被称为发射emit)，你作为消费者，你对音符需要点击，长按等操作。但是，如果音符出现的特别快，我们就会有一种处理不过来的感觉。这就是背压。</p><blockquote><p>生产者（被观察者）的生产速度大于消费者（观察者）消费速度，就会产生背压</p></blockquote><p>了解背压，我们就可以分析<code>Rxjava</code>的实现了，源码是参考<code>Rxjava2</code>的最新代码,，我没有用过<code>Rxjava 1.x</code>版本。首先我们知道<code>Rxjava</code>使用了观察者模式。那么我们首先来分析一下<code>Rxjava</code>中的观察者模式中的目标(Subject)，即被观察者， Rxjava中有很多已经实现了的被观察者，包括 <code>Observable</code> ，<code>Flowable</code>，<code>Single</code>，<code>Completable</code>，<code>Maybe。</code>具体的阐述与区别如下表。</p><table><thead><tr><th>观察者</th><th>应用场景</th></tr></thead><tbody><tr><td><code>Observable</code></td><td>不支持背压，适用于数据量不是很大的生产者消费者模型，一般官方推荐低于1k，数据量过大可能会导致资源暂用，表现出来的形式就是系统卡顿或者OOM</td></tr><tr><td><code>Flowable</code></td><td>与<code>Observable</code>的不同之处在于支持背压，通过设置缓存等方式控制生产者的生产数量。</td></tr><tr><td><code>Single</code></td><td>适用于单一事件流，即生产者只会生产一个数据(onNext)，接着就是完成(onComplete)或者出错(onError)</td></tr><tr><td><code>Completable</code></td><td>如果消费者不关心生产者任何的数据，只需要关注完成或者出错</td></tr><tr><td><code>Maybe</code></td><td>类似<code>Single</code>于<code>Completable</code>混合体，可能存在事件也可能不存在</td></tr></tbody></table><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>如下，一个典型的Rxjava的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable</span><br><span class="line">                .create((ObservableOnSubscribe&lt;Integer&gt;) observableEmitter -&gt; &#123;</span><br><span class="line">                    observableEmitter.onNext(<span class="number">10</span>);</span><br><span class="line">                    observableEmitter.onComplete();</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(integer -&gt; <span class="keyword">new</span> RuntimeException().printStackTrace(),</span><br><span class="line">                        Throwable::printStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException</span><br><span class="line">at Main.lambdamain1(Main.java:11)</span><br><span class="line">at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63)</span><br><span class="line">at io.reactivex...ObservableCreate$CreateEmitter.onNext(ObservableCreate.java:67)</span><br><span class="line">at Main.lambdamain0(Main.java:8)</span><br><span class="line">at io.reactivex.internal...ObservableCreate.subscribeActual(ObservableCreate.java:40)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:12051)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:12037)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:11966)</span><br><span class="line">at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>可以看出来大概的调用流程是，通过<code>subscribe</code>绑定观察者之后，通过调用被观察者的<code>subscribeActual</code>接口，进而最终调用到观察者的<code>onNext</code>等方法。了解大致的流程，后面就可以分析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## Observable.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line"></span><br><span class="line">##Observer.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//提供的Disposable接口，方便在随时时解除观察者的订阅，一般在subscribeActual中最开始初始化Disposable之后调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span></span>;</span><br><span class="line">    <span class="comment">//提供新的数据给到观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T t)</span></span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span></span>;</span><br><span class="line"><span class="comment">//数据分发完成</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Disposable.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当Observer不再关注Observable的改变时，可通过调用此接口解除关联。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><p>首先我们分析Rxjava中的通用被观察者<code>Observable</code>。<code>Observable</code>用来是生成被观察的序列，对象等的方式。<code>Observable</code>类中大约15000多行代码，大部分的函数都是静态函数和一些流式方法。在理解Observable之前我们需要能看懂一些常用的图，这些也是在很多介绍Rxjava都会遇到。如下，</p><p><img src="/.io//legend.png" alt="legend"></p><p>Observable提供了一系列的操作符，所有的操作参考下面表格</p><table><thead><tr><th align="center">操作符</th><th align="center">简要介绍</th></tr></thead><tbody><tr><td align="center">创建操作</td><td align="center">用于创建Observable的操作符，一般都是静态方法</td></tr><tr><td align="center">变换操作</td><td align="center">这些操作符可用于对Observable发射的数据进行变换</td></tr><tr><td align="center">过滤操作</td><td align="center">这些操作符用于从Observable发射的数据中进行选择</td></tr><tr><td align="center">组合操作</td><td align="center">组合操作符用于将多个Observable组合成一个单一的Observable</td></tr><tr><td align="center">错误处理</td><td align="center">这些操作符用于从错误通知中恢复</td></tr><tr><td align="center">辅助操作</td><td align="center">一组用于处理Observable的操作符</td></tr><tr><td align="center">条件和布尔操作</td><td align="center">这些操作符可用于单个或多个数据项，也可用于Observable</td></tr><tr><td align="center">算术和聚合操作</td><td align="center">这些操作符可用于整个数据序列</td></tr><tr><td align="center">连接操作</td><td align="center">一些有精确可控的订阅行为的特殊Observable</td></tr><tr><td align="center">转换操作</td><td align="center">将Observable转换为其它的对象或数据结构， 阻塞Observable等</td></tr></tbody></table><h5 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h5><p>创建操作常用的操作符有<code>Create</code>, <code>Defer</code>, <code>Empty/Never/Error</code>, <code>From</code>, <code>Interval</code>, <code>Just</code>, <code>Range</code>, <code>Repeat</code>, <code>Start</code>, <code>Timer</code>。我们一个个来看具体的实现。</p><blockquote><p> Rxjava并不是完整的按照观察者模式来实现的。在Rxjava中看起来更像是Observable订阅了Observer，与观察者模式反着来的，原因是为了使用流式编程作出的妥协，这样虽然逻辑上可能有点绕，但是对代码风格的统一却起着巨大作用。刚入门可能会因为这个被绕晕，了解了就知道这个是什么情况了。</p></blockquote><h6 id="Create"><a href="#Create" class="headerlink" title="# Create"></a># Create</h6><p>通过自定义ObservableOnSubscribe接口创建一个ObservableCreate对象，ObservableCreate中包含一个ObservableOnSubscribe的属性。从代码中我们可以看出创建了一个被观察者ObservableCreate，并且提供了subscribe方法来订阅观察者（Observable订阅了Observer），绑定了一个ObservableEmitter用来发送数据</p><p><img src="/.io//create.png" alt="create"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableCreate.java</span><br><span class="line"><span class="comment">//具体观察者，继承Observable，实现其抽象方法subscribeActual</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Dispose并调用observer的onSubscribe方法，将Dispose传递到Onbserver中</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用ObservableOnSubscribe的subscribe方法，这个接口是我们创建，作为create参数传入的，里面一般会调用传入的Emitter发射器的onNext，onError或者onComplete方法。此处Rxjava专门实现了一套对应的CreateEmitter类，即parent</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发射器，在Observer之上封装一层</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line">    CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判空，Rxjava2不允许onNext传入参数为null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            onError(<span class="keyword">new</span> NullPointerException(...));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否已解除监听</span></span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            observer.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">            RxJavaPlugins.onError(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                observer.onError(t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dispose();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                observer.onComplete();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableOnSubscribe.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableEmitter.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(Disposable d)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(Cancellable c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Emitter.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Defer"><a href="#Defer" class="headerlink" title="# Defer"></a># Defer</h6><p>介绍完Create我们来看另一个创建操作符Defer，Defer字面意思是推迟，即在运行subscribe才会去创建Observable，每个观察者被订阅的时候都重新创建被观察者，如图所示：<img src="/.io//defer.png" alt="defer"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">defer</span><span class="params">(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(supplier, <span class="string">"supplier is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableDefer&lt;T&gt;(supplier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableDefer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableDefer</span><span class="params">(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        ObservableSource&lt;? extends T&gt; pub;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过Callable接口，实现真正执行的时候重新创建Observable</span></span><br><span class="line">            pub = ObjectHelper.requireNonNull(supplier.call(), <span class="string">"null ObservableSource supplied"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(t);</span><br><span class="line">            EmptyDisposable.error(t, s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pub.subscribe(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Empty-Never-Error"><a href="#Empty-Never-Error" class="headerlink" title="# Empty/Never/Error"></a># Empty/Never/Error</h6><p>这几个使用场景比较单一，常用了作为测试用途。</p><p><code>empty</code>操作符不会发送任何数据，而是直接发送<code>onComplete</code>事件。</p><p><img src="/.io//empty.c.png" alt="empty.c"></p><p><code>never</code>什么都不会发送的操作符，也不会触发观察者任何的回调，通常用于“测试”用途。</p><p><img src="/images/placeholder.png" alt="never.c" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/never.c.png" class="lazyload"></p><p><code>Error</code>操作符就是调用时候直接发送onError事件给观察者：</p><p><img src="/images/placeholder.png" alt="error" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/error.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly((Observable&lt;T&gt;) ObservableEmpty.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableEmpty.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableEmpty</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">ScalarCallable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Observable&lt;Object&gt; INSTANCE = <span class="keyword">new</span> ObservableEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObservableEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Object&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用了Observer的onComplete方法</span></span><br><span class="line">        <span class="comment">//EmptyDisposable.complete</span></span><br><span class="line">        <span class="comment">//o.onSubscribe(INSTANCE);</span></span><br><span class="line">        <span class="comment">//o.onComplete();</span></span><br><span class="line">        EmptyDisposable.complete(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// null scalar is interpreted as being empty</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">error</span><span class="params">(Callable&lt;? extends Throwable&gt; errorSupplier)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(errorSupplier, <span class="string">"errorSupplier is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableError&lt;T&gt;(errorSupplier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableError.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableError</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends Throwable&gt; errorSupplier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableError</span><span class="params">(Callable&lt;? extends Throwable&gt; errorSupplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorSupplier = errorSupplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        Throwable error;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            error = ObjectHelper.requireNonNull(errorSupplier.call(), ...);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(t);</span><br><span class="line">            error = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用了Observer的onError方法</span></span><br><span class="line">        <span class="comment">//s.onSubscribe(INSTANCE);</span></span><br><span class="line">        <span class="comment">//s.onError(error);</span></span><br><span class="line">        EmptyDisposable.error(error, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">error</span><span class="params">(<span class="keyword">final</span> Throwable exception)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(exception, <span class="string">"e is null"</span>);</span><br><span class="line">    <span class="comment">//把exception封装成Callable</span></span><br><span class="line">    <span class="keyword">return</span> error(Functions.justCallable(exception));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">never</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly((Observable&lt;T&gt;) ObservableNever.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableNever.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableNever</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Observable&lt;Object&gt; INSTANCE = <span class="keyword">new</span> ObservableNever();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObservableNever</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Object&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只是创建了一个NEVER disposable的EmptyDisposable, 无其他操作</span></span><br><span class="line">        o.onSubscribe(EmptyDisposable.NEVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="From"><a href="#From" class="headerlink" title="# From"></a># From</h6><p><code>from</code>是一系列from的集合，包括fromArray，fromCallable，fromFuture，fromIterable，fromPublisher，此处列举fromArray，fromCallable其他的实现大同小异。</p><p><img src="/images/placeholder.png" alt="from" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/from.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">fromArray</span><span class="params">(T... items)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(items, <span class="string">"items is null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (items.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (items.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> just(items[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFromArray&lt;T&gt;(items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableFromArray.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableFromArray</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableFromArray</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        FromArrayDisposable&lt;T&gt; d = <span class="keyword">new</span> FromArrayDisposable&lt;T&gt;(s, array);</span><br><span class="line">        s.onSubscribe(d);</span><br><span class="line">        <span class="keyword">if</span> (d.fusionMode) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FromArrayDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicQueueDisposable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line">    <span class="keyword">final</span> T[] array;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">boolean</span> fusionMode;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> disposed;</span><br><span class="line"></span><br><span class="line">    FromArrayDisposable(Observer&lt;? <span class="keyword">super</span> T&gt; actual, T[] array) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actual = actual;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T[] a = array;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; !isDisposed(); i++) &#123;</span><br><span class="line">            T value = a[i];</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                actual.onError(<span class="keyword">new</span> NullPointerException(<span class="string">"The "</span> + i + <span class="string">"th element is null"</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            actual.onNext(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            actual.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">fromCallable</span><span class="params">(Callable&lt;? extends T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(supplier, <span class="string">"supplier is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFromCallable&lt;T&gt;(supplier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableFromCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends T&gt; callable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableFromCallable</span><span class="params">(Callable&lt;? extends T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        DeferredScalarDisposable&lt;T&gt; d = <span class="keyword">new</span> DeferredScalarDisposable&lt;T&gt;(s);</span><br><span class="line">        s.onSubscribe(d);</span><br><span class="line">        <span class="keyword">if</span> (d.isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = ObjectHelper.requireNonNull(callable.call(), <span class="string">"Callable returned null"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="keyword">if</span> (!d.isDisposed()) &#123;</span><br><span class="line">                s.onError(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RxJavaPlugins.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d.complete(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectHelper.requireNonNull(callable.call(), <span class="string">"The callable returned a null value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Interval"><a href="#Interval" class="headerlink" title="# Interval"></a># Interval</h6><p>每个固定的时间创建一个<code>Observable&lt;Integer&gt;</code></p><p><img src="/images/placeholder.png" alt="interval" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/interval.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line"><span class="comment">//scheduler默认为COMPUTATION，关于scheduler的详细解释，见下文</span></span><br><span class="line">    ObjectHelper.requireNonNull(unit, <span class="string">"unit is null"</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableInterval(Math.max(<span class="number">0L</span>, initialDelay), Math.max(<span class="number">0L</span>, period), unit, scheduler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableInterval.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableInterval</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> initialDelay;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line">    <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableInterval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialDelay = initialDelay;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.unit = unit;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Long&gt; s)</span> </span>&#123;</span><br><span class="line">        IntervalObserver is = <span class="keyword">new</span> IntervalObserver(s);</span><br><span class="line">        s.onSubscribe(is);</span><br><span class="line"></span><br><span class="line">        Scheduler sch = scheduler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Scheduler实现</span></span><br><span class="line">        <span class="keyword">if</span> (sch <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            Worker worker = sch.createWorker();</span><br><span class="line">            is.setResource(worker);</span><br><span class="line">            worker.schedulePeriodically(is, initialDelay, period, unit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit);</span><br><span class="line">            is.setResource(d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalObserver</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Disposable</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Long&gt; actual;</span><br><span class="line">        <span class="keyword">long</span> count;</span><br><span class="line">        IntervalObserver(Observer&lt;? <span class="keyword">super</span> Long&gt; actual) &#123;</span><br><span class="line">            <span class="keyword">this</span>.actual = actual;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (get() != DisposableHelper.DISPOSED) &#123;</span><br><span class="line">                actual.onNext(count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Just"><a href="#Just" class="headerlink" title="# Just"></a># Just</h6><p>对于只是发送几个数据来说，可以使用just操作符来简化, 如下，调用流程<code>onNext(&quot;test&quot;)</code>, <code>onNext(&quot;test1&quot;)</code>, <code>onNext(&quot;test2&quot;)</code>, 然后调用<code>onComplete()</code>, <code>Just</code>最多支持10个参数，除了一个参数的外，其他都是直接调用<code>fromArray</code>，一个参数的<code>Just</code>，具体实现与fromArray基本一致，在此不表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"test"</span>,<span class="string">"test2"</span>,<span class="string">"test3"</span>)</span><br><span class="line">        .subscribe(<span class="comment">//doSomething);</span></span><br></pre></td></tr></table></figure><p><img src="/images/placeholder.png" alt="just" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/just.png" class="lazyload"></p><h6 id="Range"><a href="#Range" class="headerlink" title="# Range"></a># Range</h6><p>如果需要确定一个反射数据的范围可以采用range或者是rangeLong，后者的数据类型是long，可以使用的范围更加广，其他完全是一样的。第一个参数作为起始值，第二个参数作为数量。</p><p><img src="/images/placeholder.png" alt="range.c" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/range.c.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Integer&gt; <span class="title">range</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> start, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &gt;= 0 required but it was "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> just(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过最大整形允许范围直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)start + (count - <span class="number">1</span>) &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Integer overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableRange(start, count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableRange.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableRange</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = (<span class="keyword">long</span>)start + count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Integer&gt; o)</span> </span>&#123;</span><br><span class="line">        RangeDisposable parent = <span class="keyword">new</span> RangeDisposable(o, start, end);</span><br><span class="line">        o.onSubscribe(parent);</span><br><span class="line">        parent.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeDisposable</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Integer&gt; actual;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">long</span> index;</span><br><span class="line">        <span class="keyword">boolean</span> fused;</span><br><span class="line"></span><br><span class="line">        RangeDisposable(Observer&lt;? <span class="keyword">super</span> Integer&gt; actual, <span class="keyword">long</span> start, <span class="keyword">long</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.actual = actual;</span><br><span class="line">            <span class="keyword">this</span>.index = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fused) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Observer&lt;? <span class="keyword">super</span> Integer&gt; actual = <span class="keyword">this</span>.actual;</span><br><span class="line">            <span class="keyword">long</span> e = end;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = index; i != e &amp;&amp; get() == <span class="number">0</span>; i++) &#123;</span><br><span class="line">                actual.onNext((<span class="keyword">int</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (get() == <span class="number">0</span>) &#123;</span><br><span class="line">                lazySet(<span class="number">1</span>);</span><br><span class="line">                actual.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于其他的创建操作符大致实现原理基本相同，不在此重复。</p><h5 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h5><p>对Observable发射的数据进行一系列变换，常用的操作符如<code>map</code>,<code>flatMap</code>,<code>flatMapIterable</code>,<code>concatMap</code>,<code>swicthMap</code>,<code>cast</code>,<code>scan</code>,<code>buffer</code>,<code>toList</code>,<code>groupBy</code>,<code>toMap</code>.</p><h6 id="map"><a href="#map" class="headerlink" title="# map"></a># map</h6><p>作为最长用的变换操作符我们首先来说一下<code>map</code>，可以把每一个元素转换成新的元素发射，接收一个<code>Function&lt;T,R&gt;</code>作为转换逻辑的操作。大致使用</p><p><img src="/images/placeholder.png" alt="map" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/map.png" class="lazyload"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .map(integer -&gt; <span class="number">10</span> * integer)</span><br><span class="line">        .subscribe(ele -&gt; Log.i(<span class="string">"tag"</span>, String.valueOf(ele)));</span><br></pre></td></tr></table></figure><p>注意我们此处是不会改变发射数据的数量，只改变元素的。接下来看代码具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">##Observable.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">    <span class="comment">//传入当前的被观察者与mapper</span></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##ObservableMap.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//与我们的之前分析的观察者与被观察之间的调用相同，其实如果我们看ObservableMap的具体继承，我们会发现其实ObservableMap也是一个被观察者，即map会产生一个新的被观察者对象，但是只有一个。发射的数据会创建多个。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(actual);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">                actual.onNext(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//map操作mapper.apply(t)</span></span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            actual.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="flatMap"><a href="#flatMap" class="headerlink" title="# flatMap"></a># flatMap</h6><p><code>Map</code>操作符是把每一个元素转换成一个新的元素，但是<code>flatMap</code>操作符是把每一个元素转换成新的被观察者，每个被观察者发射的元素将会合并成新的被观察者。例如下面的：</p><p><img src="/images/placeholder.png" alt="flatMap.c" data-src="Rxjava2%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/flatMap.c.png" class="lazyload"></p><p><code>flatMap</code>一个很有用的场景是，当Observable发射一系列拥有Observable成员或以其他方式可转换为Observable的数据时，<code>flatMap</code>会合并这些数据，以便它们交错。举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">                .flatMap((Function&lt;Integer, ObservableSource&lt;?&gt;&gt;) integer -&gt; Observable.just(<span class="string">"a"</span>, String.valueOf(integer)))</span><br><span class="line">                        .subscribe(System.out::print);</span><br><span class="line"></span><br><span class="line">输出结果是: a1a2a3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActivityThread 阅读之旅</title>
      <link href="/2018/06/13/ActivityThread%20%E9%98%85%E8%AF%BB%E4%B9%8B%E6%97%85/"/>
      <url>/2018/06/13/ActivityThread%20%E9%98%85%E8%AF%BB%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>研究一下App是如何启动的记录。我们知道<code>Main</code>函数是所有java程序的入口，Android也不例外，同样，启动一个应用程序，Android也会首先调用<code>Main</code>函数。<code>Main</code>函数位于<code>AcitivityThread</code>类中。<br> <a id="more"></a></p><h1 id="ActivityThread-阅读之旅"><a href="#ActivityThread-阅读之旅" class="headerlink" title="ActivityThread 阅读之旅"></a>ActivityThread 阅读之旅</h1><p>研究一下App是如何启动的记录。</p><p>我们知道<code>Main</code>函数是所有java程序的入口，Android也不例外，同样，启动一个应用程序，Android也会首先调用<code>Main</code>函数。<code>Main</code>函数位于<code>AcitivityThread</code>类中。</p><p>我们首先看<code>Main</code>函数的实现。</p><h6 id="framework-base-core-java-android-app-ActivityThread-java"><a href="#framework-base-core-java-android-app-ActivityThread-java" class="headerlink" title="framework/base/core/java/android/app/ActivityThread.java"></a>framework/base/core/java/android/app/ActivityThread.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Environment环境变量</span></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建MainLooper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下：</p><h6 id="1-Environment的初始化"><a href="#1-Environment的初始化" class="headerlink" title="1. Environment的初始化"></a>1. Environment的初始化</h6><p>其中我们可以看到<code>main</code>函数先初始化了<code>Environment</code>类，<code>Environment</code>中会初始化一系列与环境路径相关的操作，在App中可以直接使用类似Environment.getDataDirectory等接口进行访问.</p><h6 id="2-Looper相关初始化"><a href="#2-Looper相关初始化" class="headerlink" title="2. Looper相关初始化"></a>2. Looper相关初始化</h6><p><code>ActivityThread</code>通过调用<code>Looper.prepareMainLooper()</code>方法创建MainLopper，具体操作如下，先通过prepare方法创建一个不可退出的Looper作为MainLooper, 关于ThreadLocal相关的使用可以参见具体的博客等，此处不再赘述。值得一提的是，由于<code>prepare(boolean quitAllowed)</code>是私有方法，应用无法调用。但此处存在两个疑问：</p><blockquote><ol><li>在主线程调用了<code>prepareMainLooper</code>会出现什么情况?  直接出现异常</li><li>在子线程调用了<code>prepareMainLooper</code>会出现什么情况?  创建另外一个线程的MainLooper</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-ActivityThread的创建"><a href="#3-ActivityThread的创建" class="headerlink" title="3. ActivityThread的创建"></a>3. ActivityThread的创建</h6><p><code>ActivityThread</code>构造函数中创建了一个叫做mResourcesManager的实例，ResourcesManager是一个单例类，一些关于资源的配置，引用与实现都在此处实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread() &#123;</span><br><span class="line">    mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着会去调用<code>attach(false)</code>方法，此方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给成员变量赋值，可以通过ActivityThread.currentActivityThread()或者ActivityThread.isSystem()获取</span></span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//保证VM JIT实时编译打开</span></span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mAppThread是沟通AMS与ActivityThread的桥梁</span></span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//mgr会通过调用mAppThread中的一系列方法实现对Activity的控制</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">"Dalvik max="</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" total="</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" used="</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略system进程判断</span></span><br><span class="line">    <span class="comment">// add dropbox logging to libcore</span></span><br><span class="line">    DropBox.setReporter(<span class="keyword">new</span> DropBoxReporter());</span><br><span class="line">    ViewRootImpl.addConfigCallback(globalConfig -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">          <span class="comment">// We need to apply this change to the resources immediately, because upon returning</span></span><br><span class="line">          <span class="comment">// the view hierarchy will be informed about it.</span></span><br><span class="line">          <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig,</span><br><span class="line">                  <span class="keyword">null</span> <span class="comment">/* compat */</span>)) &#123;</span><br><span class="line">              updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),</span><br><span class="line">                      mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">              <span class="comment">// This actually changed the resources! Tell everyone about it.</span></span><br><span class="line">              <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span></span><br><span class="line">                      || mPendingConfiguration.isOtherSeqNewer(globalConfig)) &#123;</span><br><span class="line">                  mPendingConfiguration = globalConfig;</span><br><span class="line">                  sendMessage(H.CONFIGURATION_CHANGED, globalConfig);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要额外解释的是<code>ApplicationThread</code>中包含了一系列的<code>schedule</code>方法, 例如<code>schedulePauseActivity</code>, <code>scheduleStopActivity</code>等，这些方法都是直接通过<code>sendMessage</code>把对应的实现交给<code>ActivityThread</code>的<code>H extends Handler</code>类负责处理, <code>H</code>收到这些消息后，交给对应的<code>handle</code>方法，<code>handle</code>经过一系列的判断条件，最终调用<code>perform</code>接口实现功能，而<code>perform</code>就直接使用<code>Activity</code>中的方法，完成对<code>Activity</code>整个生命周期的控制。</p><h6 id="4-sMainThreadHandler的初始化"><a href="#4-sMainThreadHandler的初始化" class="headerlink" title="4. sMainThreadHandler的初始化"></a>4. sMainThreadHandler的初始化</h6><p>首先解决一下这个sMainThreadHandler的具体实现问题， 可以看到<code>ActivityThread</code>中关于<code>getHandler</code>只是直接返回了成员变量<code>mH</code>,即我们上文说道的处理<code>ApplicationThread</code>的具体实现的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外这个<code>sMainThreadHandler</code>的具体作用是什么呢，目前整个framework中只有一处使用了这个成员变量, 在<code>SharedPreferencesImpl</code>中的内部类<code>EditorImpl</code>的<code>notifyListeners</code>中，目的是把的对应的回调放到主线程中。私认为这不是一个很好的处理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mcr.listeners == <span class="keyword">null</span> || mcr.keysModified == <span class="keyword">null</span> ||</span><br><span class="line">        mcr.keysModified.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mcr.keysModified.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> String key = mcr.keysModified.get(i);</span><br><span class="line">            <span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Run this function on the main thread.</span></span><br><span class="line">        ActivityThread.sMainThreadHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    notifyListeners(mcr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-Loop循环"><a href="#5-Loop循环" class="headerlink" title="5. Loop循环"></a>5. Loop循环</h6><p>正式的启动主线程循环，主体代码如下。主要就是从当前Looper，即<code>MainLooper</code>中拿到所有的<code>message</code>, 然后调用其中的<code>dispatchMessage</code>方法。<code>dispatchMessage</code>会分发给对应的callback,然后根据判断决定最终的调用，比如说<code>handleMessage</code>方法，这也是我们经常使用的<code>Handler</code>收到<code>msg</code>后处理的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//去除一些打印等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler</code>中关于<code>dispatchMessage</code>的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们可以看到<code>ActivityThread</code>中完整了初始化的操作，绑定<code>ApplicationThread</code>与<code>AMS</code>, 启动主线程循环等。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App启动流程 </tag>
            
            <tag> Main Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Framebuffer相关学习</title>
      <link href="/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/06/01/Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>本文主要内容：</p><ul><li>TFT-LCD显示过程分析</li><li>framebuffer的基本原理</li><li>画面延迟、撕裂分析</li></ul><a id="more"></a><p>本文主要内容：</p><ul><li>TFT-LCD显示过程分析</li><li>framebuffer的基本原理</li><li>画面延迟、撕裂分析</li></ul><h2 id="1、TFT-LCD显示过程简要分析-硬件层面"><a href="#1、TFT-LCD显示过程简要分析-硬件层面" class="headerlink" title="1、TFT-LCD显示过程简要分析(硬件层面)"></a>1、TFT-LCD显示过程简要分析(硬件层面)</h2><p>从硬件层面来说, TFT显示器参数vsync,hsync,hspw,hbpd,hfpd,vspw,vbp,vfp等参数很多都是从CRT带来的。描述方式多数显示器选择从左上角开始, 从左至右, 到了右边界, 再偏转到左边界的下一行, 这是所谓的”Z”型扫描。类似地扫描完最后一帧时, 要偏转回左上角起始处, 准备扫描下一帧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hsync #一行有效数据扫描完成后, 转到下一行起始处</span><br><span class="line">vsync #一帧数据扫描完成后，转到左上角起始处</span><br><span class="line"></span><br><span class="line">vbp #表示在一帧图像开始时，垂直同步信号以后的无效的行数，对应驱动中的upper_margin</span><br><span class="line">vfp #表示在一帧图像结束后，垂直同步信号以前的无效的行数，对应驱动中的lower_margin</span><br><span class="line">vspw #表示垂直同步脉冲的宽度，用行数计算，对应驱动中的vsync_len</span><br><span class="line"></span><br><span class="line">hbp #表示从水平同步信号开始到一行的有效数据开始之间的VCLK的个数，left_margin</span><br><span class="line">hfp #表示一行的有效数据结束到下一个水平同步信号开始之间的VCLK的个数，right_margin</span><br><span class="line">hspw #表示水平同步脉冲的宽度，用VCLK(像素时钟信号)计算，对应驱动中的hsync_len</span><br></pre></td></tr></table></figure><p>扫描一行的时序</p><blockquote><p>hspw -&gt; hbp -&gt; 扫描数据 -&gt; hfp -&gt; hspw</p></blockquote><p>扫描一帧的时序</p><blockquote><p>vspw -&gt; vbp -&gt; 扫描有效行 -&gt; vfp -&gt; vspw</p></blockquote><p><img src="/.io//example.png" alt="example"></p><p>所有这些操作都是通过外部总线接口(EBI)实现在内存与其他外部操作实现数据的传输与控制。</p><h2 id="2、framebuffer的基本原理-软件方面"><a href="#2、framebuffer的基本原理-软件方面" class="headerlink" title="2、framebuffer的基本原理(软件方面)"></a>2、framebuffer的基本原理(软件方面)</h2><p>framebuffer，也叫帧缓冲，其内容对应于屏幕上的界面显示，可以将其简单理解为屏幕上显示内容对应的缓存，修改Framebuffer中的内容，即表示修改屏幕上的内容(具体如上硬件分析)，所以，直接操作Framebuffer可以直接从显示器上观察到效果。</p><p>framebuffer是逻辑上的概念，对应物理上是一段存储空间，其可以位于显存，也可以位于内存。</p><h4 id="framebuffer基本使用"><a href="#framebuffer基本使用" class="headerlink" title="framebuffer基本使用"></a>framebuffer基本使用</h4><p>查看显示参数</p><ul><li>分辨率<br> <code>cat /sys/class/graphics/fb0/modes</code></li><li>虚拟大小<br> <code>cat /sys/class/graphics/fb0/virtual_size</code></li></ul><p>更多如图</p><p><img src="/.io//sys-class.png" alt="syc"></p><p>基本编程使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fb;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* fb_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the file for reading and writing</span></span><br><span class="line">    fd = open(<span class="string">"/dev/graphics/fb0"</span>, O_RDWR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Get fixed screen information</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get variable screen information</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Map the device to memory</span></span><br><span class="line">    fb_mem = (<span class="keyword">char</span> *)mmap(<span class="number">0</span>, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="framebuffer实现"><a href="#framebuffer实现" class="headerlink" title="framebuffer实现"></a>framebuffer实现</h4><p>Linux是工作在保护模式下，所以用户态进程是无法直接使用显卡提供的中断调用来实现直接写屏，Linux抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。</p><p>framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过framebuffer的读写直接对显存进行操作。framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过framebuffer的读写直接对显存进行操作。</p><p>这种操看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由framebuffer设备驱动来完成的。</p><p>framebuffer属性分为可变(variable)与不可变(fixed), 可直接通过ioctl获取与修改。</p><p>获取fixed属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo)</span><br></pre></td></tr></table></figure><p>获取variable属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, FBIOGET_VSCREENINFO, &amp;vinfo)</span><br></pre></td></tr></table></figure><p>设置variable属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, FBIOPUT_VSCREENINFO, &amp;vinfo)</span><br></pre></td></tr></table></figure><p>可修改属性 fb_var_screeninfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//可见分辨率</span></span><br><span class="line">    __u32 xres;</span><br><span class="line">    __u32 yres;</span><br><span class="line">    <span class="comment">//虚拟分辨率</span></span><br><span class="line">    __u32 xres_virtual;</span><br><span class="line">    __u32 yres_virtual;</span><br><span class="line">    <span class="comment">//虚拟分辨率的偏移</span></span><br><span class="line">    __u32 xoffset;</span><br><span class="line">    __u32 yoffset;</span><br><span class="line">    <span class="comment">//bpp 像素深度-&gt;每个像素所占的bit数</span></span><br><span class="line">    __u32 bits_per_pixel;</span><br><span class="line">    <span class="comment">//灰度值</span></span><br><span class="line">    __u32 grayscale;</span><br><span class="line">    <span class="comment">//RGB位域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span></span><br><span class="line">    <span class="comment">//是否标准像素格式</span></span><br><span class="line">    __u32 nonstd;</span><br><span class="line">    <span class="comment">//设置生效时机</span></span><br><span class="line">    __u32 activate;</span><br><span class="line">    <span class="comment">//图像实际(毫米)</span></span><br><span class="line">    __u32 height;</span><br><span class="line">    __u32 width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬件相关</span></span><br><span class="line">    __u32 pixclock;</span><br><span class="line">    __u32 left_margin;</span><br><span class="line">    __u32 right_margin;</span><br><span class="line">    <span class="comment">//vbp</span></span><br><span class="line">    __u32 upper_margin;</span><br><span class="line">    __u32 lower_margin;</span><br><span class="line">    __u32 hsync_len;</span><br><span class="line">    __u32 vsync_len;</span><br><span class="line"></span><br><span class="line">    __u32 sync;</span><br><span class="line">    __u32 vmode;</span><br><span class="line">    <span class="comment">//保留</span></span><br><span class="line">    __u32 reserved[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/.io//var-info.png" alt="varInfo"></p><p>以上的参数对应在EBI与显示器的参数如图：</p><p><img src="/.io//sync.png" alt="sync"></p><p>不可变属性 fb_fix_screeninfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line">    <span class="comment">//name</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//framebuffer物理起始地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> smem_start;</span><br><span class="line">    <span class="comment">//长度,字节为单位</span></span><br><span class="line">    __u32 smem_len;</span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 type_aux;</span><br><span class="line">    __u32 visual;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pan切换图像的不同可见区域</span></span><br><span class="line">    __u16 xpanstep;</span><br><span class="line">    __u16 ypanstep;</span><br><span class="line">    __u16 ywrapstep;</span><br><span class="line">    <span class="comment">//一行字节数</span></span><br><span class="line">    __u32 line_length;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//保留</span></span><br><span class="line">    __u16 reserved[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显示、虚拟区域的切换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vinfo.yoffset = <span class="number">0</span>;  <span class="comment">// vinfo.yoffset = vinfo.yres</span></span><br><span class="line">ioctl(fd, FBIOPAN_DISPLAY, &amp;vinfo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">varInfo.yoffset = varInfo.yres * n;</span><br><span class="line">varInfo.activate = FB_ACTIVATE_VBL;</span><br><span class="line">ioctl(frameBufferFd, FBIOPUT_VSCREENINFO, &amp;varInfo);</span><br></pre></td></tr></table></figure><h2 id="3、画面延迟、撕裂分析"><a href="#3、画面延迟、撕裂分析" class="headerlink" title="3、画面延迟、撕裂分析"></a>3、画面延迟、撕裂分析</h2><p>画面撕裂 Screen Tearing 是指显示器把两个或更多的帧（frame）显示在同一画面上。是显示器的刷新率(屏幕刷新率)与设备的显示输入(帧率)不同步发生的一种现象，首先介绍两个几个相关概念。<br><img src="/.io//tearing.png" alt="tearing"></p><h4 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h4><p>即 Refresh Rate 或 Scanning Frequency，单位赫兹Hz，是指设备刷新屏幕的频率，该值对于特定的设备来说是个常量，其数值是显示器每秒钟更新画面的次数。不同的显示器支持再不同分辨率下的不同刷新率。它的范围可以从低到60高到100。如果你设置了一个特定的刷新率，显示器将一直按照这个速率刷新画面。甚至画面没有任何的改变。</p><h4 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h4><p>即 Frame Per Rate，单位 fps，是指 gpu 生成帧的速率，越高越好。它显示显卡在每秒钟可以描画多少画面。但是对于快速变化的游戏而言，你的FPS很难一直保持同样的数值，他会随着你所看到的显示卡所要描画的画面的复杂程度而变化。</p><p>维基百科中关于帧率数值的描述<a href="https://zh.wikipedia.org/wiki/帧率" target="_blank" rel="noopener">^1</a>：</p><ul><li>12 fps：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约10-12帧的时候，就会认为是连贯的</li><li>24 fps：有声电影的拍摄及播放帧率均为每秒24帧，对一般人而言已算可接受</li><li>30 fps：早期的高动态电子游戏，帧率少于每秒30帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低</li><li>60 fps：在实际体验中，60帧相对于30帧有着更好的体验</li><li>85 fps：一般而言，大脑处理视频的极限</li></ul><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>Screen Tearing出现的原因无非两个:</p><ol><li>在display的时候draw(也就是所谓的On Display Draw),  这种情况有可能会出现tearing(也不是必然).</li><li>是在display的时候swap buffer(Flip).</li></ol><h6 id="1-单缓冲方案-无等待"><a href="#1-单缓冲方案-无等待" class="headerlink" title="1. 单缓冲方案 - 无等待"></a>1. 单缓冲方案 - 无等待</h6><p>Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示。</p><p><img src="/images/placeholder.png" alt="no-vsync" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/no-vsync.png" class="lazyload"></p><blockquote><p>Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成</p><p>Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧</p><p>Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理</p><p>Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。“Jank”。</p><p>Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。</p></blockquote><p>单缓冲方案存在的问题:</p><ol><li>画面延迟</li><li>画面撕裂</li></ol><h6 id="2-单缓冲方案-等待"><a href="#2-单缓冲方案-等待" class="headerlink" title="2. 单缓冲方案 - 等待"></a>2. 单缓冲方案 - 等待</h6><p><img src="/images/placeholder.png" alt="with-vsync" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/with-vsync.png" class="lazyload"></p><p>VSync信号出现后，CPU不再犹豫，紧接着就开始执行buffer的准备工作。</p><p>由于大部分的Android显示设备刷新率是60Hz, 这也就意味着每一帧最多只能有1/60=16ms左右的准备时间。</p><ol><li>假如CPU/GPU的FPS高于这个值，那么这个方案是完美的，显示效果将很好。</li><li>CPU/GPU的性能无法满足上图的条件，会产生严重的画面延迟</li></ol><h6 id="3-双-多-缓冲方案-不等待"><a href="#3-双-多-缓冲方案-不等待" class="headerlink" title="3. 双(多)缓冲方案 - 不等待"></a>3. 双(多)缓冲方案 - 不等待</h6><p>完全把多缓冲当做单缓冲用</p><h6 id="3-双缓冲方案-等待"><a href="#3-双缓冲方案-等待" class="headerlink" title="3. 双缓冲方案 - 等待"></a>3. 双缓冲方案 - 等待</h6><p><img src="/images/placeholder.png" alt="double-buffer" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/double-buffer.png" class="lazyload"></p><p>如图采用了A/B双缓冲，以及前面介绍的VSync</p><ol><li>CPU/GPU处理所用的时间时短，但总的来说都在16ms以内，因而不影响显示效果。A和B分别代表两个缓冲区，它们不断地交换来正确显示画面。</li><li>当CPU/GPU的处理时间超过16ms时，第一个VSync到来时，缓冲区B中的数据还没有准备好，于是只能继续显示之前A缓冲区中的内容。而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。当下一个VSync出现时，CPU/GPU马上执行操作，此时它可操作的buffer是A，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li></ol><p><img src="/images/placeholder.png" alt="double-buffer-2" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/double-buffer-2.png" class="lazyload"></p><h6 id="4-三缓冲方案-等待"><a href="#4-三缓冲方案-等待" class="headerlink" title="4. 三缓冲方案 - 等待"></a>4. 三缓冲方案 - 等待</h6><p>第一次的Jank看起来是没有办法的，除非升级硬件配置来加快FPS。我们关注的重点是被CPU/GPU浪费的时间段，怎么才能充分利用起来呢？分析上述的过程，造成CPU/GPU无事可做的假象是因为当前已经没有可用的buffer了.  Triple Buffering是MultipleBuffering的一种，指的是系统使用3个缓冲区用于显示工作。</p><p><img src="/images/placeholder.png" alt="triple-buffer" data-src="Android%E6%A9%A1%E7%9A%AE%E6%93%A6%E9%97%AA%E7%83%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/triple-buffer.png" class="lazyload"></p><p>我们来逐步分析下这个新机制是否有效。首先和预料中的一致，第一次“Jank”无可厚非。不过让人欣慰的是，当第一次VSync发生后，CPU不用再等待了，它会使用第三个buffer C来进行下一帧数据的准备工作。虽然对缓冲区C的处理所需时间同样超过了16ms，但这并不影响显示屏——第2次VSync到来后，它选择buffer B进行显示;而第3次VSync时，它会接着采用C，而不是像double buffering中所看到的情况一样只能再显示一遍了。这样子就有效地降低了系统显示错误的机率。</p><h6 id="5-更多缓冲？"><a href="#5-更多缓冲？" class="headerlink" title="5. 更多缓冲？"></a>5. 更多缓冲？</h6>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framebuffer原理 </tag>
            
            <tag> Screen Tearing </tag>
            
            <tag> 多缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android图形框架的研究之路</title>
      <link href="/2018/04/01/Android%E5%9B%BE%E5%BD%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/04/01/Android%E5%9B%BE%E5%BD%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>Android 目前通用的两种绘图方式是通过 Android 提供的 2D 绘图 API Canvas 与 OpenGL 两种方式实现。</p><p>Canvas 是一个 2D 图形 API，常用来绘制 Android 所有原生和自定义 View 。在 Android 中，Canvas API 通过一个名为 OpenGLRenderer 的绘制库实现硬件加速，该绘制库将 Canvas 运算转换为 OpenGL 运算，以便它们可以在 GPU 上执行。从 Android 4.0 之后开始，强制启用硬件加速。</p> <a id="more"></a><h1 id="Android图形框架的研究之路"><a href="#Android图形框架的研究之路" class="headerlink" title="Android图形框架的研究之路"></a>Android图形框架的研究之路</h1><p>Android 目前通用的两种绘图方式是通过 Android 提供的 2D 绘图 API Canvas 与 OpenGL 两种方式实现。</p><p>Canvas 是一个 2D 图形 API，常用来绘制 Android 所有原生和自定义 View 。在 Android 中，Canvas API 通过一个名为 OpenGLRenderer 的绘制库实现硬件加速，该绘制库将 Canvas 运算转换为 OpenGL 运算，以便它们可以在 GPU 上执行。从 Android 4.0 之后开始，强制启用硬件加速。</p><p>OpenGL ES可以直接把要显示的数据渲染到Surface。</p><h3 id="Android图形组件"><a href="#Android图形组件" class="headerlink" title="Android图形组件"></a>Android图形组件</h3><p>无论使用什么方式绘制，最终都会把绘制内容渲染到Surface中。在 Android 平台上创建的每个窗口都由 Surface 提供支持。显示缓冲队列有一个个 Surface 组成，而缓冲队列通常会被 SurfaceFlinger 消耗。所有被渲染的可见 Surface 都被 SurfaceFlinger 合成到显示部分。</p><p><img src="/.io//graphics.png" alt="raphic"></p><h5 id="Image-Stream-Producers"><a href="#Image-Stream-Producers" class="headerlink" title="Image Stream Producers"></a>Image Stream Producers</h5><p>图像流生产者， 是生成图形缓冲区以供消耗的任何内容。例如 OpenGL ES、Canvas 2D 和 mediaserver 视频解码器等。</p><h5 id="Image-Stream-Consumers"><a href="#Image-Stream-Consumers" class="headerlink" title="Image Stream Consumers"></a>Image Stream Consumers</h5><p>图像流消费者，最常见的是SurfaceFlinger，该系统服务会消耗当前可见的 Surface，并使用窗口管理器中提供的信息将它们合成到显示部分。SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface。</p><p>其他 OpenGL ES 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流。非 GL 应用也可以是消耗方，例如 ImageReader 类。</p><h5 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h5><p>控制窗口的 Android 系统服务，它是视图容器。窗口总是由 Surface 提供支持。该服务会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、Z-Order 以及窗口的其他许多方面。窗口管理器会将所有窗口元数据发送到 SurfaceFlinger，以便 SurfaceFlinger 可以使用该数据在显示部分合成 Surface。</p><h5 id="Hardware-Composer"><a href="#Hardware-Composer" class="headerlink" title="Hardware Composer"></a>Hardware Composer</h5><p>硬件混合渲染器， SurfaceFlinger 可以将某些Surface的合成工作交给 Hardware Composer， 以分担 OpenGL 和 GPU 上的工作量， 是所有 Android 图形渲染的核心</p><h5 id="Gralloc"><a href="#Gralloc" class="headerlink" title="Gralloc"></a>Gralloc</h5><p>图形内存分配器 (Gralloc) 来分配图像生产方请求的内存。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="/.io//graphics_pipeline.png" alt="raphics_pipelin"></p><p>左侧的对象是生成图形缓冲区的渲染器，如主屏幕、状态栏和系统界面。SurfaceFlinger 是合成器，而硬件混合渲染器是制作器。</p><h5 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h5><p>BufferQueues 是 Android 图形组件之间的粘合剂。它们是一对队列，可以调解缓冲区从生产方到消耗方的固定周期。一旦生产方移交其缓冲区，SurfaceFlinger 便会负责将所有内容合成到显示部分。</p><p>BufferQueue 是将缓冲区池与队列相结合的数据结构，它使用 Binder IPC 在进程之间传递缓冲区。BufferQueue 通常用于渲染到 Surface，并且与 GL 消耗方及其他任务一起消耗内容。BufferQueue 可以在三种不同的模式下运行：</p><p>类同步模式 - 默认情况下，BufferQueue 在类同步模式下运行，在该模式下，从生产方进入的每个缓冲区都在消耗方那退出。在此模式下不会舍弃任何缓冲区。如果生产方速度太快，创建缓冲区的速度比消耗缓冲区的速度更快，它将阻塞并等待可用的缓冲区。</p><p>非阻塞模式 - BufferQueue 还可以在非阻塞模式下运行，在此类情况下，它会生成错误，而不是等待缓冲区。在此模式下也不会舍弃缓冲区。这有助于避免可能不了解图形框架的复杂依赖项的应用软件出现潜在死锁现象。</p><p>舍弃模式 - 最后，BufferQueue 可以配置为丢弃旧缓冲区，而不是生成错误或进行等待。例如，如果对纹理视图执行 GL 渲染并尽快绘制，则必须丢弃缓冲区。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android图形架构 </tag>
            
            <tag> Android图形组件 </tag>
            
            <tag> 数据流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
